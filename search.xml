<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Linux tracing 追踪体系</title>
      <link href="/2025/10/30/Linux-tracing-%E8%BF%BD%E8%B8%AA%E4%BD%93%E7%B3%BB/"/>
      <url>/2025/10/30/Linux-tracing-%E8%BF%BD%E8%B8%AA%E4%BD%93%E7%B3%BB/</url>
      
        <content type="html"><![CDATA[<p>本文章由 Qwen3-Max 生成，由作者整理。</p><hr><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://www.kernel.org/doc/html/latest/trace/index.html">Linux Tracing Technologies Guide</a></p><hr><h2 id="Linux-追踪体系概览"><a href="#Linux-追踪体系概览" class="headerlink" title="Linux 追踪体系概览"></a>Linux 追踪体系概览</h2><p>Linux 内核提供了多层次、模块化的追踪基础设施，统称为 Linux Tracing Technologies。其核心目标是：</p><ul><li>观测内核行为（函数调用、中断、调度等）</li><li>分析性能瓶颈（延迟、抖动、锁竞争）</li><li>调试系统异常（死锁、崩溃、资源泄漏）</li></ul><p>主要技术栈包括：</p><ul><li>软件追踪：ftrace、tracepoints、kprobes&#x2F;uprobes、event tracing</li><li>硬件辅助追踪：CoreSight（ARM）、Intel Trace Hub</li><li>专用延迟分析器：irqsoff、preemptoff、osnoise、timerlat</li><li>用户态追踪接口：user_events、tracefs</li></ul><p>所有追踪数据通过统一的 tracefs 文件系统暴露给用户空间（传统通过 debugfs，现推荐 tracefs）。</p><p><img src="/linux_tracing_system.svg"></p><hr><h2 id="静态追踪点-——-Tracepoints-与-Event-Tracing"><a href="#静态追踪点-——-Tracepoints-与-Event-Tracing" class="headerlink" title="静态追踪点 —— Tracepoints 与 Event Tracing"></a>静态追踪点 —— Tracepoints 与 Event Tracing</h2><h3 id="Tracepoints-机制"><a href="#Tracepoints-机制" class="headerlink" title="Tracepoints 机制"></a>Tracepoints 机制</h3><p>Tracepoints 是内核中预定义的静态插桩点，由开发者在关键路径（如调度、内存分配、文件操作）插入。其优势在于：</p><ul><li>开销极低（默认关闭时无影响）</li><li>语义明确，稳定性高</li><li>无需动态指令修改</li></ul><p>每个 tracepoint 需在头文件中定义，并在代码中调用。</p><p>想要自定义追踪点，参考<a href="https://www.kernel.org/doc/html/latest/trace/tracepoints.html">Using the Linux Kernel Tracepoints</a>.</p><h3 id="Event-Tracing-系统"><a href="#Event-Tracing-系统" class="headerlink" title="Event Tracing 系统"></a>Event Tracing 系统</h3><p>Tracepoints 可自动注册为”事件”，通过 &#x2F;sys&#x2F;kernel&#x2F;tracing&#x2F;events&#x2F; 下的目录暴露，可用于跟踪的事件可以在文件 &#x2F;sys&#x2F;kernel&#x2F;tracing&#x2F;available_events 中找到。用户可：</p><ul><li>启用&#x2F;禁用事件</li><li>设置过滤条件（如 pid &#x3D;&#x3D; 123）</li><li>配置触发器（如 stacktrace、snapshot）</li><li>查看事件格式（format 文件）</li></ul><p><strong>并非所有</strong> tracepoint 都支持事件追踪，需开发者提供格式定义。</p><p>该机制无需编写内核模块即可使用。</p><p>具体使用可参考<a href="https://www.kernel.org/doc/html/latest/trace/events.html">Event Tracing</a>.</p><hr><h2 id="ftrace-——-内核函数追踪器"><a href="#ftrace-——-内核函数追踪器" class="headerlink" title="ftrace —— 内核函数追踪器"></a>ftrace —— 内核函数追踪器</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>ftrace（Function Tracer）是 Linux 内核内置的轻量级追踪框架，专为内核开发者设计，用于分析函数调用、延迟、调度行为等。它无需加载额外模块，通过 <code>/sys/kernel/tracing</code>（即 tracefs）暴露控制接口。<strong>ftrace 已经不仅仅是函数追踪器，已经发展成内核的追踪器框架</strong>。ftrace 是内核内置的轻量级追踪框架，支持多种 tracer.</p><h3 id="核心功能"><a href="#核心功能" class="headerlink" title="核心功能"></a>核心功能</h3><ul><li>function tracer：追踪所有内核函数调用。</li><li>function_graph tracer：以类似调用图的方式显示函数入口与返回，支持嵌套深度分析。</li><li>latency tracers：<ul><li><code>irqsoff</code>：追踪中断关闭期间的最大延迟。</li><li><code>preemptoff</code>：追踪抢占关闭期间的延迟。</li><li><code>preemptirqsoff</code>：同时追踪中断与抢占关闭。</li><li><code>wakeup</code> &#x2F; <code>wakeup_rt</code>：追踪高优先级任务被唤醒的延迟。</li></ul></li><li>stack tracer：监控内核栈使用深度（需 CONFIG_STACK_TRACER）。</li><li>snapshot：保存当前追踪缓冲区快照。</li><li>instances：支持多实例并行追踪，互不干扰。</li></ul><h3 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h3><p>通过写入 tracefs 文件控制行为，例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="keyword">function</span> &gt; /sys/kernel/tracing/current_tracer</span><br><span class="line"><span class="built_in">echo</span> do_fork &gt; /sys/kernel/tracing/set_ftrace_filter</span><br><span class="line"><span class="built_in">cat</span> /sys/kernel/tracing/trace</span><br></pre></td></tr></table></figure><p>ftrace 支持动态过滤（<code>set_ftrace_filter</code>）、排除（<code>set_ftrace_notrace</code>）和格式化输出。</p><h3 id="高级特性"><a href="#高级特性" class="headerlink" title="高级特性"></a>高级特性</h3><ul><li>dynamic ftrace：仅在启用追踪时插入跳转指令，运行时开销极低。</li><li>Fprobe：在函数入口&#x2F;出口插入轻量探针（类似 kretprobe，但更高效）。</li><li>boot-time tracing：通过内核启动参数（如 <code>ftrace=function</code>）在早期阶段启用追踪。</li></ul><hr><h2 id="动态探针-——-Kprobes、Uprobes、Eprrobes"><a href="#动态探针-——-Kprobes、Uprobes、Eprrobes" class="headerlink" title="动态探针 —— Kprobes、Uprobes、Eprrobes"></a>动态探针 —— Kprobes、Uprobes、Eprrobes</h2><h3 id="Kprobes（内核探针）"><a href="#Kprobes（内核探针）" class="headerlink" title="Kprobes（内核探针）"></a>Kprobes（内核探针）</h3><p>Kprobes 允许在任意内核指令地址动态插入探针，无需修改内核代码或重启系统。支持两种类型：</p><ul><li>kprobe：在指定地址插入探针（函数入口或中间指令）。</li><li>kretprobe：在函数返回时触发。<br>Kprobes 可用于性能分析、故障注入、安全监控等。其开销高于 tracepoints，但灵活性极高。</li></ul><h3 id="Uprobes（用户态探针）"><a href="#Uprobes（用户态探针）" class="headerlink" title="Uprobes（用户态探针）"></a>Uprobes（用户态探针）</h3><p>Uprobes 是 Kprobes 的用户空间对应物，可对用户态程序的任意函数或地址进行追踪。常用于应用性能分析、系统调用拦截等。</p><h3 id="基于探针的事件追踪"><a href="#基于探针的事件追踪" class="headerlink" title="基于探针的事件追踪"></a>基于探针的事件追踪</h3><p>Kprobe 和 Uprobe 可注册为“事件”（events），通过 tracefs 暴露为可读写的事件节点，支持过滤、触发器和直方图统计。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;p:myprobe do_sys_open&#x27;</span> &gt; /sys/kernel/tracing/kprobe_events</span><br><span class="line"><span class="built_in">echo</span> 1 &gt; /sys/kernel/tracing/events/kprobes/myprobe/enable</span><br></pre></td></tr></table></figure><h3 id="Eprobes（事件探针）"><a href="#Eprobes（事件探针）" class="headerlink" title="Eprobes（事件探针）"></a>Eprobes（事件探针）</h3><p>在 Linux 中，<code>EPROBE</code> 并不是一个独立的探针类型，而是与 tracefs 动态事件（dynamic events） 相关的一个概念。具体来说，EPROBE 是 Linux 内核中用于 事件探针（event probe） 的一种动态追踪机制，它允许用户基于已有的 trace event 创建新的、可定制的探针。</p><ul><li><p>什么是 EPROBE</p><ul><li><code>EPROBE</code> 是一种 基于现有 <code>trace event</code> 的动态探针，它利用 <code>tracefs</code> 文件系统（通常挂载在 <code>/sys/kernel/tracing/</code>）来定义和管理。</li><li>它不同于传统的 <code>kprobe</code>（内核函数&#x2F;指令级探针）或 <code>uprobe</code>（用户空间探针），而是 对已有 tracepoint 事件进行“再包装”或“再采样”，可以附加过滤器、修改字段、重命名等。</li><li>在内核 API 中，可以通过 <code>tracefs_eprobe_alloc()</code> 来分配一个 <code>EPROBE</code> 探针结构，该结构描述了事件探针的配置。</li></ul></li><li><p>与 Kprobe 的区别</p><ul><li>Kprobe：直接插入到内核任意函数或指令地址，用于动态插桩，适用于没有 tracepoint 的代码路径。</li><li>EPROBE：必须基于已存在的 trace event（如 sched&#x2F;sched_switch、irq&#x2F;irq_handler_entry 等），不能直接挂钩到任意地址，但使用更安全、开销更低。</li></ul></li><li><p>使用方式（简要）<br>EPROBE 通常通过写入 <code>tracefs</code> 中的 <code>dyn_events</code> 文件来创建，例如：</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;e:my_sched_switch sched/sched_switch prev_comm=$prev_comm next_comm=$next_comm&#x27;</span> &gt; /sys/kernel/tracing/dyn_events</span><br></pre></td></tr></table></figure><p>这会创建一个名为 <code>my_sched_switch</code> 的 EPROBE，它基于 <code>sched/sched_switch</code> 事件，并只提取部分字段。</p><p>启用后，可以在 <code>events/eprobes/</code> 目录下看到该事件，并通过 <code>trace</code> 或 <code>trace_pipe</code> 读取。</p><hr><h2 id="专用延迟分析器"><a href="#专用延迟分析器" class="headerlink" title="专用延迟分析器"></a>专用延迟分析器</h2><h3 id="OSNOISE-Tracer"><a href="#OSNOISE-Tracer" class="headerlink" title="OSNOISE Tracer"></a>OSNOISE Tracer</h3><p>用于测量操作系统噪声（OS Noise），即干扰实时任务执行的内核活动（如 IRQ、SoftIRQ、线程调度）。它统计每种干扰源的持续时间和次数。</p><h3 id="Timerlat-Tracer"><a href="#Timerlat-Tracer" class="headerlink" title="Timerlat Tracer"></a>Timerlat Tracer</h3><p>专为实时调度延迟设计。它在每个 CPU 上创建高优先级内核线程，周期性设置定时器并测量：</p><ul><li>IRQ 延迟：从定时器到期到 IRQ 处理开始</li><li>Thread 延迟：从 IRQ 到实时线程被唤醒并运行</li></ul><p>帮助开发者定位导致 wakeup 延迟的根源。常与用户工具 rtla timerlat 配合使用。</p><hr><h2 id="用户事件"><a href="#用户事件" class="headerlink" title="用户事件"></a>用户事件</h2><p>一种 用户态主动注册事件 的机制，允许用户程序显式地向内核注册自定义追踪事件。程序需主动调用特定接口（如写入 tracefs 或使用 ring buffer）来“触发”事件。类似于用户态的 racepoint，但由用户程序定义格式和内容。允许用户态程序向内核追踪系统注册自定义事件，实现用户-内核联合追踪。</p><hr><h2 id="硬件辅助追踪"><a href="#硬件辅助追踪" class="headerlink" title="硬件辅助追踪"></a>硬件辅助追踪</h2><ul><li>ARM CoreSight</li><li>X86 Trace Hub</li><li>RISC-V N&#x2F;E-Trace</li></ul><p>硬件辅助追踪（HW-assisted tracing）是一种用于追踪内核和用户态程序的硬件技术，它利用了硬件的硬件支持，如 CoreSight、Trace Hub 或 RISC-V N&#x2F;E-Trace 等，来提高追踪效率。这些硬件支持通常与 CPU、内存、存储设备、外设等硬件组件一起工作，抓取CPU的指令流，通用寄存器，MSR&#x2F;CSR, 内存数据等，通过应用软件解析生成可视化追踪数据，以提供更高效的追踪功能。</p><h2 id="eBPF"><a href="#eBPF" class="headerlink" title="eBPF"></a>eBPF</h2><h3 id="eBPF-是什么"><a href="#eBPF-是什么" class="headerlink" title="eBPF 是什么"></a>eBPF 是什么</h3><p>eBPF 是一种革命性技术，起源于 Linux 内核，能够在特权环境（如操作系统内核）中运行沙箱程序。它可以在不修改内核源代码或加载内核模块的情况下，安全高效地扩展内核功能。</p><p>eBPF 是一种安全、高效、可编程的内核虚拟机技术, 是类似 Linux Tracing 的高层次可编程框架，允许用户在不修改内核源码、不加载内核模块的前提下，在内核中运行沙箱化的程序（称为 eBPF 程序），用于：</p><ul><li>网络（XDP、tc）</li><li>安全（LSM hooks）</li><li>追踪与性能分析（Tracing &amp; Profiling）</li><li>调度、存储等</li></ul><p>应用程序开发者可以在运行时通过 eBPF 程序向操作系统添加额外功能。操作系统通过借助即时编译器（JIT）和验证引擎，保证了安全性和执行效率，如同原生编译一般。这引发了一系列基于 eBPF 的项目，覆盖了广泛的应用场景，包括下一代网络、可观测性和安全功能。</p><p>如今，eBPF 被广泛用于推动各种应用场景：在现代数据中心和云原生环境中提供高性能网络和负载均衡，以低开销提取细粒度的安全可观测性数据，帮助应用程序开发者追踪应用，为性能故障排查提供洞见，实施预防性的应用程序和容器运行时安全策略，等等。可能性无限，而 eBPF 正在解锁的创新才刚刚开始。</p><p><a href="https://ebpf.io/">ebpf.io</a></p><h3 id="eBPF-与内核追踪技术的关系"><a href="#eBPF-与内核追踪技术的关系" class="headerlink" title="eBPF 与内核追踪技术的关系"></a>eBPF 与内核追踪技术的关系</h3><p>eBPF 本身不是追踪器，而是一个可编程的执行引擎，它可以挂载到各种追踪“钩子”（hooks）上，这些钩子包括：</p><table><thead><tr><th>钩子类型</th><th>对应内核机制</th><th>eBPF 支持</th></tr></thead><tbody><tr><td>函数入口&#x2F;出口</td><td>ftrace &#x2F; kprobes</td><td>✅ kprobe &#x2F; kretprobe 程序类型</td></tr><tr><td>用户态函数</td><td>uprobes</td><td>✅ uprobe &#x2F; uretprobe</td></tr><tr><td>静态插桩点</td><td>tracepoints</td><td>✅ tracepoint 程序类型</td></tr><tr><td>性能计数器</td><td>perf_events</td><td>✅ perf_event 程序类型</td></tr><tr><td>调度事件</td><td>sched tracepoints</td><td>✅（如 sched:sched_switch）</td></tr><tr><td>自定义事件</td><td>user_events（Linux</td><td>5.17+）✅ 可通过 tracepoint 接口挂载</td></tr></tbody></table><p>eBPF 重度依赖并扩展了 ftrace、kprobes、uprobes、tracepoints 等机制。</p><h3 id="eBPF-在追踪中的优势"><a href="#eBPF-在追踪中的优势" class="headerlink" title="eBPF 在追踪中的优势"></a>eBPF 在追踪中的优势</h3><table><thead><tr><th>特性</th><th>ftrace &#x2F; tracefs events</th><th>eBPF</th></tr></thead><tbody><tr><td>数据过滤</td><td>基础字符串&#x2F;数值过滤</td><td>✅ 任意逻辑（if&#x2F;else、循环受限）</td></tr><tr><td>数据聚合</td><td>需借助 hist 触发器</td><td>✅ 内置 maps（hash、array、lru 等）</td></tr><tr><td>上下文访问</td><td>有限（依赖事件定义）</td><td>✅ 可读取寄存器、栈、内存（安全校验后）</td></tr><tr><td>输出格式</td><td>固定文本</td><td>✅ 自定义结构化数据（通过 perf&#x2F;ringbuf）</td></tr><tr><td>用户态交互</td><td>读 trace_pipe</td><td>✅ 高效共享内存（ring buffer, perf buffer）</td></tr><tr><td>多事件关联</td><td>困难</td><td>✅ 通过 maps 跨事件状态跟踪（如 PID → 请求ID）</td></tr></tbody></table><h3 id="典型-eBPF-追踪工具"><a href="#典型-eBPF-追踪工具" class="headerlink" title="典型 eBPF 追踪工具"></a>典型 eBPF 追踪工具</h3><ul><li><p>BCC (BPF Compiler Collection)<br>提供 Python&#x2F;C++ 前端，封装 kprobe&#x2F;uprobe&#x2F;tracepoint 使用，如 opensnoop, execsnoop, profile。</p></li><li><p>bpftrace<br>类似 awk 的脚本语言，直接写单行追踪命令：</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bpftrace -e <span class="string">&#x27;tracepoint:syscalls:sys_enter_openat &#123; printf(&quot;%s %s\n&quot;, comm, str(args-&gt;filename)); &#125;&#x27;</span></span><br></pre></td></tr></table></figure><ul><li>libbpf + CO-RE<br>用于生产级 eBPF 应用开发（如 Pixie, Parca, Pixie, Datadog）。</li></ul><p>现代 Linux 追踪 &#x3D; 内核追踪基础设施（ftrace 等） + eBPF 可编程能力。</p><h2 id="tracefs"><a href="#tracefs" class="headerlink" title="tracefs"></a>tracefs</h2><p>tracefs 是 Linux 内核提供的一个文件系统，用于提供内核追踪功能。它提供了一系列文件，用于配置和查看内核的追踪信息。<code>/sys/kernel/tracing</code> 的主要文件及目录如下，</p><table><thead><tr><th align="left">概念</th><th align="right">文件及路径名</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><strong>$\color{#FFA500}{核心追踪后端与控制}$</strong></td><td align="right"></td><td align="left"></td></tr><tr><td align="left">说明</td><td align="right">README</td><td align="left">简要说明 tracefs 的用途和基本操作</td></tr><tr><td align="left">当前激活的追踪器</td><td align="right">current_tracer</td><td align="left">设置&#x2F;读取当前使用的追踪器（如 function,function_graph,nop等）</td></tr><tr><td align="left">可用的追踪器列表</td><td align="right">available_tracers</td><td align="left">用于配置到current_tracer</td></tr><tr><td align="left">追踪开关</td><td align="right">tracing_on</td><td align="left">全局开关。1 开启追踪，0 暂停（但不丢弃已注册的探针）</td></tr><tr><td align="left">追踪缓冲区</td><td align="right">buffer_size_kb</td><td align="left">设置每个 CPU 的环形缓冲区大小</td></tr><tr><td align="left">总追踪缓冲区</td><td align="right">buffer_total_size_kb</td><td align="left">只读，所有 CPU 的总环形缓冲区大小</td></tr><tr><td align="left">追踪数据输出</td><td align="right">trace，trace_pipe</td><td align="left">trace 是静态快照，trace_pipe 是流式、消费后即消失的输出</td></tr><tr><td align="left">追踪标记</td><td align="right">trace_marker，trace_marker_raw</td><td align="left">用户空间程序可向其中写入自定义消息，用于标记时间点</td></tr><tr><td align="left">追踪缓冲区释放</td><td align="right">free_buffer</td><td align="left">写入此文件可释放追踪缓冲区内存（通常在关闭追踪后使用）</td></tr><tr><td align="left">追踪快照</td><td align="right">snapshot</td><td align="left">管理快照缓冲区。写入1可交换主缓冲区与快照缓冲区，用于在关键时刻保存现场</td></tr><tr><td align="left">追踪 CPU 位图</td><td align="right">tracing_cpumask</td><td align="left">设置参与追踪的 CPU 位图。可用于只追踪特定 CPU 上的事件</td></tr><tr><td align="left">追踪最大延迟</td><td align="right">tracing_max_latency，tracing_thresh</td><td align="left">用于延迟追踪器（如irqsoff）。当检测到延迟超过阈值时，会保存当时的调用栈</td></tr><tr><td align="left">追踪栈深度</td><td align="right">stack_trace，stack_max_size</td><td align="left">显示&#x2F;重置最大内核栈深度。配合stack_trace追踪器使用</td></tr><tr><td align="left">追踪栈深度过滤</td><td align="right">stack_trace_filter</td><td align="left">设置只对特定函数调用栈进行深度记录</td></tr><tr><td align="left"><strong>$\color{#08F800}{静态追踪：Tracepoints 与 Events}$</strong></td><td align="right"></td><td align="left"></td></tr><tr><td align="left">可用事件列表</td><td align="right">available_events</td><td align="left">列出所有已注册的静态 tracepoint 事件</td></tr><tr><td align="left">事件开关</td><td align="right">events&#x2F;</td><td align="left">每个子系统（如 sched&#x2F;,kmem&#x2F;）下都有 enable 文件，用于开关该事件</td></tr><tr><td align="left">全局事件开关</td><td align="right">set_event,set_event_pid,set_event_notrace_pid</td><td align="left">全局事件开关：通过写入事件名（如 sched:sched_switch）或 PID 来启用&#x2F;禁止特定事件</td></tr><tr><td align="left">合成事件</td><td align="right">synthetic_events</td><td align="left">合成事件：用户可定义基于现有事件的复杂事件（如延迟计算）</td></tr><tr><td align="left"><strong>$\color{#00FFFF}{动态追踪：Kprobes, Uprobes, Fprobe}$</strong></td><td align="right"></td><td align="left"></td></tr><tr><td align="left">Kprobe 动态事件</td><td align="right">kprobe_events</td><td align="left">核心接口。通过写入特定语法（如 p:myprobe o_sys_open）来动态创建内核探针</td></tr><tr><td align="left">Uprobe 动态事件</td><td align="right">uprobe_events</td><td align="left">核心接口。用于动态探测用户空间程序（如p:malloc_entry &#x2F;lib&#x2F;libc.so:malloc）</td></tr><tr><td align="left">通用动态事件</td><td align="right">dynamic_events</td><td align="left">统一入口。Kprobe、Uprobe、Fprobe、Eprobe 事件均可在此定义</td></tr><tr><td align="left">性能剖析</td><td align="right">kprobe_profile, uprobe_profile</td><td align="left">显示每个动态探针的命中次数</td></tr><tr><td align="left"><strong>$\color{#000FF0}{函数追踪：Ftrace 核心}$</strong></td><td align="right"></td><td align="left"></td></tr><tr><td align="left">可用函数列表</td><td align="right">available_filter_functions</td><td align="left">列出所有可被 ftrace 追踪的函数</td></tr><tr><td align="left">可用函数列表</td><td align="right">available_filter_functions_addrs</td><td align="left">列出所有可被 ftrace 追踪的函数及其地址</td></tr><tr><td align="left">函数过滤器</td><td align="right">set_ftrace_filter</td><td align="left">写入函数名，仅追踪这些函数</td></tr><tr><td align="left">函数黑名单</td><td align="right">set_ftrace_notrace</td><td align="left">写入函数名，排除这些函数</td></tr><tr><td align="left">进程过滤</td><td align="right">set_ftrace_pid，set_ftrace_notrace_pid</td><td align="left">按进程 PID 过滤，只追踪或排除特定进程的函数调用</td></tr><tr><td align="left">函数调用图过滤</td><td align="right">set_graph_function,set_graph_notrace</td><td align="left">为 function_graph 追踪器设置函数调用图的过滤器</td></tr><tr><td align="left">调用图深度</td><td align="right">max_graph_depth</td><td align="left">与 function_graph 追踪器配合，限制调用图深度</td></tr><tr><td align="left">函数性能剖析</td><td align="right">function_profile_enabled</td><td align="left">启用函数性能剖析。启用后，trace_stats&#x2F;function会统计每个函数的调用次数和耗时</td></tr><tr><td align="left">追踪过的函数</td><td align="right">touched_functions</td><td align="left">只读，列出自追踪启动以来被调用过的所有函数（需先启用function追踪器）</td></tr><tr><td align="left">动态 ftrace 总信息</td><td align="right">dyn_ftrace_total_info</td><td align="left">只读，显示动态 ftrace 的内部统计信息，如已打补丁的函数数量</td></tr><tr><td align="left"><strong>$\color{#FF00FF}{高级追踪器与专用工具}$</strong></td><td align="right"></td><td align="left"></td></tr><tr><td align="left">硬件延迟检测</td><td align="right">hwlat_detector&#x2F;</td><td align="left">专用追踪器，用于检测硬件引起的巨大延迟</td></tr><tr><td align="left">操作系统噪声</td><td align="right">osnoise&#x2F;</td><td align="left">追踪系统中非任务相关的延迟源（如中断、软中断）</td></tr><tr><td align="left">运行时验证</td><td align="right">rv&#x2F;</td><td align="left">用于形式化验证的追踪接口</td></tr><tr><td align="left">实例化追踪</td><td align="right">instances&#x2F;</td><td align="left">创建独立的追踪实例，用于隔离不同用途的追踪会话</td></tr><tr><td align="left"><strong>$\color{#FF8800}{用户空间追踪}$</strong></td><td align="right"></td><td align="left"></td></tr><tr><td align="left">用户事件数据</td><td align="right">user_events_data</td><td align="left">写入端。用户空间程序向此文件写入自定义事件数据</td></tr><tr><td align="left">用户事件状态</td><td align="right">user_events_status</td><td align="left">读取端。显示已注册的用户事件及其格式</td></tr><tr><td align="left"><strong>$\color{#FF0000}{底层支持与元数据}$</strong></td><td align="right"></td><td align="left"></td></tr><tr><td align="left">cpu独立追踪数据</td><td align="right">per_cpu&#x2F;</td><td align="left">每个 CPU 的独立追踪数据。包含trace_pipe_raw文件，用于高性能、零拷贝的内存映射读取（见ring-buffer-map.html）</td></tr><tr><td align="left">追踪选项开关</td><td align="right">options&#x2F;</td><td align="left">如print-parent（打印调用者）、latency-format（延迟格式）等。可通过trace_options文件批量设置</td></tr><tr><td align="left">追踪数据输出格式</td><td align="right">printk_formats</td><td align="left">只读，列出内核中printk使用的格式字符串，供某些追踪后端解析使用</td></tr><tr><td align="left">保存的进程名和线程组 ID</td><td align="right">saved_cmdlines,saved_tgids</td><td align="left">保存进程名和线程组 ID。追踪系统会缓存最近活跃的 PID 及其命令名，以便在trace输出中显示可读的进程名而非 PID</td></tr><tr><td align="left">保存的进程名缓存大小</td><td align="right">saved_cmdlines_size</td><td align="left">设置 saved_cmdlines 缓存的大小</td></tr><tr><td align="left">时间戳模式</td><td align="right">timestamp_mode</td><td align="left">设置时间戳的来源和格式，如local,global,counter等</td></tr><tr><td align="left">错误日志</td><td align="right">error_log</td><td align="left">追踪系统内部错误日志。当动态事件定义语法错误时，错误信息会记录在此</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> trace </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> trace </tag>
            
            <tag> tracefs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RISC-V MTE 内存标签</title>
      <link href="/2025/09/30/RISC-V-MTE-Spec-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2025/09/30/RISC-V-MTE-Spec-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="📋-文档基本信息"><a href="#📋-文档基本信息" class="headerlink" title="📋 文档基本信息"></a>📋 文档基本信息</h2><p>基于 <code>riscv-mte.html</code> 文档的详细知识点梳理</p><ul><li><strong>文档标题</strong>: RISC-V Memory Tagging Extension</li><li><strong>版本</strong>: v0.0.0 (Draft)</li><li><strong>日期</strong>: 2025-09-28</li><li><strong>状态</strong>: 开发阶段草案</li></ul><hr><h2 id="📖-第1章-介绍"><a href="#📖-第1章-介绍" class="headerlink" title="📖 第1章 - 介绍"></a>📖 第1章 - 介绍</h2><h3 id="🔍-背景与问题陈述"><a href="#🔍-背景与问题陈述" class="headerlink" title="🔍 背景与问题陈述"></a>🔍 背景与问题陈述</h3><h4 id="内存安全问题根源"><a href="#内存安全问题根源" class="headerlink" title="内存安全问题根源"></a><strong>内存安全问题根源</strong></h4><ul><li>生产级软件大多使用C&#x2F;C++等内存管理原语强大的语言</li><li>协作开发和紧锣密鼓的工期导致引入内存安全bug</li><li>内存安全问题的核心是违反语言规范的无效内存访问</li></ul><h4 id="对象生命周期管理"><a href="#对象生命周期管理" class="headerlink" title="对象生命周期管理"></a><strong>对象生命周期管理</strong></h4><table><thead><tr><th>内存类型</th><th>生命周期管理</th><th>示例</th><th>生命周期边界</th></tr></thead><tbody><tr><td><strong>堆内存</strong></td><td>内存分配器管理</td><td>malloc&#x2F;free</td><td>malloc ~ free调用之间</td></tr><tr><td><strong>栈内存</strong></td><td>编译器作用域规则</td><td>局部变量</td><td>程序语言作用域规则</td></tr><tr><td><strong>全局变量</strong></td><td>操作系统管理</td><td>全局变量</td><td>进程启动 ~ 进程关闭</td></tr></tbody></table><h4 id="主要内存安全漏洞类型"><a href="#主要内存安全漏洞类型" class="headerlink" title="主要内存安全漏洞类型"></a><strong>主要内存安全漏洞类型</strong></h4><ul><li><p><strong>时间安全性问题(Temporal)</strong></p><ul><li>Use-after-free (UAF) - 堆内存</li><li>Stack use after return&#x2F;scope - 栈内存</li></ul></li><li><p><strong>空间安全性问题(Spatial)</strong></p><ul><li>缓冲区溢出&#x2F;下溢</li><li>越界访问</li></ul></li></ul><h3 id="🛡️-内存标签保护机制"><a href="#🛡️-内存标签保护机制" class="headerlink" title="🛡️ 内存标签保护机制"></a>🛡️ 内存标签保护机制</h3><h4 id="锁钥模型-Lock-and-Key"><a href="#锁钥模型-Lock-and-Key" class="headerlink" title="锁钥模型(Lock-and-Key)"></a><strong>锁钥模型(Lock-and-Key)</strong></h4><ul><li><strong>内存标签(锁)</strong>: 为内存块分配唯一标识</li><li><strong>指针标签(钥)</strong>: 指针高位存储对应的标签标识</li><li><strong>访问验证</strong>: 访问时验证锁钥匹配，不匹配则终止程序</li></ul><h4 id="生命周期管理流程"><a href="#生命周期管理流程" class="headerlink" title="生命周期管理流程"></a><strong>生命周期管理流程</strong></h4><ol><li><strong>对象创建</strong>: malloc时分配相同标签给内存和指针</li><li><strong>访问验证</strong>: 使用指针时验证标签匹配</li><li><strong>对象销毁</strong>: free时更改内存标签，使旧指针失效</li></ol><h4 id="现有软件方案对比"><a href="#现有软件方案对比" class="headerlink" title="现有软件方案对比"></a><strong>现有软件方案对比</strong></h4><table><thead><tr><th>方案</th><th>实现方式</th><th>适用场景</th><th>性能影响</th></tr></thead><tbody><tr><td><strong>HWAddressSanitizer</strong></td><td>指针掩码技术</td><td>单元测试&#x2F;开发者测试</td><td>中等到显著</td></tr><tr><td><strong>AddressSanitizer</strong></td><td>纯软件实现</td><td>模糊测试&#x2F;特殊测试框架</td><td>显著开销</td></tr></tbody></table><hr><h2 id="🏗️-第2章-内存标签扩展-Zimt"><a href="#🏗️-第2章-内存标签扩展-Zimt" class="headerlink" title="🏗️ 第2章 - 内存标签扩展 (Zimt)"></a>🏗️ 第2章 - 内存标签扩展 (Zimt)</h2><h3 id="🔬-基础架构设计"><a href="#🔬-基础架构设计" class="headerlink" title="🔬 基础架构设计"></a>🔬 基础架构设计</h3><h4 id="核心设计原则"><a href="#核心设计原则" class="headerlink" title="核心设计原则"></a><strong>核心设计原则</strong></h4><ul><li><strong>内存块划分</strong>: 16字节为单位的连续内存块(MC)</li><li><strong>XLEN要求</strong>: 仅支持64位架构，依赖指针掩码扩展</li><li><strong>编码兼容性</strong>: 使用zimop编码保证二进制兼容性</li></ul><h4 id="标签配置规范"><a href="#标签配置规范" class="headerlink" title="标签配置规范"></a><strong>标签配置规范</strong></h4><table><thead><tr><th>指针标签宽度</th><th>内存标签宽度</th><th>可用标签空间</th><th>存储效率</th></tr></thead><tbody><tr><td>4位</td><td>4位</td><td>16个唯一值</td><td>高(每字节存2个标签)</td></tr><tr><td>7位</td><td>8位</td><td>128个唯一值</td><td>标准(每字节存1个标签)</td></tr></tbody></table><p>内存标签宽度为8位，可提供256中标签值，安全性比4位（16种标签值）高，但实际使用时因为指针标签只有7位，所以只有128种标签值。为啥是7位，因为Sv57只有7位是可以提供给内存标签。因此标签的最大宽度实际只有7位。</p><h3 id="💻-内存操作"><a href="#💻-内存操作" class="headerlink" title="💻 内存操作"></a>💻 内存操作</h3><h4 id="加载-存储操作分类"><a href="#加载-存储操作分类" class="headerlink" title="加载&#x2F;存储操作分类"></a><strong>加载&#x2F;存储操作分类</strong></h4><ol><li><p><strong>常规加载&#x2F;存储操作</strong></p><ul><li>对具有 –R、X-R、-WR、XWR权限的页面操作</li><li>用于标准内存访问指令（除settag和checktag）</li></ul></li><li><p><strong>检查型（checked）加载&#x2F;存储</strong></p><ul><li>启用了标签检查的常规操作</li><li>在访问时执行标签验证</li></ul></li><li><p><strong>非检查型（unchecked）加载&#x2F;存储</strong></p><ul><li>禁用标签检查的常规操作</li><li>用于可信代码路径优化（有些函数或执行环境是值得信赖的，没必要进行标签检查。）</li></ul></li><li><p><strong>标签加载&#x2F;存储操作</strong></p><ul><li>专门用于标签存储区的操作（gentag, addtag, settag, checktag）</li><li>需要特定的页面权限(标签存储区)</li></ul></li></ol><h3 id="🎯-标签管理指令集"><a href="#🎯-标签管理指令集" class="headerlink" title="🎯 标签管理指令集"></a>🎯 标签管理指令集</h3><h4 id="标签生成指令-gentag-rd"><a href="#标签生成指令-gentag-rd" class="headerlink" title="标签生成指令 - gentag rd"></a><strong>标签生成指令 - <code>gentag rd</code></strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gentag t0  # 在t0高位生成随机标签</span><br></pre></td></tr></table></figure><ul><li><strong>功能</strong>: 生成<strong>伪随机</strong>指针标签</li><li><strong>条件</strong>: 内存标签启用时生成随机值（会出现什么值是随机的），内存标签禁用则回退zimop行为（t0会被清空）</li><li><strong>安全性</strong>: 确保标签在调用间均匀分布（每个值出现的概率是一样的）</li></ul><h4 id="标签算术指令-addtag-rd-rs1-tag-imm4"><a href="#标签算术指令-addtag-rd-rs1-tag-imm4" class="headerlink" title="标签算术指令 - addtag rd, rs1, #tag_imm4"></a><strong>标签算术指令 - <code>addtag rd, rs1, #tag_imm4</code></strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">addtag t1, t0, 1  # 在t0标签（高位）基础上加1（左移到高位）存到t1的高位，内存标签禁用则回退zimop行为（t0会被清空）</span><br></pre></td></tr></table></figure><ul><li><strong>应用</strong>: 编译器派生相关对象的标签</li><li><strong>优势</strong>: 静态确定性地计算栈对象标签（gentag已经获得了随机标签，这里只需算术计算标签）</li><li><strong>用途</strong>: 编译器为堆栈上的连续对象分配不同的标记（具有相同的基标记），从而帮助捕获相邻溢出错误。这也有助于语言运行时在异常展开等事件中，以确定性方式计算堆栈上对象的标记。</li></ul><h4 id="内存标签设置指令-settag-rs1-chunk-count"><a href="#内存标签设置指令-settag-rs1-chunk-count" class="headerlink" title="内存标签设置指令 - settag rs1, #chunk_count"></a><strong>内存标签设置指令 - <code>settag rs1, #chunk_count</code></strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gentag t0, zero      # 生成基础标签(base tag)</span><br><span class="line">or s1, s1, t0        # 组合地址和标签(s1是va)</span><br><span class="line">settag s1, 1         # 为s1指向的内存块(前2个内存块)设置标签</span><br></pre></td></tr></table></figure><ul><li><strong>范围</strong>: 支持1-16个连续内存块（编码中用4个bit来表示chunk_count, 因此，0表示1个内存块，1表示2个内存块，15表示16个内存块）</li><li><strong>地址计算</strong>: <code>rs1 &amp; (~0xF)</code> 获取起始地址（有效地址：不包含高位）</li><li><strong>对齐要求</strong>: 无原子性保证，可能分割为多次存储</li></ul><h3 id="⚡-标签检查机制"><a href="#⚡-标签检查机制" class="headerlink" title="⚡ 标签检查机制"></a>⚡ 标签检查机制</h3><h4 id="检查触发条件"><a href="#检查触发条件" class="headerlink" title="检查触发条件"></a><strong>检查触发条件</strong></h4><ul><li><strong>M模式</strong>: 所有常规加载&#x2F;存储都检查</li><li><strong>非M模式</strong>: <ul><li><code>satp.MODE == Bare</code>: 全部检查</li><li><code>satp.MODE != Bare</code>: 仅标记页面（叶子PTE）检查</li></ul></li></ul><h4 id="检查豁免规则"><a href="#检查豁免规则" class="headerlink" title="检查豁免规则"></a><strong>检查豁免规则</strong></h4><ul><li><strong>栈指针访问</strong>: sp&#x2F;x2相对访问不检查</li><li><strong>标签不匹配</strong>: 触发软件检查异常(tval&#x3D;4)</li><li><strong>标签查找</strong>: mc_tag是从内存中获取的，其本身也要进行PMP等权限检查，可能会产生页面错误&#x2F;访问错误</li></ul><h4 id="显式检查指令-checktag-rs1-chunk-count"><a href="#显式检查指令-checktag-rs1-chunk-count" class="headerlink" title="显式检查指令 - checktag rs1, #chunk_count"></a><strong>显式检查指令 - <code>checktag rs1, #chunk_count</code></strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">checktag s1, 1  # 显式检查s1指向的连续的2个内存块标签</span><br></pre></td></tr></table></figure><ul><li><strong>强制检查</strong>: 不受页面标记（MTAG）影响</li><li><strong>用途</strong>: 调试和验证场景</li></ul><h3 id="🔧-控制系统寄存器配置"><a href="#🔧-控制系统寄存器配置" class="headerlink" title="🔧 控制系统寄存器配置"></a>🔧 控制系统寄存器配置</h3><h4 id="MT-MODE编码规范"><a href="#MT-MODE编码规范" class="headerlink" title="MT_MODE编码规范"></a><strong>MT_MODE编码规范</strong></h4><table><thead><tr><th>模式值</th><th>状态</th><th>指针标签宽度</th></tr></thead><tbody><tr><td>00</td><td>禁用</td><td>-</td></tr><tr><td>01</td><td>保留</td><td>-</td></tr><tr><td>10</td><td>启用</td><td>4位</td></tr><tr><td>11</td><td>启用</td><td>7位</td></tr></tbody></table><h4 id="特权级别控制寄存器"><a href="#特权级别控制寄存器" class="headerlink" title="特权级别控制寄存器"></a><strong>特权级别控制寄存器</strong></h4><table><thead><tr><th>特权级别</th><th>控制寄存器</th><th>影响模式</th></tr></thead><tbody><tr><td>M模式</td><td><code>mseccfg.MT_MODE</code></td><td>M模式启用</td></tr><tr><td>HS&#x2F;S模式</td><td><code>menvcfg.MT_MODE</code></td><td>HS&#x2F;S模式启用</td></tr><tr><td>VU&#x2F;U模式</td><td><code>senvcfg.MT_MODE</code></td><td>VU&#x2F;U模式启用</td></tr><tr><td>VS模式</td><td><code>henvcfg.MT_MODE</code></td><td>VS模式启用</td></tr></tbody></table><h4 id="异步报告控制"><a href="#异步报告控制" class="headerlink" title="异步报告控制"></a><strong>异步报告控制</strong></h4><ul><li><strong>MT_ASYNC位</strong>: <strong>存储</strong>操作，标签不匹配可以异步报告</li><li><strong>保证同步</strong>: <strong>加载</strong>操作始终保持同步错误报告</li></ul><h3 id="📄-页面级别标签检查控制"><a href="#📄-页面级别标签检查控制" class="headerlink" title="📄 页面级别标签检查控制"></a>📄 页面级别标签检查控制</h3><h4 id="页表条目MTAG位"><a href="#页表条目MTAG位" class="headerlink" title="页表条目MTAG位"></a><strong>页表条目MTAG位</strong></h4><ul><li><strong>启用检查</strong>: 数据页面MTAG&#x3D;1时强制标签检查</li><li><strong>代码豁免</strong>: 代码页面MTAG&#x3D;1时豁免检查</li><li><strong>权限限制</strong>: 某些页面配置（XWR&#x3D;111,010）下MTAG位保留,若被设置，引发页面异常。内存标签未启用，则MTAG位为保留位。</li></ul><h4 id="跨页面指令行为"><a href="#跨页面指令行为" class="headerlink" title="跨页面指令行为"></a><strong>跨页面指令行为</strong></h4><ul><li>指令跨不同MTAG值页面边界时，视为MTAG&#x3D;0</li><li>确保指令执行的确定性</li></ul><hr><h2 id="🌐-第3章-虚拟索引标签存储-Svatag-Smvatag"><a href="#🌐-第3章-虚拟索引标签存储-Svatag-Smvatag" class="headerlink" title="🌐 第3章 - 虚拟索引标签存储 (Svatag&#x2F;Smvatag)"></a>🌐 第3章 - 虚拟索引标签存储 (Svatag&#x2F;Smvatag)</h2><h3 id="🗃️-虚拟标签表架构"><a href="#🗃️-虚拟标签表架构" class="headerlink" title="🗃️ 虚拟标签表架构"></a>🗃️ 虚拟标签表架构</h3><h4 id="地址计算模型"><a href="#地址计算模型" class="headerlink" title="地址计算模型"></a><strong>地址计算模型</strong></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mc_tag_va = VITT_BASE + (((va &gt;&gt; <span class="number">4</span>) * mc_tag_width) &gt;&gt; <span class="number">3</span>)</span><br></pre></td></tr></table></figure><p>根据标签宽度的具体计算：</p><ul><li><strong>4位标签</strong>: <code>VITT_BASE + (va &gt;&gt; 5)</code></li><li><strong>8位标签</strong>: <code>VITT_BASE + (va &gt;&gt; 4)</code></li></ul><h4 id="标签存储优化"><a href="#标签存储优化" class="headerlink" title="标签存储优化"></a><strong>标签存储优化</strong></h4><ul><li><strong>4位模式</strong>: 每字节打包存储2个标签</li><li><strong>8位模式</strong>: 标准一字节一标签存储</li><li><strong>访问粒度</strong>: 支持不对齐访问</li></ul><h4 id="内存块-MC-到标签的映射关系"><a href="#内存块-MC-到标签的映射关系" class="headerlink" title="内存块(MC)到标签的映射关系"></a><strong>内存块(MC)到标签的映射关系</strong></h4><table><thead><tr><th><strong>MC地址</strong></th><th><strong>4位模式</strong></th><th><strong>存储布局</strong></th></tr></thead><tbody><tr><td>0x0000</td><td>VITT_BASE[0][0:3]</td><td>[MC0标签 &#124; MC1标签]</td></tr><tr><td>0x0010</td><td>VITT_BASE[0][4:7]</td><td>[MC2标签 &#124; MC3标签]</td></tr><tr><td>0x0020</td><td>VITT_BASE[1][0:3]</td><td>…</td></tr><tr><td><strong>MC地址</strong></td><td><strong>8位模式</strong></td><td><strong>存储布局</strong></td></tr><tr><td>0x0000</td><td>VITT_BASE[0]</td><td>[MC0标签]</td></tr><tr><td>0x0010</td><td>VITT_BASE[1]</td><td>[MC1标签]</td></tr><tr><td>0x0020</td><td>VITT_BASE[2]</td><td>…</td></tr></tbody></table><p>假如内存为16GB，则，</p><ul><li>4位模式，mc_tag空间大小：16GB&#x2F;16 * 4&#x2F;8(B) &#x3D; 512M, 512M&#x2F;16GB &#x3D; 0.03125 &#x3D; 3.125%</li><li>8位模式，mc_tag空间大小：16GB&#x2F;16 * 1B &#x3D; 1GB, 1GB&#x2F;16GB &#x3D; 0.0625 &#x3D; 6.25%</li></ul><p>开启内存标签后，内存开销增加<strong>3.125%<strong>或</strong>6.25%</strong>。</p><h3 id="🔐-特权级基址寄存器"><a href="#🔐-特权级基址寄存器" class="headerlink" title="🔐 特权级基址寄存器"></a>🔐 特权级基址寄存器</h3><h4 id="标签表基址CSR分配"><a href="#标签表基址CSR分配" class="headerlink" title="标签表基址CSR分配"></a><strong>标签表基址CSR分配</strong></h4><table><thead><tr><th>特权级别</th><th>基址寄存器</th><th>扩展</th></tr></thead><tbody><tr><td>U模式</td><td><code>svittu</code></td><td>Svatag</td></tr><tr><td>S&#x2F;HS模式</td><td><code>svitts</code></td><td>Svatag</td></tr><tr><td>VS模式</td><td><code>vsvitts</code></td><td>Svatag</td></tr><tr><td>M模式</td><td><code>mvitt</code></td><td>Smvatag</td></tr><tr><td>基地址必须4KB对齐。</td><td></td><td></td></tr></tbody></table><h4 id="存储保护机制"><a href="#存储保护机制" class="headerlink" title="存储保护机制"></a><strong>存储保护机制</strong></h4><ul><li><strong>访问限制</strong>: 常规操作访问VITT范围会触发异常</li><li><strong>边界计算</strong>: 基于当前特权级别的最低&#x2F;最高虚拟地址</li><li><strong>地址空间划分</strong>: 用户空间正向，管理空间负向</li></ul><h4 id="保护范围计算"><a href="#保护范围计算" class="headerlink" title="保护范围计算"></a><strong>保护范围计算</strong></h4><p>根据文档3.3节，VITT保护范围由虚拟地址空间边界确定：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tag_memory_region_start = mc_tag_va(LOWEST_VADDR_CURR_PRIV)</span><br><span class="line">tag_memory_region_end = mc_tag_va(HIGHEST_VADDR_CURR_PRIV)</span><br></pre></td></tr></table></figure><h4 id="特权级地址空间划分"><a href="#特权级地址空间划分" class="headerlink" title="特权级地址空间划分"></a><strong>特权级地址空间划分</strong></h4><table><thead><tr><th>特权级别</th><th>LOWEST_VADDR</th><th>HIGHEST_VADDR</th><th>地址空间特点</th></tr></thead><tbody><tr><td><strong>U模式</strong></td><td>0</td><td>2^(VADDR_BITS-1)-1</td><td>正地址空间</td></tr><tr><td><strong>S&#x2F;HS&#x2F;VS模式</strong></td><td>2^(VADDR_BITS-1)</td><td>2^VADDR_BITS-1</td><td>负地址空间</td></tr><tr><td><strong>M模式</strong></td><td>实现定义</td><td>实现定义</td><td>定制地址范围</td></tr><tr><td>VADDR_BITS 代表虚拟寻址位数。根据 satp CSR 中的 Sv39、Sv48 或 Sv57 虚拟寻址模式，VADDR_BITS 可以是 39、48 或 57。在裸模式和 M 模式下，LOWEST_VADDR_CURR_PRIV 和 HIGHEST_VADDR_CURR_PRIV 由实现定义。实际的物理地址远小于虚拟地址范围，因此VITT范围要根据物理范围设定。另外，由于虚拟地址是任意可配置的，所以VITT基地址也是可配置的，从而保证所有虚拟地址都被保护。</td><td></td><td></td><td></td></tr></tbody></table><h4 id="保护机制实现细节"><a href="#保护机制实现细节" class="headerlink" title="保护机制实现细节"></a><strong>保护机制实现细节</strong></h4><h5 id="1-常规内存访问保护"><a href="#1-常规内存访问保护" class="headerlink" title="1. 常规内存访问保护"></a><strong>1. 常规内存访问保护</strong></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 以下操作触发访问异常</span><br><span class="line">lb t0, (vitt_address)      # 常规加载VITT区域</span><br><span class="line">sb t1, (vitt_address)      # 常规存储VITT区域</span><br></pre></td></tr></table></figure><ul><li><strong>强制保护</strong>：任何常规Load&#x2F;Store到VITT范围都触发异常</li><li><strong>硬件实现</strong>：通过地址比较器实时检测</li></ul><h5 id="2-标签操作保护"><a href="#2-标签操作保护" class="headerlink" title="2. 标签操作保护"></a><strong>2. 标签操作保护</strong></h5><p>当<code>settag</code>指令指定的内存块与VITT范围重叠时：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">settag s1, 1  # 如果s1指向VITT区域，触发异常</span><br></pre></td></tr></table></figure><ul><li><strong>预检机制</strong>：在执行标签设置前验证地址有效性</li><li><strong>范围重叠检测</strong>：确保不会意外修改标签元数据</li></ul><h5 id="3-特权级别保护"><a href="#3-特权级别保护" class="headerlink" title="3. 特权级别保护"></a><strong>3. 特权级别保护</strong></h5><p><strong>Svatag依赖关系</strong>：</p><ul><li>依赖<code>Svukte</code>扩展实现地址空间均分</li><li>用户空间：0 → 最大正地址</li><li>管理空间：最小负地址 → 最大负地址</li></ul><h4 id="内存页面对齐问题"><a href="#内存页面对齐问题" class="headerlink" title="内存页面对齐问题"></a><strong>内存页面对齐问题</strong></h4><p>由于VITT地址计算的非传统性，可能产生特殊的对齐问题：</p><h4 id="跨页面边界处理"><a href="#跨页面边界处理" class="headerlink" title="跨页面边界处理"></a><strong>跨页面边界处理</strong></h4><ul><li><strong>4位模式</strong>：由于打包存储，单个VITT条目可能跨页面边界</li><li><strong>错误处理</strong>：硬件必须正确处理页面错误和访问权限</li></ul><hr><h2 id="⚡-第4章-标签检查免除扩展"><a href="#⚡-第4章-标签检查免除扩展" class="headerlink" title="⚡ 第4章 - 标签检查免除扩展"></a>⚡ 第4章 - 标签检查免除扩展</h2><h3 id="🚀-瞬态检查禁用机制"><a href="#🚀-瞬态检查禁用机制" class="headerlink" title="🚀 瞬态检查禁用机制"></a>🚀 瞬态检查禁用机制</h3><h4 id="TTCD状态管理"><a href="#TTCD状态管理" class="headerlink" title="TTCD状态管理"></a><strong>TTCD状态管理</strong></h4><table><thead><tr><th>状态值</th><th>名称</th><th>描述</th></tr></thead><tbody><tr><td>0</td><td>TAG_CHECK_ENFORCED</td><td>启用标签检查</td></tr><tr><td>1</td><td>TAG_CHECK_ELIDE</td><td>免除标签检查</td></tr></tbody></table><h4 id="免除检查指令-nietc"><a href="#免除检查指令-nietc" class="headerlink" title="免除检查指令 - nietc"></a><strong>免除检查指令 - <code>nietc</code></strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nietc      # 下一条指令免除标签检查</span><br><span class="line">lb t0, 16(sp)  # 此加载操作不检查标签</span><br></pre></td></tr></table></figure><ul><li><strong>编码</strong>: 使用C.MOP.3编码，依赖C和Zcmop扩展</li><li><strong>状态恢复</strong>: 后续内存访问自动恢复检查</li><li><strong>陷阱处理</strong>: TTCD状态保存在*status寄存器中</li></ul><h3 id="💾-状态寄存器扩展"><a href="#💾-状态寄存器扩展" class="headerlink" title="💾 状态寄存器扩展"></a>💾 状态寄存器扩展</h3><h4 id="TTCD状态保存字段"><a href="#TTCD状态保存字段" class="headerlink" title="TTCD状态保存字段"></a><strong>TTCD状态保存字段</strong></h4><table><thead><tr><th>特权级别</th><th>状态寄存器</th><th>保存字段</th></tr></thead><tbody><tr><td>M模式</td><td><code>mstatus</code></td><td><code>MPTTCD</code>(位42)</td></tr><tr><td>S模式</td><td><code>sstatus</code></td><td><code>SPTTCD</code>(位24)</td></tr><tr><td>VS模式</td><td><code>vsstatus</code></td><td><code>SPTTCD</code>(位24)</td></tr></tbody></table><h4 id="状态恢复机制"><a href="#状态恢复机制" class="headerlink" title="状态恢复机制"></a><strong>状态恢复机制</strong></h4><ul><li><strong>陷阱进入</strong>: TTCD当前状态保存到对应PTTCD字段</li><li><strong>陷阱返回</strong>: 从PTTCD字段恢复TTCD状态并清除PTTCD</li></ul><hr><h2 id="🎯-应用示例与最佳实践"><a href="#🎯-应用示例与最佳实践" class="headerlink" title="🎯 应用示例与最佳实践"></a>🎯 应用示例与最佳实践</h2><h3 id="💡-栈标签代码生成示例"><a href="#💡-栈标签代码生成示例" class="headerlink" title="💡 栈标签代码生成示例"></a>💡 栈标签代码生成示例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function:</span><br><span class="line">    addi sp, sp, -512    # 栈帧分配</span><br><span class="line">    gentag t0, zero      # 生成基础标签</span><br><span class="line">    addi s1, sp, 16      # 第一个对象地址</span><br><span class="line">    addtag t1, t0, 1     # 派生标签+1</span><br><span class="line">    or s1, s1, t1        # 组合地址和标签</span><br><span class="line">    settag s1, 1         # 设置内存标签</span><br><span class="line">    # ... 对象使用 ...</span><br><span class="line">    addi s1, sp, 16      # 清除指针标签</span><br><span class="line">    settag s1, 1         # 重置内存标签</span><br></pre></td></tr></table></figure><h3 id="🔧-性能优化策略"><a href="#🔧-性能优化策略" class="headerlink" title="🔧 性能优化策略"></a>🔧 性能优化策略</h3><ol><li><strong>局部访问优化</strong>: 使用<code>nietc</code>免除可信局部访问检查</li><li><strong>标签派生</strong>: 使用<code>addtag</code>高效管理相关对象标签</li><li><strong>批量设置</strong>: 利用<code>settag</code>的连续块设置减少指令数</li></ol><hr><h2 id="📊-总结要点"><a href="#📊-总结要点" class="headerlink" title="📊 总结要点"></a>📊 总结要点</h2><h3 id="🎯-核心价值"><a href="#🎯-核心价值" class="headerlink" title="🎯 核心价值"></a>🎯 核心价值</h3><ul><li><strong>硬件加速</strong>: 相比纯软件方案显著降低性能开销</li><li><strong>生产可用</strong>: 适合各种部署场景包括生产环境</li><li><strong>灵活控制</strong>: 支持页面粒度和指令粒度的检查控制</li></ul><h3 id="🔍-关键特性"><a href="#🔍-关键特性" class="headerlink" title="🔍 关键特性"></a>🔍 关键特性</h3><ol><li><strong>细粒度保护</strong>: 16字节内存块级别的安全保护</li><li><strong>随机化安全</strong>: 伪随机标签防止攻击者预测</li><li><strong>兼容性设计</strong>: 通过寄存器控制实现向后兼容</li><li><strong>性能优化</strong>: 提供多种免除检查机制</li></ol><h3 id="📈-适用场景"><a href="#📈-适用场景" class="headerlink" title="📈 适用场景"></a>📈 适用场景</h3><ul><li><strong>安全关键应用</strong>: 需要内存安全保证的生产系统</li><li><strong>开发测试</strong>: 高效的单元测试和模糊测试</li><li><strong>遗留代码</strong>: 对现有C&#x2F;C++代码的增量安全增强</li></ul><p>这份学习笔记涵盖了RISC-V MTE扩展的核心技术要点，为深入理解和实际应用提供了全面的参考框架。</p><h2 id="Hello-World示例-标签使用全过程"><a href="#Hello-World示例-标签使用全过程" class="headerlink" title="Hello World示例 - 标签使用全过程"></a>Hello World示例 - 标签使用全过程</h2><h3 id="程序启动初始化-环境准备"><a href="#程序启动初始化-环境准备" class="headerlink" title="程序启动初始化 (环境准备)"></a>程序启动初始化 (环境准备)</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Hello World程序示例</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> greeting[<span class="number">32</span>] = <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line">    <span class="type">char</span>* heap_str = <span class="built_in">malloc</span>(<span class="number">64</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">strcpy</span>(heap_str, greeting);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, heap_str);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">free</span>(heap_str);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="栈内存标签设置过程"><a href="#栈内存标签设置过程" class="headerlink" title="栈内存标签设置过程"></a>栈内存标签设置过程</h3><h4 id="编译器生成的汇编代码示例："><a href="#编译器生成的汇编代码示例：" class="headerlink" title="编译器生成的汇编代码示例："></a>编译器生成的汇编代码示例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">main:</span><br><span class="line">    # 函数序言 - 栈帧设置</span><br><span class="line">    addi sp, sp, -64        # 分配64字节栈空间 (4个内存块)</span><br><span class="line">    </span><br><span class="line">    # 生成基础标签</span><br><span class="line">    gentag t0               # 生成随机标签，存储在t0的高位</span><br><span class="line">    </span><br><span class="line">    # 为栈对象设置标签</span><br><span class="line">    addi t1, sp, 16         # greeting数组地址</span><br><span class="line">    addtag t2, t0, 1        # 派生greeting标签 = base + 1</span><br><span class="line">    or t1, t1, t2           # 组合地址和标签</span><br><span class="line">    settag t1, 1            # 为greeting数组设置标签 (1个内存块)</span><br><span class="line">    </span><br><span class="line">    # 存储数据</span><br><span class="line">    la t3, hello_str</span><br><span class="line">    sd t3, 16(sp)           # 存储&quot;Hello, World!&quot;到栈</span><br></pre></td></tr></table></figure><p><strong>标签存储布局：</strong></p><ul><li>内存块0 (sp+0~sp+15): 未使用，标签&#x3D;0</li><li>内存块1 (sp+16~sp+31): greeting数组，标签&#x3D;base+1</li><li>内存块2-3: 其他栈数据</li></ul><h3 id="堆内存标签设置过程"><a href="#堆内存标签设置过程" class="headerlink" title="堆内存标签设置过程"></a>堆内存标签设置过程</h3><h4 id="malloc实现示例："><a href="#malloc实现示例：" class="headerlink" title="malloc实现示例："></a>malloc实现示例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">malloc:</span><br><span class="line">    # ... 内存分配逻辑 ...</span><br><span class="line">    mv a0, allocated_addr   # 分配的内存地址</span><br><span class="line">    </span><br><span class="line">    # 生成堆对象标签</span><br><span class="line">    gentag t1               # 生成新随机标签</span><br><span class="line">    addtag a0, t1, 0        # 为指针设置标签</span><br><span class="line">    settag a0, 3            # 为4个连续内存块设置标签 (64字节)</span><br><span class="line">    </span><br><span class="line">    ret</span><br><span class="line">    </span><br><span class="line"># main函数中的堆分配调用</span><br><span class="line">    li a0, 64</span><br><span class="line">    call malloc             # 返回带标签的指针</span><br><span class="line">    mv s0, a0               # 堆字符串指针</span><br></pre></td></tr></table></figure><h3 id="内存访问时的标签检查"><a href="#内存访问时的标签检查" class="headerlink" title="内存访问时的标签检查"></a>内存访问时的标签检查</h3><h4 id="编译器生成的访问代码："><a href="#编译器生成的访问代码：" class="headerlink" title="编译器生成的访问代码："></a>编译器生成的访问代码：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># strcpy(heap_str, greeting) 的实现</span><br><span class="line">strcpy_impl:</span><br><span class="line">    # 堆指针访问 - 触发标签检查</span><br><span class="line">    lb t0, 16(sp)           # 读取栈数据 (标签检查通过)</span><br><span class="line">    sb t0, 0(s0)            # 写入堆数据 (标签检查通过)</span><br><span class="line">    </span><br><span class="line">    # 每次内存访问都会：</span><br><span class="line">    # 1. 从指针提取pointer_tag</span><br><span class="line">    # 2. 根据有效地址计算mc_tag_va = VITT_BASE + (va &gt;&gt; 4)（8位标签）</span><br><span class="line">    # 3. 从标签存储区加载mc_tag</span><br><span class="line">    # 4. 比较pointer_tag == mc_tag</span><br></pre></td></tr></table></figure><p><strong>标签检查流程：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pointer_tag = s0[63:57]     # 从指针提取7位标签</span><br><span class="line">va = s0 &amp; 0x00FFFFFFFFFFFFFF # 清除标签位得到实际地址(用户空间mask)</span><br><span class="line">mc_tag_va = VITT_BASE + (va &gt;&gt; 4)  # 计算标签存储地址</span><br><span class="line">mc_tag = load_byte(mc_tag_va)      # 加载内存标签</span><br><span class="line">if pointer_tag != mc_tag: raise_exception()</span><br></pre></td></tr></table></figure><h3 id="内存释放时的标签处理"><a href="#内存释放时的标签处理" class="headerlink" title="内存释放时的标签处理"></a>内存释放时的标签处理</h3><h4 id="free实现示例："><a href="#free实现示例：" class="headerlink" title="free实现示例："></a>free实现示例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">free:</span><br><span class="line">    # 清除内存标签 (防止UAF)</span><br><span class="line">    mv t0, a0</span><br><span class="line">    andi t0, t0, 0x00FFFFFFFFFFFFFF  # 清除指针标签</span><br><span class="line">    settag t0, 3             # 设置新标签(通常为0)</span><br><span class="line">    </span><br><span class="line">    # ... 实际内存释放逻辑 ...</span><br><span class="line">    ret</span><br><span class="line"></span><br><span class="line"># main函数中的释放调用</span><br><span class="line">    mv a0, s0</span><br><span class="line">    call free               # 清除堆内存标签</span><br></pre></td></tr></table></figure><h3 id="虚拟索引标签表-VITT-操作"><a href="#虚拟索引标签表-VITT-操作" class="headerlink" title="虚拟索引标签表(VITT)操作"></a>虚拟索引标签表(VITT)操作</h3><p><strong>标签存储地址计算：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设参数：</span></span><br><span class="line">VITT_BASE = <span class="number">0x80000000</span>      <span class="comment">// 标签表基地址</span></span><br><span class="line">pointer_tag_width = <span class="number">7</span>        <span class="comment">// 7位指针标签</span></span><br><span class="line">mc_tag_width = <span class="number">8</span>            <span class="comment">// 8位内存标签</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于地址0x1000：</span></span><br><span class="line">mc_tag_va = <span class="number">0x80000000</span> + (<span class="number">0x1000</span> &gt;&gt; <span class="number">4</span>) = <span class="number">0x80000100</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于地址0x1010：</span></span><br><span class="line">mc_tag_va = <span class="number">0x80000000</span> + (<span class="number">0x1010</span> &gt;&gt; <span class="number">4</span>) = <span class="number">0x80000101</span></span><br></pre></td></tr></table></figure><h3 id="异常处理场景"><a href="#异常处理场景" class="headerlink" title="异常处理场景"></a>异常处理场景</h3><h4 id="标签不匹配异常："><a href="#标签不匹配异常：" class="headerlink" title="标签不匹配异常："></a>标签不匹配异常：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 使用已释放内存 (UAF)</span><br><span class="line">mov a0, s0                  # s0指向已释放内存</span><br><span class="line">lb t0, 0(a0)                # 触发标签检查异常</span><br><span class="line"></span><br><span class="line"># 异常流程：</span><br><span class="line"># 1. 检测到pointer_tag != mc_tag</span><br><span class="line"># 2. 抛出software check exception (tval=4)</span><br><span class="line"># 3. 程序终止或进入异常处理</span><br></pre></td></tr></table></figure><h4 id="缓冲区溢出检测："><a href="#缓冲区溢出检测：" class="headerlink" title="缓冲区溢出检测："></a>缓冲区溢出检测：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 缓冲区溢出尝试</span><br><span class="line">addi t0, s0, 80             # 超出分配的64字节</span><br><span class="line">lb t1, 0(t0)                # 访问越界内存</span><br><span class="line"></span><br><span class="line"># 由于越界访问不同的内存块，标签不匹配</span><br><span class="line"># 触发异常防止内存破坏</span><br></pre></td></tr></table></figure><h3 id="性能优化-标签检查免除"><a href="#性能优化-标签检查免除" class="headerlink" title="性能优化 - 标签检查免除"></a>性能优化 - 标签检查免除</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 使用nietc指令免除局部访问的标签检查</span><br><span class="line">nietc                       # 下一条指令免除标签检查</span><br><span class="line">lb t0, 16(sp)               # 栈局部访问，免除检查</span><br><span class="line"># TTCD状态自动恢复</span><br><span class="line"></span><br><span class="line">nietc</span><br><span class="line">sb t0, 0(s0)                # 堆访问，免除检查</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Hello World程序的标签使用流程：</p><ol><li><strong>初始化</strong>：栈和堆分配时生成随机标签</li><li><strong>设置</strong>：使用<code>settag</code>为内存区域设置标签</li><li><strong>访问</strong>：每次内存访问自动进行标签检查</li><li><strong>释放</strong>：释放内存时重置标签防止UAF</li><li><strong>保护</strong>：检测缓冲区溢出和use-after-free攻击</li></ol>]]></content>
      
      
      <categories>
          
          <category> RISC-V </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RISC-V </tag>
            
            <tag> MTE </tag>
            
            <tag> memory tagging </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux源码解读(OpenAI)：上下文切换</title>
      <link href="/2025/09/19/Linux%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-OpenAI-%EF%BC%9A%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2/"/>
      <url>/2025/09/19/Linux%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-OpenAI-%EF%BC%9A%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">File: Documentation/context-switch.md</span><br><span class="line">Generated with: AI-assisted authoring</span><br><span class="line">AI model: unspecified (inserted by maintainers)</span><br><span class="line">Generation date: 2025-09-19</span><br><span class="line"></span><br><span class="line">Repository: linux (torvalds)</span><br><span class="line">Branch: master</span><br><span class="line">Commit: 76eeb9b8de98</span><br><span class="line">Nearest tag: v6.17-rc5</span><br><span class="line">Workspace status: uncommitted local changes present (see git status)</span><br><span class="line"></span><br><span class="line">Note: Please update the &quot;AI model&quot; field if you want a specific model identifier to be recorded. The commit and tag info reflect the source tree used when this document was edited.</span><br></pre></td></tr></table></figure><h2 id="深入理解-context-switch-整理版"><a href="#深入理解-context-switch-整理版" class="headerlink" title="深入理解 context_switch (整理版)"></a>深入理解 context_switch (整理版)</h2><p>本文档目标：把 <code>kernel/sched/core.c</code> 中的 <code>context_switch()</code> 的实现与设计意图，用更清晰的结构和排版讲清楚，便于阅读和检索。</p><p>如果你只想快速了解要点，请看 “TL;DR &#x2F; 快速参考”。否则继续阅读下面的分节（从概览到架构差异、RISC-V 细节与实践）。</p><hr><h2 id="快速参考"><a href="#快速参考" class="headerlink" title="快速参考"></a>快速参考</h2><ul><li>context_switch 做三件事：<ol><li>准备与同步（prepare_task_switch、arch hook、membarrier）</li><li>切换地址空间（lazy TLB &#x2F; switch_mm &#x2F; ASID &#x2F; SATP）</li><li>切换寄存器&#x2F;栈（switch_to -&gt; __switch_to），并完成收尾（finish_task_switch）</li></ol></li><li>主要分支由 <code>next-&gt;mm</code> 是否为空决定（内核线程 vs 用户线程）。</li><li>RISC-V 关键点：ASID 分配、SATP 写入、TLB&#x2F;ICACHE 刷新、<code>__switch_to</code> 汇编负责快速寄存器交换。</li></ul><hr><h2 id="目录（快速跳转）"><a href="#目录（快速跳转）" class="headerlink" title="目录（快速跳转）"></a>目录（快速跳转）</h2><ul><li>函数接口（inputs&#x2F;outputs）</li><li>快速流程图与代码要点</li><li>逐段解析（详细）</li><li>RISC-V：实现细节与汇编摘录</li><li>实验与调试（try it）</li><li>Graphviz 图与渲染</li><li>参考与下一步</li></ul><hr><h2 id="函数接口（contract）"><a href="#函数接口（contract）" class="headerlink" title="函数接口（contract）"></a>函数接口（contract）</h2><ul><li>输入：<ul><li><code>struct rq *rq</code> — 目标 CPU 的 runqueue</li><li><code>struct task_struct *prev</code> — 要切出的任务</li><li><code>struct task_struct *next</code> — 要切入的任务</li><li><code>struct rq_flags *rf</code> — 调度过程中使用的标志</li></ul></li><li>输出：返回更新后的 <code>rq</code>（通常 <code>finish_task_switch</code> 的返回值）</li><li>成功条件：寄存器&#x2F;栈、MM（如适用）正确切换，相关屏障与 tracepoints 执行完毕</li><li>错误&#x2F;异常：本函数不返回错误码；异常由上层检测（WARN、BUG、trace）</li></ul><hr><h2 id="快速流程图与代码要点"><a href="#快速流程图与代码要点" class="headerlink" title="快速流程图与代码要点"></a>快速流程图与代码要点</h2><p>核心代码（节选，来自 <code>kernel/sched/core.c</code>）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> __always_inline <span class="keyword">struct</span> rq *</span><br><span class="line"><span class="title function_">context_switch</span><span class="params">(<span class="keyword">struct</span> rq *rq, <span class="keyword">struct</span> task_struct *prev,</span></span><br><span class="line"><span class="params">         <span class="keyword">struct</span> task_struct *next, <span class="keyword">struct</span> rq_flags *rf)</span></span><br><span class="line">&#123;</span><br><span class="line">  prepare_task_switch(rq, prev, next);</span><br><span class="line">  arch_start_context_switch(prev);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!next-&gt;mm) &#123; <span class="comment">/* to kernel */</span></span><br><span class="line">    enter_lazy_tlb(prev-&gt;active_mm, next);</span><br><span class="line">    next-&gt;active_mm = prev-&gt;active_mm;</span><br><span class="line">    <span class="keyword">if</span> (prev-&gt;mm)</span><br><span class="line">      mmgrab_lazy_tlb(prev-&gt;active_mm);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      prev-&gt;active_mm = <span class="literal">NULL</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123; <span class="comment">/* to user */</span></span><br><span class="line">    membarrier_switch_mm(rq, prev-&gt;active_mm, next-&gt;mm);</span><br><span class="line">    switch_mm_irqs_off(prev-&gt;active_mm, next-&gt;mm, next);</span><br><span class="line">    lru_gen_use_mm(next-&gt;mm);</span><br><span class="line">    <span class="keyword">if</span> (!prev-&gt;mm) &#123;</span><br><span class="line">      rq-&gt;prev_mm = prev-&gt;active_mm;</span><br><span class="line">      prev-&gt;active_mm = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  switch_mm_cid(rq, prev, next);</span><br><span class="line">  prepare_lock_switch(rq, next, rf);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* low-level register/stack switch */</span></span><br><span class="line">  switch_to(prev, next, prev);</span><br><span class="line">  barrier();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> finish_task_switch(prev);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/context-switch-riscv.svg"><br>关键流程（高阶）：prepare -&gt; arch hook -&gt; MM 决策 -&gt; switch_mm_cid -&gt; prepare_lock_switch -&gt; switch_to -&gt; finish</p><hr><h2 id="逐段详解"><a href="#逐段详解" class="headerlink" title="逐段详解"></a>逐段详解</h2><p>下面对 <code>context_switch</code> 的每个阶段给出更深入的实现细节、涉及的子系统和常见的实现注意点。目标是帮助读者把高层逻辑与内核中并发&#x2F;性能考虑联系起来。</p><ol><li>prepare_task_switch(rq, prev, next)</li></ol><ul><li>作用：准备切换所需的高层状态，常见内容包括：<ul><li>更新调度统计（如 <code>schedstat</code>、<code>nr_switches</code>），并触发相应的 tracepoint（例如 <code>sched_switch</code> 的前序信息）。</li><li>为后续的 MM 切换或寄存器切换做好条件检查（例如确保 <code>next</code> 的状态可运行、处理 DEAD 状态等）。</li><li>设置或调整与延迟清理有关的字段（例如在某些路径把 <code>rq-&gt;prev_mm</code> 标记为待释放）。</li><li>禁用抢占&#x2F;递增上下文切换计数以保证临界区（上层 schedule 路径在进入 context_switch 前通常已禁用抢占）。</li></ul></li></ul><p>注意：此阶段应尽量轻量，以避免把昂贵操作放在调度临界路径内；昂贵清理通常延迟到 <code>finish_task_switch()</code>。</p><ol start="2"><li>arch_start_context_switch(prev)</li></ol><ul><li>作用：为架构或虚拟化层提供一个切换前的钩子，常见用途：<ul><li>对 paravirt 或 hypervisor 通知（在某些实现中会合并页表切换&#x2F;切换后处理以减少超主机调用）。</li><li>做架构相关的快表清理或为接下来 <code>switch_to</code> 的汇编做准备（默认实现为空宏）。</li></ul></li></ul><p>实现要点：各架构可选择性覆盖此钩子；文档在 <code>include/linux/pgtable.h</code> 有宏定义。</p><ol start="3"><li>MM（地址空间）处理</li></ol><p>这是 context_switch 中最复杂且对性能影响最大的部分之一。核心决策基于 <code>next-&gt;mm</code>：</p><ul><li><p>to kernel (next-&gt;mm &#x3D;&#x3D; NULL)</p><ul><li>行为：内核线程没有独立用户页表，内核通常把 <code>next-&gt;active_mm</code> 设为 <code>prev-&gt;active_mm</code> 并使用 lazy TLB 机制继续访问同一地址空间直到合适时机释放。</li><li>关键函数：<code>enter_lazy_tlb()</code>（在某些架构此函数会处理 lazy 引用转移并标记 active_mm），以及在必要时对 <code>prev-&gt;active_mm</code> 做引用计数增量（<code>mmgrab_lazy_tlb</code>）。</li></ul></li><li><p>to user (next-&gt;mm !&#x3D; NULL)</p><ul><li>行为：必须把 CPU 的页表上下文从 <code>prev-&gt;active_mm</code> 切换到 <code>next-&gt;mm</code>。此路径涉及多项操作：<ul><li><code>membarrier_switch_mm()</code>：处理 sys_membarrier 要求的屏障语义，保证 return-to-user 的屏障可见性。</li><li><code>switch_mm_irqs_off(prev-&gt;active_mm, next-&gt;mm, next)</code>：执行实际的页表切换；该接口通常在关中断上下文执行以避免并发访问页表寄存器或发生部分可见状态。</li><li><code>lru_gen_use_mm(next-&gt;mm)</code>：通知 LRU-generation 子系统此 mm 被访问，用于内存回收&#x2F;衰老策略。</li><li>延迟 mmdrop：若 <code>prev</code> 是内核线程，会把 <code>prev-&gt;active_mm</code> 放到 <code>rq-&gt;prev_mm</code>，在 <code>finish_task_switch()</code> 中再执行 mmdrop（因为 mmdrop 可能较慢，应避免在临界路径做）。</li></ul></li></ul></li></ul><p>实现要点与风险：</p><ul><li>页表切换通常涉及写入特权寄存器（如 SATP），并可能触发 TLB invalidation。各架构会有专门实现（<code>switch_mm()</code>&#x2F;<code>switch_mm_irqs_off()</code>）来封装这些细节。</li><li>为了性能，ASID（或其他硬件上下文 ID）通常被重用&#x2F;分配；当 ASID 不足时会发生 rollover，此时需要全局 TLB flush 并更新版本号（参见各架构实现）。</li></ul><ol start="4"><li>switch_mm_cid(rq, prev, next)</li></ol><ul><li><p>作用：维护与上下文 ID（ASID、CID）相关的 CPU 层次跟踪和统计，并在必要时触发基于 CID 的操作（例如为 perf&#x2F;ptrace&#x2F;硬件上下文管理同步）。</p></li><li><p>要点：该函数依赖此前的屏障（membarrier &#x2F; switch_mm）来保证可见性；如果这些屏障被修改，<code>switch_mm_cid()</code> 的语义可能需要对齐更新。</p></li></ul><ol start="5"><li>prepare_lock_switch(rq, next, rf)</li></ol><ul><li>作用：准备 runqueue&#x2F;锁状态以便执行低层寄存器切换。具体含义包括：<ul><li>确保 <code>rq-&gt;curr</code>&#x2F;<code>rq-&gt;nr_running</code> 等调度元数据在切换点的一致性；</li><li>将需要在切换期间保留或临时调整的锁标志合并到 <code>rf</code> 中（<code>rq_flags</code> 用于在 schedule 路径上下文中传递锁&#x2F;irq 状态）；</li><li>在一些实现中会处理与 load-balancing 或偷取相关的最后准备步骤。</li></ul></li></ul><p>实现注意：准备阶段越简短越好，复杂的同步应尽可能延后或拆分。</p><ol start="6"><li>switch_to(prev, next, prev) &#x2F; __switch_to</li></ol><ul><li><p><code>switch_to</code> 是架构层的宏封装：它在调用汇编切换前处理 FPU&#x2F;向量寄存器的保存&#x2F;恢复、环境 CSR（如 ENVCFG）的写入、以及在需要时执行 icache flush 检查。</p></li><li><p><code>__switch_to</code>（通常为汇编）负责：</p><ul><li>保存 callee-saved 寄存器（例如 ra, s0-s11）到 <code>prev-&gt;thread</code>；</li><li>恢复 <code>next-&gt;thread</code> 中保存的寄存器并切换 <code>tp</code>&#x2F;thread_info，使 <code>current</code> 读写快速生效；</li><li>可能还会在硬件&#x2F;ABI 层面处理特殊位（如 SUM&#x2F;FS）或 shadow call stack 的保存&#x2F;恢复；</li><li>返回时，低层寄存器与内核栈已切换到 <code>next</code> 的上下文。<code>last</code> 参数通常用于让上层记录&#x2F;获得被切出的 <code>prev</code> 指针以便后续清理。</li></ul></li></ul><p>实现要点与代价：寄存器保存&#x2F;恢复代价是上下文切换的固定开销，同时 FPU&#x2F;向量寄存器（如果热切换）可能导致显著额外开销；因此内核通过惰性保存&#x2F;恢复减少频率（如 lazy FPU）。</p><ol start="7"><li>barrier() 与内存可见性</li></ol><ul><li>在完成低层切换后使用编译器&#x2F;CPU barrier 来保证内存操作顺序，必要时配合 <code>membarrier</code> 系统调用的语义，确保用户态恢复前的屏障约束被满足。</li></ul><ol start="8"><li>finish_task_switch(prev)</li></ol><ul><li>作用：完成切换后的清理与统计，是把昂贵或可以延后操作移出临界路径的主要场所，常见工作包括：<ul><li>执行 lazy TLB &#x2F; lazy mm 的卸载（如 <code>mmdrop_lazy_tlb()</code>）；</li><li>触发 tracepoints（<code>sched_switch</code> 的后序）、更新调度统计、以及 <code>nr_context_switches</code> 的计数；</li><li>通知 RCU（<code>rcu_note_context_switch()</code>）表明当前任务进入或退出 quiescent state；</li><li>释放或减少对 <code>prev-&gt;active_mm</code> 的引用（延迟的 mmdrop）；</li><li>恢复 preemption &#x2F; 恢复中断状态（如果在切换路径中被暂时修改）。</li></ul></li></ul><p>实现要点：把昂贵清理延迟到这里能显著降低上下文切换的延迟，但会在短期内增加内存占用或延迟回收；必须保证并发安全。</p><hr><h2 id="RISC-V：实现细节与汇编摘录"><a href="#RISC-V：实现细节与汇编摘录" class="headerlink" title="RISC-V：实现细节与汇编摘录"></a>RISC-V：实现细节与汇编摘录</h2><p>位置参考：</p><ul><li><code>arch/riscv/kernel/entry.S</code>（<code>__switch_to</code> 汇编）</li><li><code>arch/riscv/include/asm/switch_to.h</code>（<code>switch_to</code> 宏）</li><li><code>arch/riscv/mm/context.c</code>（<code>switch_mm</code>、ASID 管理）</li></ul><p>汇编摘录（节选，带关键注释）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">SYM_FUNC_START(__switch_to)</span><br><span class="line">  /* Save context into prev-&gt;thread */</span><br><span class="line">  li    a4,  TASK_THREAD_RA        # offset base for prev-&gt;thread</span><br><span class="line">  add   a3, a0, a4                # a3 = prev + offset</span><br><span class="line">  add   a4, a1, a4                # a4 = next + offset</span><br><span class="line">  REG_S ra,  TASK_THREAD_RA_RA(a3)</span><br><span class="line">  REG_S sp,  TASK_THREAD_SP_RA(a3)</span><br><span class="line">  REG_S s0,  TASK_THREAD_S0_RA(a3)</span><br><span class="line">  ...                            # 保存 s1..s11</span><br><span class="line"></span><br><span class="line">  /* save the user space access flag */</span><br><span class="line">  csrr  s0, CSR_STATUS</span><br><span class="line">  REG_S s0, TASK_THREAD_SUM_RA(a3)</span><br><span class="line"></span><br><span class="line">  scs_save_current</span><br><span class="line"></span><br><span class="line">  /* Restore context from next-&gt;thread */</span><br><span class="line">  REG_L s0,  TASK_THREAD_SUM_RA(a4)</span><br><span class="line">  li    s1,  SR_SUM</span><br><span class="line">  and   s0,  s0, s1</span><br><span class="line">  csrs  CSR_STATUS, s0           # restore SUM bit in status CSR</span><br><span class="line">  REG_L ra,  TASK_THREAD_RA_RA(a4)</span><br><span class="line">  REG_L sp,  TASK_THREAD_SP_RA(a4)</span><br><span class="line">  ...                            # 恢复 s1..s11</span><br><span class="line"></span><br><span class="line">  move tp, a1                    # set tp to next (thread_info)</span><br><span class="line">  scs_load_current</span><br><span class="line">  ret</span><br><span class="line">SYM_FUNC_END(__switch_to)</span><br></pre></td></tr></table></figure><p>简要寄存器表：ra, sp, s0-s11（callee-saved），以及 <code>CSR_STATUS</code>（SUM&#x2F;FS 位）。</p><p>是否需要，我可以把 <code>TASK_THREAD_*</code> 的具体偏移表也摘录进来（需要读取对应 header）。</p><hr><h2 id="实验与调试（Try-it）"><a href="#实验与调试（Try-it）" class="headerlink" title="实验与调试（Try it）"></a>实验与调试（Try it）</h2><p>快速命令（在仓库根目录）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看 context_switch 源码段</span></span><br><span class="line">sed -n <span class="string">&#x27;5288,5360p&#x27;</span> kernel/sched/core.c</span><br></pre></td></tr></table></figure><p>调试提示：使用 tracepoints（<code>sched_switch</code>、<code>rcu_note_context_switch</code>）、ftrace 或在 <code>__switch_to</code> 附近设置 kgdb&#x2F;kprobe 来观察寄存器切换。</p><hr><h2 id="参考与下一步"><a href="#参考与下一步" class="headerlink" title="参考与下一步"></a>参考与下一步</h2><ul><li><code>kernel/sched/core.c</code></li><li><code>arch/*/kernel</code>（各架构的 <code>__switch_to</code> &#x2F; <code>switch_mm</code> 实现）</li><li><code>arch/riscv/mm/context.c</code>（ASID 管理）</li><li>I-cache 刷新与 membarrier：RISC-V 的 membarrier&#x2F;ICACHE 协作在 <code>membarrier_arch_switch_mm</code> &#x2F; <code>flush_icache_deferred</code> 中体现；<code>context_switch</code>（上游）调用的 <code>membarrier_switch_mm</code> 需与此配合以保证用户态指令可见性。</li><li>ASID 池与 rollover：实现维护 <code>current_version</code>、<code>context_asid_map</code>、每 CPU 的 <code>active_context</code> 和 <code>reserved_context</code>，当 ASID 不足时会触发 rollover（增加版本）并在 <code>__flush_context</code> 中更新状态并强制各 CPU 做 TLB 无效化。</li><li>SMP&#x2F;迁移：<code>switch_to_should_flush_icache</code> 会在任务迁移（<code>thread.prev_cpu</code>）或 mm&#x2F;thread 标记了 <code>force_icache_flush</code> 时触发 i-cache flush，避免执行 stale 指令流。</li></ul><hr><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>本文档给出了 <code>context_switch</code> 的结构化、可读版本，强调了 MM 管理、屏障语义和低层切换点。下一步可以：</p><ul><li>对比 x86&#x2F;arm64 的 <code>switch_to</code> 与 <code>switch_mm</code> 实现差异；</li><li>使用 tracepoints 和 perf 收集上下文切换的延迟分布；</li><li>深入 read&#x2F;modify <code>enter_lazy_tlb</code>、<code>switch_mm_irqs_off</code> 的实现细节。</li></ul>]]></content>
      
      
      <categories>
          
          <category> kernel </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> kernel </tag>
            
            <tag> context_switch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux源码解读(灵码)：上下文切换</title>
      <link href="/2025/09/19/Linux%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB%EF%BC%9A%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2/"/>
      <url>/2025/09/19/Linux%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB%EF%BC%9A%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux内核context-switch函数详解"><a href="#Linux内核context-switch函数详解" class="headerlink" title="Linux内核context_switch函数详解"></a>Linux内核context_switch函数详解</h1><ul><li>linux v6.17-rc6 master 8b789f2b7602a818e7c7488c74414fae21392b63 2025-09-18</li><li>generated by 通义灵码</li></ul><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><code>context_switch</code>函数是Linux内核调度器的核心组件之一，负责在进程或线程之间切换CPU执行上下文。当调度器决定切换当前运行的任务时，该函数会保存当前任务的状态并恢复下一个任务的状态。</p><h2 id="函数定义和位置"><a href="#函数定义和位置" class="headerlink" title="函数定义和位置"></a>函数定义和位置</h2><p>函数位于<code>kernel/sched/core.c</code>文件中，从第5301行开始：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> __always_inline <span class="keyword">struct</span> rq *</span><br><span class="line"><span class="title function_">context_switch</span><span class="params">(<span class="keyword">struct</span> rq *rq, <span class="keyword">struct</span> task_struct *prev,</span></span><br><span class="line"><span class="params">               <span class="keyword">struct</span> task_struct *next, <span class="keyword">struct</span> rq_flags *rf)</span></span><br></pre></td></tr></table></figure><h2 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h2><ul><li><code>rq</code>: 当前CPU的运行队列</li><li><code>prev</code>: 当前正在运行的任务（将被切换出去）</li><li><code>next</code>: 下一个将要运行的任务（将被切换进来）</li><li><code>rf</code>: 运行队列标志</li></ul><h2 id="函数详细分析"><a href="#函数详细分析" class="headerlink" title="函数详细分析"></a>函数详细分析</h2><h3 id="1-准备阶段"><a href="#1-准备阶段" class="headerlink" title="1. 准备阶段"></a>1. 准备阶段</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">prepare_task_switch(rq, prev, next);</span><br></pre></td></tr></table></figure><p>该函数执行上下文切换前的准备工作：</p><ul><li>处理KCOV（内核代码覆盖率）相关准备</li><li>更新调度信息</li><li>处理性能事件</li><li>通知抢占相关的回调函数</li><li>处理本地kmap映射</li><li>准备任务和架构特定的切换操作</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arch_start_context_switch(prev);</span><br></pre></td></tr></table></figure><p>架构特定的上下文切换起始操作。在虚拟化环境中，这可能与<code>switch_to</code>中的退出操作结合，将页表重新加载和切换后端合并为一个超级调用。</p><h3 id="2-内存管理上下文切换"><a href="#2-内存管理上下文切换" class="headerlink" title="2. 内存管理上下文切换"></a>2. 内存管理上下文切换</h3><p>这是上下文切换中最复杂的部分，处理不同类型的内存管理上下文之间的切换：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!next-&gt;mm) &#123;                                <span class="comment">// to kernel</span></span><br><span class="line">    enter_lazy_tlb(prev-&gt;active_mm, next);</span><br><span class="line"></span><br><span class="line">    next-&gt;active_mm = prev-&gt;active_mm;</span><br><span class="line">    <span class="keyword">if</span> (prev-&gt;mm)                           <span class="comment">// from user</span></span><br><span class="line">        mmgrab_lazy_tlb(prev-&gt;active_mm);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        prev-&gt;active_mm = <span class="literal">NULL</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;                                        <span class="comment">// to user</span></span><br><span class="line">    membarrier_switch_mm(rq, prev-&gt;active_mm, next-&gt;mm);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * sys_membarrier() requires an smp_mb() between setting</span></span><br><span class="line"><span class="comment">     * rq-&gt;curr / membarrier_switch_mm() and returning to userspace.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The below provides this either through switch_mm(), or in</span></span><br><span class="line"><span class="comment">     * case &#x27;prev-&gt;active_mm == next-&gt;mm&#x27; through</span></span><br><span class="line"><span class="comment">     * finish_task_switch()&#x27;s mmdrop().</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    switch_mm_irqs_off(prev-&gt;active_mm, next-&gt;mm, next);</span><br><span class="line">    lru_gen_use_mm(next-&gt;mm);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!prev-&gt;mm) &#123;                        <span class="comment">// from kernel</span></span><br><span class="line">        <span class="comment">/* will mmdrop_lazy_tlb() in finish_task_switch(). */</span></span><br><span class="line">        rq-&gt;prev_mm = prev-&gt;active_mm;</span><br><span class="line">        prev-&gt;active_mm = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>存在四种主要场景：</p><ol><li><p><strong>内核到内核切换</strong> (<code>!next-&gt;mm</code> 且 <code>!prev-&gt;mm</code>)：</p><ul><li>下一个任务是内核线程</li><li>进入懒惰TLB模式并传递活动的内存管理结构</li></ul></li><li><p><strong>用户到内核切换</strong> (<code>!next-&gt;mm</code> 且 <code>prev-&gt;mm</code>)：</p><ul><li>从用户进程切换到内核线程</li><li>获取前一个内存管理结构的懒惰引用</li></ul></li><li><p><strong>内核到用户切换</strong> (<code>next-&gt;mm</code> 且 <code>!prev-&gt;mm</code>)：</p><ul><li>从内核线程切换到用户进程</li><li>切换内存映射并为新内存管理结构设置LRU生成器</li><li>前一个活动内存管理结构将在<code>finish_task_switch()</code>中被释放</li></ul></li><li><p><strong>用户到用户切换</strong> (<code>next-&gt;mm</code> 且 <code>prev-&gt;mm</code>)：</p><ul><li>在两个用户进程之间切换</li><li>切换内存映射并适当处理内存管理引用</li></ul></li></ol><h3 id="3-CPU-ID管理"><a href="#3-CPU-ID管理" class="headerlink" title="3. CPU ID管理"></a>3. CPU ID管理</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">switch_mm_cid(rq, prev, next);</span><br></pre></td></tr></table></figure><p>处理内存管理上下文的CPU ID管理，这对NUMA感知的内存管理很重要。</p><h3 id="4-锁准备"><a href="#4-锁准备" class="headerlink" title="4. 锁准备"></a>4. 锁准备</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">prepare_lock_switch(rq, next, rf);</span><br></pre></td></tr></table></figure><p>为锁切换做准备：</p><ul><li>提前释放运行队列锁（因为下一个任务将释放它）</li><li>处理用于调试的锁依赖跟踪</li></ul><h3 id="5-处理器状态切换"><a href="#5-处理器状态切换" class="headerlink" title="5. 处理器状态切换"></a>5. 处理器状态切换</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">switch_to(prev, next, prev);</span><br><span class="line">barrier();</span><br></pre></td></tr></table></figure><p>这是实际进行处理器状态切换的地方：</p><ul><li><code>switch_to</code>是一个宏，会展开为特定架构的代码</li><li>它保存当前处理器状态并恢复下一个任务的状态</li><li><a href="file:///home/zhouf/wks/tools/linux/tools/virtio/asm/barrier.h#L3-L4">barrier()</a>确保内存排序</li></ul><h3 id="6-清理阶段"><a href="#6-清理阶段" class="headerlink" title="6. 清理阶段"></a>6. 清理阶段</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> finish_task_switch(prev);</span><br></pre></td></tr></table></figure><p>最后，完成上下文切换后的清理操作。</p><h2 id="关键概念"><a href="#关键概念" class="headerlink" title="关键概念"></a>关键概念</h2><h3 id="内存管理上下文"><a href="#内存管理上下文" class="headerlink" title="内存管理上下文"></a>内存管理上下文</h3><p>在Linux中，任务可以有不同类型的内存管理上下文：</p><ul><li><strong>用户进程</strong>：拥有自己的<code>mm_struct</code>结构，存储在<code>task_struct-&gt;mm</code>中</li><li><strong>内核线程</strong>：没有自己的地址空间，所以<code>task_struct-&gt;mm</code>为NULL，但它们会继承之前运行任务的<code>active_mm</code></li></ul><h3 id="懒惰TLB处理"><a href="#懒惰TLB处理" class="headerlink" title="懒惰TLB处理"></a>懒惰TLB处理</h3><p>内核使用懒惰TLB（Translation Lookaside Buffer）处理来优化上下文切换。不是立即切换TLB条目，而是将之前的TLB标记为”懒惰”，只在必要时才切换。</p><h3 id="内存屏障"><a href="#内存屏障" class="headerlink" title="内存屏障"></a>内存屏障</h3><p>内存屏障在上下文切换中广泛使用，以确保操作的正确排序，特别是对于内存管理和同步原语。</p><h2 id="架构特定实现"><a href="#架构特定实现" class="headerlink" title="架构特定实现"></a>架构特定实现</h2><p><code>context_switch</code>函数严重依赖于架构特定的实现：</p><ol><li><code>switch_to</code> - 每个架构都用汇编语言实现</li><li><code>arch_start_context_switch</code> - 架构特定的准备操作</li><li><code>switch_mm_irqs_off</code> - 架构特定的内存管理切换</li><li>各种内存管理函数都有架构特定的实现</li></ol><h2 id="性能考虑"><a href="#性能考虑" class="headerlink" title="性能考虑"></a>性能考虑</h2><p>上下文切换是昂贵的操作，因为它涉及：</p><ol><li>保存和恢复处理器状态</li><li>切换内存管理上下文</li><li>缓存和TLB刷新</li><li>各种簿记操作</li></ol><p>内核通过以下方式优化：</p><ul><li>使用懒惰TLB处理</li><li>在可能的地方最小化内存屏障</li><li>为常见情况（如内核线程到内核线程切换）提供快速路径</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>context_switch</code>函数是Linux内核调度器中复杂但关键的组成部分。它处理在任务之间切换的复杂细节，同时保持系统完整性、性能和适当的内存管理。理解这个函数对于理解Linux内核如何进行多任务处理和管理系统资源至关重要。</p>]]></content>
      
      
      <categories>
          
          <category> kernel </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> kernel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>uprobe使用：tracefs/perf</title>
      <link href="/2025/09/17/uprobe%E4%BD%BF%E7%94%A8%EF%BC%9Atracefs-perf/"/>
      <url>/2025/09/17/uprobe%E4%BD%BF%E7%94%A8%EF%BC%9Atracefs-perf/</url>
      
        <content type="html"><![CDATA[<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><hr><p><a href="https://www.kernel.org/doc/html/latest/trace/uprobetracer.html">Uprobe-tracer: Uprobe-based Event Tracing</a><br><a href="https://www.cnblogs.com/linhaostudy/p/17446087.html">uprobe的使用浅析</a><br><a href="https://zhuanlan.zhihu.com/p/19085021883">uprobe实现原理</a><br><a href="https://blog.csdn.net/u012489236/article/details/127954817">深入ftrace uprobe原理和功能介绍</a></p><h1 id="tracefs-uprobe"><a href="#tracefs-uprobe" class="headerlink" title="tracefs-uprobe"></a>tracefs-uprobe</h1><hr><p>跟kprobe的流程相似，这里只举例如何设置探测点。<br>假设已经编译好 hello_world 应用。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在hello_world虚拟地址0x10处添加探针, 打印a0, a1, stack[4]</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;p ./hello_world:0x10 arg1=%a0 arg2=%a1 tmp=+4($stack)&#x27;</span> &gt; /sys/kernel/tracing/uprobe_events</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在hello_world虚拟地址0x10处添加返回探针</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;r ./hello_world:0x10&#x27;</span> &gt; /sys/kernel/tracing/uprobe_events</span><br></pre></td></tr></table></figure><h1 id="perf"><a href="#perf" class="headerlink" title="perf"></a>perf</h1><hr><p>perf 在使用动态探针时不区分 uprobe 和 kprobe，使用方法相同：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">perf probe -x hello_world -a <span class="string">&#x27;hello_world:0x10 arg1=%a0 arg2=%a1 tmp=+4($stack)&#x27;</span></span><br><span class="line"><span class="comment"># 在new_func1的第三行添加探针查看寄存器</span></span><br><span class="line">perf probe -x ./hello_world new_func1:3 %ra</span><br><span class="line">perf probe -x ./hello_world 0x4f8 %ra</span><br><span class="line"><span class="comment"># 在new_func1的第三行添加探针查看内存，需要设置引号</span></span><br><span class="line">perf probe -x ./hello_world <span class="string">&quot;new_func1:3 j=-36(%s0):s32&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据提示执行 record命令</span></span><br><span class="line">perf record -e xxxx -aR ./hello_world</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看报告</span></span><br><span class="line">perf script</span><br><span class="line">perf report -i perf.data</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除所有探针</span></span><br><span class="line">perf probe -x hello_world -d <span class="string">&#x27;*&#x27;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> uprobe </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> uprobe </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kprobe使用：tracefs/perf/eBPF(bcc)</title>
      <link href="/2025/09/16/kprobe%E4%BD%BF%E7%94%A8%EF%BC%9Atracefs-perf-eBPF-bcc/"/>
      <url>/2025/09/16/kprobe%E4%BD%BF%E7%94%A8%EF%BC%9Atracefs-perf-eBPF-bcc/</url>
      
        <content type="html"><![CDATA[<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><hr><p><a href="https://www.kernel.org/doc/html/latest/trace/kprobes.html">Kernel Probes</a><br><a href="https://www.kernel.org/doc/html/latest/trace/kprobetrace.html">Kprobe-based Event Tracing</a><br><a href="https://tinylab.org/bcc-overview/">bcc 用法和原理初探之 kprobes 注入</a></p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><hr><p>kprobes 是对内核的动态跟踪，之前介绍了内核模块加载方式的 kprobe 使用，从而实现指令跟踪、局部变量&#x2F;通用寄存器的打印。这里进一步介绍其他使用 kprobe 的方法，包括 tracefs 方式、perf probe 方式、eBPF 方式。从性能开销上看：<strong>modules &lt; tracefs &lt; perf probe &lt; eBPF</strong>.</p><h1 id="tracefs-kprobe"><a href="#tracefs-kprobe" class="headerlink" title="tracefs-kprobe"></a>tracefs-kprobe</h1><hr><p>查看<a href="https://www.kernel.org/doc/html/latest/trace/kprobetrace.html">Kprobe-based Event Tracing</a>页面学习kprobes设置语法。按照<a href="http://localhost:4000/2025/09/16/kprobe%E4%BD%BF%E7%94%A8%EF%BC%9AC%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91/">内核模块</a>的配置，使用 tracefs 实现的过程如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">su -</span><br><span class="line">mount -t tracefs none /sys/kernel/tracing</span><br><span class="line"><span class="built_in">cd</span> /sys/kernel/tracing</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 alloc_bprm 是在kernel中</span></span><br><span class="line">grep alloc_bprm /proc/kallsyms</span><br><span class="line"><span class="comment"># ffffffff80282144 t alloc_bprm</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭 trace</span></span><br><span class="line"><span class="built_in">echo</span> 0 &gt;  tracing_on</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在函数alloc_bprm偏移0x3c处打印a0</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;p alloc_bprm+0x3c a0=%a0&#x27;</span> &gt; kprobe_events</span><br><span class="line"><span class="comment"># 或使用绝对地址</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;p 0xffffffff80282180 a0=%a0&#x27;</span> &gt; kprobe_events</span><br><span class="line"><span class="built_in">cat</span> kprobe_events</span><br><span class="line"><span class="comment"># p:kprobes/p_alloc_bprm_60 alloc_bprm+60 a0=%a0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使能设置的kprobe，若 p_alloc_bprm_60不存在，也许是其他目录，kprobe_events 中可以查看具体是什么目录</span></span><br><span class="line"><span class="built_in">echo</span> 1 &gt; events/kprobes/p_alloc_bprm_60/enable</span><br><span class="line"><span class="comment"># 上述使能信号设置后 events/kprobes/enable 也会自动设置</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使能 trace</span></span><br><span class="line"><span class="built_in">echo</span> 1 &gt;  tracing_on</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行命令行命令，触发kprobe</span></span><br><span class="line"><span class="built_in">uname</span> -r</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭 trace</span></span><br><span class="line"><span class="built_in">echo</span> 0 &gt;  tracing_on</span><br><span class="line"></span><br><span class="line"><span class="comment"># 清理探测点</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;-:kprobes/p_alloc_bprm_60&#x27;</span> &gt; kprobe_events</span><br><span class="line"></span><br><span class="line"><span class="comment"># 清理所有探测点</span></span><br><span class="line"><span class="built_in">echo</span> &gt; kprobe_events</span><br></pre></td></tr></table></figure><p>在添加探测点时虽然可以用 sym+off 的方式，但最简单的方式是直接使用绝对地址，因为这个地址可以直接从 vmlinux 的反汇编中得到，而且对应的指令也一目了然。</p><h1 id="perf-probe"><a href="#perf-probe" class="headerlink" title="perf probe"></a>perf probe</h1><hr><p>使用 perf 实现相同功能如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">su -</span><br><span class="line"><span class="comment"># 添加探测点, kallsyms中必须有调试信息，不然需要使用绝对地址</span></span><br><span class="line">/mnt/linux/tools/perf/perf probe -x  /proc/kallsyms --add  <span class="string">&#x27;alloc_bprm+0x3c a0=%a0&#x27;</span></span><br><span class="line"><span class="comment"># 或使用绝对地址+偏移:0xffffffff80282144 是 alloc_bprm 的绝对地址</span></span><br><span class="line">/mnt/linux/tools/perf/perf probe --add  <span class="string">&#x27;0xffffffff80282144+0x3c a0=%a0&#x27;</span></span><br><span class="line"><span class="comment"># 或使用完整地址</span></span><br><span class="line">/mnt/linux/tools/perf/perf probe --add  <span class="string">&#x27;0xffffffff80282180 a0=%a0&#x27;</span></span><br><span class="line"><span class="comment"># 或</span></span><br><span class="line">/mnt/linux/tools/perf/perf probe --add <span class="string">&#x27;kernel:alloc_bprm+0x3c a0=%a0&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出所有探测点</span></span><br><span class="line">/mnt/linux/tools/perf/perf probe -l</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行命令 uname -r, 触发探测点</span></span><br><span class="line">/mnt/linux/tools/perf/perf record -e probe:alloc_bprm -aR <span class="built_in">uname</span> -r</span><br><span class="line"><span class="comment"># 或 按照提示执行</span></span><br><span class="line">/mnt/linux/tools/perf/perf record -e probe:abs_ffffffff80282180 -aR <span class="built_in">uname</span> -r</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者实时显示</span></span><br><span class="line">/mnt/linux/tools/perf/perf trace -e probe:alloc_bprm</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 perf.data 中的结果</span></span><br><span class="line">/mnt/linux/tools/perf/perf script</span><br><span class="line"><span class="comment"># 报告：perf-exec     166 [004]   676.402643: probe:abs_ffffffff80282180: (ffffffff80282180) a0=0xffffffd602693400</span></span><br><span class="line"><span class="comment"># 从报告上看，a0值非零，已经分配好了空间</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者直接报告</span></span><br><span class="line">/mnt/linux/tools/perf/perf report -i perf.data</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除所有探针</span></span><br><span class="line">/mnt/linux/tools/perf/perf probe -d <span class="string">&#x27;*&#x27;</span></span><br></pre></td></tr></table></figure><h1 id="eBPF"><a href="#eBPF" class="headerlink" title="eBPF"></a>eBPF</h1><hr><p>linux&#x2F;tools&#x2F;bpf&#x2F;bpftool 下提供了<strong>管理调试工具</strong> bpftool, 可以<strong>检查、查询、管理已加载的 eBPF 程序和映射</strong>，而 bcc 开发工具包，用于<strong>编写、编译、加载、运行 eBPF 程序</strong>。</p><h2 id="bpftool"><a href="#bpftool" class="headerlink" title="bpftool"></a>bpftool</h2><ul><li><p>sudo bpftool prog list：<br>显示所有已经被load到系统里的eBPF程序的信息列表，除了显示功能外，还支持dump等功能，可以通过man bpftool prog来查看具体支持的功能。</p></li><li><p>bpftool net list<br>显示内核网络子系统里的eBPF程序，除了显示功能外，还支持其它功能，可以通过man bpftool net来查看具体支持的功能。</p></li><li><p>bpftool link list<br>显示所有激活的链接，除了显示功能外，还支持其它功能，可以通过man bpftool link来查看具体支持的功能。</p></li><li><p>bpftool perf list<br>显示系统里所有raw_tracepoint, tracepoint, kprobe attachments ，除了显示功能外，还支持其它功能，可以通过man bpftool perf来查看具体支持的功能。</p></li><li><p>bpftool btf list<br>显示所有BPF Type Format (BTF)数据 ，除了显示功能外，还支持其它功能，可以通过man bpftool btf来查看具体支持的功能。</p></li><li><p>bpftool map list<br>显示系统内已经载入的所有bpf map数据，除了显示功能外，还支持其它功能，可以通过man bpftool map来查看具体支持的功能。</p></li><li><p>bpftool feature probe dev eth0<br>查看eth0支持的eBPF特性 。</p></li></ul><p><a href="https://github.com/libbpf/bpftool/releases">bpftool</a></p><h2 id="bcc"><a href="#bcc" class="headerlink" title="bcc"></a>bcc</h2><p><a href="https://blog.cyru1s.com/posts/ebpf-bcc.html">ebpf &amp; bcc 中文教程及手册</a><br><a href="https://zhuanlan.zhihu.com/p/1920869693301981491">学习笔记-BCC</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> bcc <span class="keyword">import</span> BPF</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义 eBPF 程序</span></span><br><span class="line">bpf_text = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">#include &lt;uapi/linux/ptrace.h&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">int pre_handler(struct pt_regs *regs) &#123;    </span></span><br><span class="line"><span class="string">    bpf_trace_printk(&quot;Hit alloc_bprm+0x3c: a0 = 0x%lx\\n&quot;, regs-&gt;a0);</span></span><br><span class="line"><span class="string">    return 0;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载 BPF 程序</span></span><br><span class="line">b = BPF(text=bpf_text)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取 alloc_bprm 的地址</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment"># 从 /proc/kallsyms 读取符号地址</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;/proc/kallsyms&#x27;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">            <span class="keyword">if</span> <span class="string">&#x27;alloc_bprm&#x27;</span> <span class="keyword">in</span> line <span class="keyword">and</span> <span class="string">&#x27; t &#x27;</span> <span class="keyword">in</span> line:</span><br><span class="line">                parts = line.split()</span><br><span class="line">                alloc_bprm_addr = <span class="built_in">int</span>(parts[<span class="number">0</span>], <span class="number">16</span>)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;找不到 alloc_bprm 符号&quot;</span>)</span><br><span class="line">            exit(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;读取 /proc/kallsyms 失败: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line">    exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算目标地址, 如果有反汇编，可以直接得到目标地址不用从 /proc/kallsyms 中获取</span></span><br><span class="line">target_addr = alloc_bprm_addr + <span class="number">0x3c</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;alloc_bprm 地址: 0x<span class="subst">&#123;alloc_bprm_addr:x&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;目标地址: 0x<span class="subst">&#123;target_addr:x&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 附加 kprobe</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment"># 使用 attach_kprobe 并指定地址</span></span><br><span class="line">    b.attach_kprobe(</span><br><span class="line">        event=<span class="string">f&quot;0x<span class="subst">&#123;target_addr:x&#125;</span>&quot;</span>,  <span class="comment"># 使用十六进制格式的地址</span></span><br><span class="line">        fn_name=<span class="string">&quot;pre_handler&quot;</span>,</span><br><span class="line">        offset=<span class="number">0</span>  <span class="comment"># 从地址开始处附加</span></span><br><span class="line">    )</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;成功附加 kprobe&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;附加 kprobe 失败: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line">    exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印跟踪结果</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;开始跟踪，按 Ctrl-C 停止&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;%-18s %-16s %-6s %s&quot;</span> % (<span class="string">&quot;TIME(s)&quot;</span>, <span class="string">&quot;COMM&quot;</span>, <span class="string">&quot;PID&quot;</span>, <span class="string">&quot;MESSAGE&quot;</span>))</span><br><span class="line">b.trace_print()</span><br></pre></td></tr></table></figure><p>eBPF 适合对观测数据进行分析，但对于硅后定位来说，可能使用perf&#x2F;bpftool更适合，因为只需要观测cpu状态。</p><h2 id="bpftrace"><a href="#bpftrace" class="headerlink" title="bpftrace"></a>bpftrace</h2><hr><p>bpftrace 是一个基于 eBPF 的高级追踪语言和运行时，专为 Linux 设计，支持对内核和用户空间进行静态与动态追踪。其语法受 awk、C、DTrace 和 SystemTap 启发，目标是让开发者能用简洁的一行命令快速实现系统可观测性。</p><h3 id="1-列出所有可用的-tracepoint"><a href="#1-列出所有可用的-tracepoint" class="headerlink" title="1. 列出所有可用的 tracepoint"></a>1. 列出所有可用的 tracepoint</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bpftrace -l <span class="string">&#x27;tracepoint:*&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="2-追踪所有系统调用（按进程名）"><a href="#2-追踪所有系统调用（按进程名）" class="headerlink" title="2. 追踪所有系统调用（按进程名）"></a>2. 追踪所有系统调用（按进程名）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bpftrace -e <span class="string">&#x27;tracepoint:syscalls:sys_enter_* &#123; printf(&quot;%s %s\n&quot;, comm, probe); &#125;&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="3-监控-openat-系统调用的文件名"><a href="#3-监控-openat-系统调用的文件名" class="headerlink" title="3. 监控 openat 系统调用的文件名"></a>3. 监控 openat 系统调用的文件名</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bpftrace -e <span class="string">&#x27;tracepoint:syscalls:sys_enter_openat &#123; printf(&quot;%s %s\n&quot;, comm, str(args-&gt;filename)); &#125;&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="4-统计每秒发生的-write-系统调用次数"><a href="#4-统计每秒发生的-write-系统调用次数" class="headerlink" title="4. 统计每秒发生的 write 系统调用次数"></a>4. 统计每秒发生的 write 系统调用次数</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bpftrace -e <span class="string">&#x27;tracepoint:syscalls:sys_exit_write &#123; @ = count(); &#125; interval:s:1 &#123; print(@); clear(@); &#125;&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="5-追踪内核函数（如-do-sys-open）"><a href="#5-追踪内核函数（如-do-sys-open）" class="headerlink" title="5. 追踪内核函数（如 do_sys_open）"></a>5. 追踪内核函数（如 do_sys_open）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bpftrace -e <span class="string">&#x27;kprobe:do_sys_open &#123; printf(&quot;%s called do_sys_open\n&quot;, comm); &#125;&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="6-测量函数执行延迟（入口-出口）"><a href="#6-测量函数执行延迟（入口-出口）" class="headerlink" title="6. 测量函数执行延迟（入口+出口）"></a>6. 测量函数执行延迟（入口+出口）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">bpftrace -e <span class="string">&#x27;</span></span><br><span class="line"><span class="string">kprobe:vfs_read &#123; time[&quot;start&quot;] = nsecs; &#125;</span></span><br><span class="line"><span class="string">kretprobe:vfs_read /time[&quot;start&quot;]/ &#123;</span></span><br><span class="line"><span class="string">    printf(&quot;vfs_read took %dns\n&quot;, nsecs - time[&quot;start&quot;]);</span></span><br><span class="line"><span class="string">    delete(time[&quot;start&quot;]);</span></span><br><span class="line"><span class="string">&#125;&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="7-追踪用户程序函数（需符号表）"><a href="#7-追踪用户程序函数（需符号表）" class="headerlink" title="7. 追踪用户程序函数（需符号表）"></a>7. 追踪用户程序函数（需符号表）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 假设 /bin/bash 有 debuginfo</span></span><br><span class="line">bpftrace -e <span class="string">&#x27;uprobe:/bin/bash:main &#123; printf(&quot;bash main called by %s\n&quot;, comm); &#125;&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="8-按进程-ID-聚合系统调用次数"><a href="#8-按进程-ID-聚合系统调用次数" class="headerlink" title="8. 按进程 ID 聚合系统调用次数"></a>8. 按进程 ID 聚合系统调用次数</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bpftrace -e <span class="string">&#x27;tracepoint:syscalls:sys_enter_* &#123; @calls[pid, comm] = count(); &#125;&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="9-监控磁盘-I-O-延迟（使用-block-tracepoint）"><a href="#9-监控磁盘-I-O-延迟（使用-block-tracepoint）" class="headerlink" title="9. 监控磁盘 I&#x2F;O 延迟（使用 block tracepoint）"></a>9. 监控磁盘 I&#x2F;O 延迟（使用 block tracepoint）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">bpftrace -e <span class="string">&#x27;</span></span><br><span class="line"><span class="string">tracepoint:block:block_rq_issue &#123; start[args-&gt;dev, args-&gt;sector] = nsecs; &#125;</span></span><br><span class="line"><span class="string">tracepoint:block:block_rq_complete /start[args-&gt;dev, args-&gt;sector]/ &#123;</span></span><br><span class="line"><span class="string">    printf(&quot;IO latency: %d us\n&quot;, (nsecs - start[args-&gt;dev, args-&gt;sector]) / 1000);</span></span><br><span class="line"><span class="string">    delete(start[args-&gt;dev, args-&gt;sector]);</span></span><br><span class="line"><span class="string">&#125;&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="10-使用直方图统计-read-大小分布"><a href="#10-使用直方图统计-read-大小分布" class="headerlink" title="10. 使用直方图统计 read 大小分布"></a>10. 使用直方图统计 read 大小分布</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bpftrace -e <span class="string">&#x27;tracepoint:syscalls:sys_exit_read &#123; @ = hist(args-&gt;ret); &#125;&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="11-捕获栈回溯（当发生特定事件时）"><a href="#11-捕获栈回溯（当发生特定事件时）" class="headerlink" title="11. 捕获栈回溯（当发生特定事件时）"></a>11. 捕获栈回溯（当发生特定事件时）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bpftrace -e <span class="string">&#x27;kprobe:tcp_sendmsg &#123; printf(&quot;TCP send from:\n&quot;); print(ustack); &#125;&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="12-监控内存分配（slab-alloc）"><a href="#12-监控内存分配（slab-alloc）" class="headerlink" title="12. 监控内存分配（slab alloc）"></a>12. 监控内存分配（slab alloc）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bpftrace -e <span class="string">&#x27;tracepoint:kmem:kmalloc &#123; @bytes = sum(args-&gt;bytes_alloc); &#125;&#x27;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> kprobe </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> kprobe </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kprobe使用：内核模块加载</title>
      <link href="/2025/09/16/kprobe%E4%BD%BF%E7%94%A8%EF%BC%9A%E6%A8%A1%E5%9D%97%E5%8A%A0%E8%BD%BD%E6%96%B9%E5%BC%8F/"/>
      <url>/2025/09/16/kprobe%E4%BD%BF%E7%94%A8%EF%BC%9A%E6%A8%A1%E5%9D%97%E5%8A%A0%E8%BD%BD%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="Kprobes-解决了什么问题"><a href="#Kprobes-解决了什么问题" class="headerlink" title="Kprobes 解决了什么问题"></a>Kprobes 解决了什么问题</h1><hr><p>在 Linux Kernel 中需要 debug，需要知道内核函数变量的值，比较简单的做法是在内核代码对应的函数中插入 log 信息，但这种方式往往需要重新编译内核，然后启动设备，这往往比较繁琐而且改变内核运行过程。</p><p>而利用 Kprobes (Kernel Probes) 这种动态探测技术，可以弥补上述缺点。用户可以自定义 Kprobes 的回调函数，然后指定探测点，当 Kernel 执行到探测点，在回调函数中获取 CPU 寄存器的值，同时内核返回原来的执行流程。</p><p>Kprobes 技术提供了探测点的调用前、调用后和内存访问出错 3 种回调方式，分别是：</p><ul><li>pre_handler</li><li>post_handler</li><li>fault_handler</li></ul><p>其中 pre_handler 是执行到探测点前的回调函数，post_handler 是在执行到探测点后的回调函数，fault_handler 会在内存访问出错时的回调函数。</p><h1 id="环境依赖"><a href="#环境依赖" class="headerlink" title="环境依赖"></a>环境依赖</h1><hr><ul><li>linux-6.17-rc5 源码</li><li>已经建好的ubuntu-base 文件系统(见之前的文章)</li></ul><p><strong>编译源码和示例</strong>：最好在chroot下进行，一是方便安装软件，二是运行更快，三是qemu中可能存在各种问题。</p><ol><li>挂载ubuntu-base 文件系统：<code>sudo mount -o loop ubuntu_base.img ./rootfs</code></li><li>挂载 wsl 下的 linux 源码到 &#x2F;mnt&#x2F;linux: <code>sudo mount --bind linux ./rootfs/mnt/linux</code></li><li>chroot ubuntu-base 文件系统: <code>sudo chroot ./rootfs</code></li><li>挂载各子系统：在 chroot 环境下：<code>/start.sh</code>，文件具体如下：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">mount -t proc none /proc</span><br><span class="line">mount -t sysfs none /sys</span><br><span class="line">mount -t devtmpfs none /dev</span><br><span class="line"><span class="built_in">mkdir</span> -p /dev/pts</span><br><span class="line">mount -t devpts devpts /dev/pts</span><br><span class="line">dhclient &amp;</span><br><span class="line">mount -t 9p -o trans=virtio hostshare /mnt</span><br><span class="line">mount -t tracefs none /sys/kernel/tracing</span><br></pre></td></tr></table></figure><h1 id="探测-sys-exec-中的-bprm-变量值"><a href="#探测-sys-exec-中的-bprm-变量值" class="headerlink" title="探测 sys_exec 中的 bprm 变量值"></a>探测 sys_exec 中的 bprm 变量值</h1><hr><p><a href="https://tinylab.org/linux-kprobes/">一文解读 Linux Kprobes 好处、用法和工作原理</a></p><p>Linux 运行每一个可执行文件都会调用 sys_exec，通过这个系统调用陷入内核态，然后执行 do_execveat_common (Linux 4.4 版本，其他版本未验证）加载可执行新文件，其实现位于 <code>fs/exec.c</code>.</p><p>在参考文献中，作者使用<code>if (!bprm)</code>作为<code>kprobe</code>的对象, 当 PC 运行到此处时，会触发<code>pre_handler</code>。这里使用 linux v6.17-rc5 的源码，在<code>fs/exec.c</code>中，对等的函数变为<code>alloc_bprm</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">bprm = kzalloc(<span class="keyword">sizeof</span>(*bprm), GFP_KERNEL); <span class="comment">// line 1414</span></span><br><span class="line"><span class="keyword">if</span> (!bprm) &#123;                               <span class="comment">// line 1415</span></span><br><span class="line">       do_close_execat(file);                 <span class="comment">// line 1416</span></span><br><span class="line">       <span class="keyword">return</span> ERR_PTR(-ENOMEM);               <span class="comment">// line 1417</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bprm-&gt;file = file;                         <span class="comment">// line 1420</span></span><br></pre></td></tr></table></figure><p>查看system.map文件，找到<code>ffffffff80282144 t alloc_bprm</code>, 进而找到汇编后的代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ffffffff80282144 &lt;alloc_bprm&gt;:</span><br><span class="line">alloc_bprm():</span><br><span class="line">/mnt/linux/fs/exec.c:1405</span><br><span class="line">ffffffff80282144:7139                addisp,sp,-64</span><br><span class="line">...</span><br><span class="line">ffffffff8028217e:84aa                mvs1,a0</span><br><span class="line">alloc_bprm():</span><br><span class="line">/mnt/linux/fs/exec.c:1415</span><br><span class="line">ffffffff80282180:18050163          beqza0,ffffffff80282302 &lt;alloc_bprm+0x1be&gt;</span><br><span class="line">/mnt/linux/fs/exec.c:1420</span><br><span class="line">ffffffff80282184:05253023          sds2,64(a0)</span><br><span class="line">/mnt/linux/fs/exec.c:1422</span><br><span class="line">ffffffff80282188:f9c00793          lia5,-100</span><br></pre></td></tr></table></figure><p>关键就是<code>ffffffff80282180 beqza0,ffffffff80282302 &lt;alloc_bprm+0x1be&gt;</code>这一句, <code>ffffffff80282302</code> 地址是<code>do_close_execat()</code>函数的起始地址。可见<code>a0</code>就是<code>bprm</code>的值。因此，kprobe探测点为<code>ffffffff80282180</code>处的指令<code>18050163</code>，我们需要在此处打印一些有用信息。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">kprobe</span> <span class="title">kp</span> =</span> &#123;</span><br><span class="line">.symbol_name= <span class="string">&quot;alloc_bprm&quot;</span>,</span><br><span class="line">.offset = <span class="number">0x3c</span>, <span class="comment">//  echo &quot;obase=16;$((0x80282180 - 0x80282144))&quot;|bc</span></span><br><span class="line">    .pre_handler = handler_pre，</span><br><span class="line">    .post_handler = handler_post，</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在 linux&#x2F;samples&#x2F;kprobes 下已经demo示例，简单修改上述 kprobe 探测点即可，在 pre_handler 中已经有打印信息，只需添加 <code>a0</code> 的打印信息。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pr_info(<span class="string">&quot;&lt;%s&gt; p-&gt;addr = 0x%p, pc = 0x%lx, status = 0x%lx, a0 = 0x%lx\n&quot;</span>,</span><br><span class="line">p-&gt;symbol_name, p-&gt;addr, regs-&gt;epc, regs-&gt;status， regs-&gt;a0);</span><br></pre></td></tr></table></figure><p>另外，需要修改Makefile</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj-m += kprobe_example.o</span><br></pre></td></tr></table></figure><h1 id="编译-kprobe-示例代码"><a href="#编译-kprobe-示例代码" class="headerlink" title="编译 kprobe 示例代码"></a>编译 kprobe 示例代码</h1><hr><p>假设已经在chroot环境中编译了内核 6.17-rc5 (挂载到了 &#x2F;mnt&#x2F;linux), 并且已经按照上述要求修改了kprobe_example.c 文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /mnt/linux/samples/kprobes/</span><br><span class="line">make -C ../.. M=$(<span class="built_in">pwd</span>) modules</span><br><span class="line"><span class="comment"># 或，在linux根目录时</span></span><br><span class="line">make M=samples/kprobes modules</span><br><span class="line"><span class="built_in">exit</span>  <span class="comment"># 退出 chroot</span></span><br><span class="line"><span class="built_in">sudo</span> umount -l rootfs/mnt <span class="comment"># 卸载 linux 源码</span></span><br><span class="line"><span class="built_in">sudo</span> umount -l rootfs     <span class="comment"># 卸载 ubuntu base 文件系统</span></span><br></pre></td></tr></table></figure><p>现在已经生成了 <code>kprobe_example.ko</code>。</p><h1 id="qemu-加载-kprobe"><a href="#qemu-加载-kprobe" class="headerlink" title="qemu 加载 kprobe"></a>qemu 加载 kprobe</h1><hr><p>由于 chroot 环境使用的是主机的系统，所以测试需要到 qemu 进行。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qemu-system-riscv64 -smp 8 -cpu rva23s64 -M virt -m 512M -nographic -kernel /mnt/d/wsl/share/ubuntu/Image -drive file=/mnt/d/wsl/share/ubuntu/ubuntu_base.img,format=raw,<span class="built_in">id</span>=hd0,<span class="keyword">if</span>=none -device virtio-blk-device,drive=hd0 -append <span class="string">&quot;root=/dev/vda rw console=ttyS0 init=/bin/bash&quot;</span> -fsdev <span class="built_in">local</span>,security_model=mapped-xattr,<span class="built_in">id</span>=fsdev0,path=/home/xxx/wks/tools -device virtio-9p-pci,<span class="built_in">id</span>=fs0,fsdev=fsdev0,mount_tag=hostshare -device virtio-net-device,netdev=net0 -netdev user,<span class="built_in">id</span>=net0</span><br></pre></td></tr></table></figure><p>进入 os 后，先执行 <code>/start.sh</code> 挂载 proc, sys, dev 等。然后加载 kprobe_example.ko 驱动。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/start.sh</span><br><span class="line">insmod kprobe_example.ko</span><br><span class="line"><span class="comment"># [  848.177529] kprobe_example: loading out-of-tree module taints kernel.</span></span><br><span class="line"><span class="comment"># [  848.530845] kprobe_init: Planted kprobe at 00000000a417bfe6</span></span><br><span class="line"><span class="comment"># 注册驱动后，在命令行输入命令，就会触发kprobe调用，如下</span></span><br><span class="line"><span class="built_in">uname</span> -r</span><br><span class="line"><span class="comment"># [ 1018.088978] handler_pre: &lt;alloc_bprm&gt; p-&gt;addr = 0x00000000a417bfe6, pc = 0xffffffff80282180, status = 0x200000120, a0 = 0xffffffd60266d800</span></span><br><span class="line"><span class="comment"># [ 1018.090076] handler_post: &lt;alloc_bprm&gt; p-&gt;addr = 0x00000000a417bfe6, status = 0x200000120</span></span><br><span class="line"><span class="comment"># 6.17.0-rc5-dirty</span></span><br><span class="line">rmmod kprobe_example.ko <span class="comment"># 移除 kprobe</span></span><br></pre></td></tr></table></figure><p>输入<code>uname -r</code>后先打印了 handler_pre 中的log信息，即执行被探测指令前的信息，a0 不为 0 (实际为 kzalloc 分配的堆空间地址)，跳转并执行 <code>do_close_execat(file);</code>，第行打印 handler_post 的log信息，由于 a0 在执行前后并未改变，所以 handler_post 没有更多有用信息，这里只是展示其使用方式，并未打印 a0. 第三行是<code>uname -r</code>的真正输出，是系统版本号。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><hr><p>内核模块加载方式依赖于源码和相关头文件，因此相对来说比较麻烦，但<strong>性能开销</strong>是最小的，在硅后验证中，可以长期运行，来复现问题。</p>]]></content>
      
      
      <categories>
          
          <category> kprobe </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> kprobe </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>制作 ubuntu-base 文件系统</title>
      <link href="/2025/09/05/%E5%88%B6%E4%BD%9C-ubuntu-base-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
      <url>/2025/09/05/%E5%88%B6%E4%BD%9C-ubuntu-base-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><hr><p><a href="https://www.cnblogs.com/phoebus-ma/p/17436089.html">https://www.cnblogs.com/phoebus-ma/p/17436089.html</a><br><a href="https://cloud.tencent.com/developer/article/2565632">https://cloud.tencent.com/developer/article/2565632</a><br><a href="https://blog.csdn.net/jingyu_1/article/details/135822574">https://blog.csdn.net/jingyu_1/article/details/135822574</a></p><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><hr><p>为了学习 Linux kernel，在 qemu 模拟时通过加载源码编译的 kernel 来启动 os. 而文件系统采用 busybox。这样的好处是 kernel 可以自由控制编译选项。坏处是无法安装软件。网上搜索了一下，没有相关方法，于是转而采用 Ubuntu 来制作文件系统，并支持联网，注意，这里不是带 kernel 的发行版，而是干净的文件系统。</p><p>通过检索制作方法，搜集到了2种方式：</p><ul><li>使用 debootstrap 制作，该方法能制作一个比较完整的 ubuntu 文件系统，特点是简单、臃肿。弃用。</li><li>使用 ubuntu base 制作，这是一个最小 ubuntu 文件系统，由官方发布。采用。</li></ul><h1 id="环境和目标"><a href="#环境和目标" class="headerlink" title="环境和目标"></a>环境和目标</h1><hr><ul><li>环境：x86 wsl ubuntu</li><li>目标：在 wsl 环境上通过 qemu 来加载文件系统并运行自定义 riscv 内核，方便调试、研究。</li></ul><h1 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h1><hr><h2 id="Qemu-和-Linux"><a href="#Qemu-和-Linux" class="headerlink" title="Qemu 和 Linux"></a>Qemu 和 Linux</h2><hr><p>参考<a href="https://zhuanlan.zhihu.com/p/258394849">在 QEMU 上运行 RISC-V 64 位版本的 Linux</a>。</p><h2 id="ubuntu-base-根文件系统"><a href="#ubuntu-base-根文件系统" class="headerlink" title="ubuntu-base 根文件系统"></a>ubuntu-base 根文件系统</h2><hr><ul><li>官方的文件系统包<a href="https://cdimage.ubuntu.com/ubuntu-base/releases/24.04.3/release/ubuntu-base-24.04.3-base-riscv64.tar.gz">ubuntu-base-24.04.3-base-riscv64.tar.gz</a></li></ul><p>这个包可以理解为安装的 busybox _install 目录。在制作 busybox 文件系统时，直接替换 _install 目录即可。但是这样的文件系统还是不支持网络。</p><ul><li>软件安装</li></ul><p>在 x86 wsl ubuntu 上安装如下软件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install -y qemu-user-static</span><br></pre></td></tr></table></figure><p>安装这个软件后会在 wsl ubuntu 的 &#x2F;usr&#x2F;bin 目录下生成 qemu-riscv64-static 命令，这个命令可以在 x86 架构下运行 riscv64 架构的二进制文件。</p><ul><li>创建磁盘</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">qemu-img create ubuntu_base.img 4g <span class="comment"># 4GB 空间</span></span><br><span class="line">mkfs.ext4 ubuntu_base.img</span><br></pre></td></tr></table></figure><ul><li>挂载磁盘</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p ./rootfs</span><br><span class="line">mount -o loop ubuntu_base.img ./rootfs</span><br></pre></td></tr></table></figure><ul><li>构建文件系统</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">tar xzf ubuntu-base-24.04.3-base-riscv64.tar.gz -C ./rootfs</span><br><span class="line"><span class="built_in">cd</span> linux &amp;&amp; <span class="built_in">sudo</span> CROSS_COMPILE=riscv64-unknown-linux-gnu- ARCH=riscv make modules_install INSTALL_MOD_PATH=../rootfs/</span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">cp</span> /usr/bin/qemu-riscv64-static ./rootfs/usr/bin/ <span class="comment"># riscv64 架构下的命令都是通过qemu转译成 x86 的命令被执行的</span></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">cp</span> /etc/resolv.conf ./rootfs/etc/resolv.conf <span class="comment"># 针对 riscv64 环境提供 wsl 网络</span></span><br><span class="line"><span class="comment"># https://mirror.tuna.tsinghua.edu.cn/help/ubuntu-ports/,  注意，这个 ubuntu ports 源才是正确的</span></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">echo</span> <span class="string">&quot;deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ noble main restricted universe multiverse</span></span><br><span class="line"><span class="string">deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ noble main restricted universe multiverse</span></span><br><span class="line"><span class="string">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ noble-updates main restricted universe multiverse</span></span><br><span class="line"><span class="string">deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ noble-updates main restricted universe multiverse</span></span><br><span class="line"><span class="string">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ noble-backports main restricted universe multiverse</span></span><br><span class="line"><span class="string">deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ noble-backports main restricted universe multiverse</span></span><br><span class="line"><span class="string">deb http://ports.ubuntu.com/ubuntu-ports/ noble-security main restricted universe multiverse</span></span><br><span class="line"><span class="string">deb-src http://ports.ubuntu.com/ubuntu-ports/ noble-security main restricted universe multiverse&quot;</span> &gt; ./rootfs/etc/apt/sources.list</span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">chmod</span> 1777 /tmp  <span class="comment"># 属性不对，apt update 报错</span></span><br><span class="line"><span class="comment"># 当二次挂载文件系统，安装其他工具时，只需从以下步骤开始执行即可</span></span><br><span class="line"><span class="built_in">sudo</span> mount -t proc /proc ./rootfs/proc</span><br><span class="line"><span class="built_in">sudo</span> mount -t sysfs /sys ./rootfs/sys</span><br><span class="line"><span class="built_in">sudo</span> mount -o <span class="built_in">bind</span> /dev ./rootfs/dev</span><br><span class="line"><span class="built_in">sudo</span> mount -o <span class="built_in">bind</span> /dev/pts ./rootfs/dev/pts</span><br><span class="line"><span class="built_in">sudo</span> mount --<span class="built_in">bind</span> linux ./rootfs/mnt/ <span class="comment"># 目的是在 chroot 下直接编译安装perf工具（主要是和kernel源码匹配）</span></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">chroot</span> ./rootfs <span class="comment"># 这个步骤非常重要</span></span><br></pre></td></tr></table></figure><p><code>chroot</code> 执行后就像是切换到 riscv64 架构环境了，后续执行的所有命令都是基于 riscv64 架构的。当前还是 wsl 下，但是却像是 x86 架构换成了 riscv64 架构，并且根目录变成了.&#x2F;rootfs, 后续的软件安装都是安装在这里。</p><ul><li>riscv64 网络工具安装</li></ul><p>由于 ubuntu base 包里面没有网络工具，所以需要安装。这里 wsl riscv4 下使用的是 wsl 的网络。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt update</span><br><span class="line"><span class="comment"># 安装网络工具包</span></span><br><span class="line"><span class="built_in">sudo</span> apt install -y \</span><br><span class="line">    net-tools   \    <span class="comment"># ifconfig, netstat</span></span><br><span class="line">    isc-dhcp-client \  <span class="comment"># dhcp 客户端</span></span><br><span class="line">    iputils-ping \   <span class="comment"># ping</span></span><br><span class="line">    ifupdown</span><br></pre></td></tr></table></figure><ul><li>配置</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">chsh -s /bin/bash root</span><br><span class="line"><span class="comment"># 启动后使用 dhclient 自动联网，不需要其他配置</span></span><br><span class="line"><span class="comment"># tee /etc/network/interfaces &lt;&lt; EOF</span></span><br><span class="line"><span class="comment"># auto lo</span></span><br><span class="line"><span class="comment"># iface lo inet loopback</span></span><br><span class="line"><span class="comment"># auto eth0</span></span><br><span class="line"><span class="comment"># iface eth0 inet dhcp</span></span><br><span class="line"><span class="comment"># EOF</span></span><br><span class="line"></span><br><span class="line">* 卸载</span><br><span class="line"></span><br><span class="line">```bash</span><br><span class="line"><span class="built_in">exit</span> <span class="comment"># 由于当前还在 chroot 状态，所以需要先退出</span></span><br><span class="line"><span class="built_in">sudo</span> umount rootfs/proc rootfs/sys rootfs/dev/pts rootfs/dev rootfs</span><br></pre></td></tr></table></figure><p>至此，文件系统已经制作完毕，并且附带网络配置工具。</p><h2 id="启用-qemu-仿真"><a href="#启用-qemu-仿真" class="headerlink" title="启用 qemu 仿真"></a>启用 qemu 仿真</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># x86 wsl ubuntu</span></span><br><span class="line">qemu-system-riscv64 -smp 2 -cpu max -M virt -m 512M -nographic \</span><br><span class="line">-kernel linux/arch/riscv/boot/Image \</span><br><span class="line">-bios opensbi/build/platform/generic/firmware/fw_jump.bin \</span><br><span class="line">-drive file=ubuntu_base.img,format=raw,<span class="built_in">id</span>=hd0,<span class="keyword">if</span>=none \     <span class="comment">#制作的文件系统</span></span><br><span class="line">-device virtio-blk-device,drive=hd0 \</span><br><span class="line">-append <span class="string">&quot;root=/dev/vda rw console=ttyS0 init=/bin/bash ip=dhcp&quot;</span> \  <span class="comment"># dhcp 获取 ip, 以 bash 启动</span></span><br><span class="line">-fsdev <span class="built_in">local</span>,security_model=mapped-xattr,<span class="built_in">id</span>=fsdev0,path=./share \  <span class="comment"># 共享目录, 假设host下已有</span></span><br><span class="line">-device virtio-9p-pci,<span class="built_in">id</span>=fs0,fsdev=fsdev0,mount_tag=hostshare \</span><br><span class="line">-device virtio-net-device,netdev=net0 -netdev user,<span class="built_in">id</span>=net0 \ <span class="comment"># 启动网卡</span></span><br></pre></td></tr></table></figure><p>进入客户机后需要挂载 proc 和 sys 文件系统。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">bash</span><br><span class="line">mount -t proc none /proc</span><br><span class="line">mount -t sysfs none /sys</span><br><span class="line"><span class="built_in">mkdir</span> -p /dev/pts</span><br><span class="line">mount -t devpts none /dev/pts</span><br><span class="line"><span class="comment"># 挂载共享目录</span></span><br><span class="line"><span class="built_in">mkdir</span> -p /mnt/share</span><br><span class="line">mount -t 9p -o trans=virtio hostshare /mnt/share</span><br><span class="line"><span class="comment"># mount -t 9p -o trans=virtio,version=9p2000.L hostshare /mnt/share # 备选</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;nameserver 10.0.2.3&#x27;</span> &gt; /etc/resolv.conf <span class="comment"># 这是qemu的默认NDS</span></span><br><span class="line">dhclient <span class="comment"># 自动联网</span></span><br></pre></td></tr></table></figure><h2 id="网络配置（以下是参考，但未使用）"><a href="#网络配置（以下是参考，但未使用）" class="headerlink" title="网络配置（以下是参考，但未使用）"></a>网络配置（以下是参考，但未使用）</h2><ul><li>方案一(Ubuntu 默认方案，未尝试)</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装 netplan</span></span><br><span class="line"><span class="built_in">sudo</span> apt update</span><br><span class="line"><span class="built_in">sudo</span> apt install -y netplan.io</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建配置文件</span></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">tee</span> /etc/netplan/01-network.yaml &lt;&lt; <span class="string">EOF</span></span><br><span class="line"><span class="string">network:</span></span><br><span class="line"><span class="string">  version: 2</span></span><br><span class="line"><span class="string">  renderer: networkd</span></span><br><span class="line"><span class="string">  ethernets:</span></span><br><span class="line"><span class="string">    eth0:</span></span><br><span class="line"><span class="string">      dhcp4: true</span></span><br><span class="line"><span class="string">      # 静态IP配置示例:</span></span><br><span class="line"><span class="string">      # addresses:</span></span><br><span class="line"><span class="string">      #   - 192.168.1.100/24</span></span><br><span class="line"><span class="string">      # routes:</span></span><br><span class="line"><span class="string">      #   - to: default</span></span><br><span class="line"><span class="string">      #     via: 192.168.1.1</span></span><br><span class="line"><span class="string">      # nameservers:</span></span><br><span class="line"><span class="string">      #   addresses: [8.8.8.8, 1.1.1.1]</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 应用配置</span></span><br><span class="line"><span class="built_in">sudo</span> netplan generate</span><br><span class="line"><span class="built_in">sudo</span> netplan apply</span><br></pre></td></tr></table></figure><ul><li>方案二（可用）</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装必要工具</span></span><br><span class="line"><span class="comment"># 目前还没有网络，需要提前安装</span></span><br><span class="line"><span class="comment"># sudo apt update</span></span><br><span class="line"><span class="comment"># sudo apt install -y iproute2 ifupdown isc-dhcp-client</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建网络接口配置</span></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">tee</span> /etc/network/interfaces &lt;&lt; <span class="string">EOF</span></span><br><span class="line"><span class="string"># 环回接口</span></span><br><span class="line"><span class="string">auto lo</span></span><br><span class="line"><span class="string">iface lo inet loopback</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 主网络接口 - 使用 DHCP</span></span><br><span class="line"><span class="string">auto eth0</span></span><br><span class="line"><span class="string">iface eth0 inet dhcp</span></span><br><span class="line"><span class="string">    dns-nameservers 8.8.8.8 1.1.1.1</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 如果需要静态IP</span></span><br><span class="line"><span class="string"># iface eth0 inet static</span></span><br><span class="line"><span class="string">#   address 192.168.1.100/24</span></span><br><span class="line"><span class="string">#   gateway 192.168.1.1</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 启用服务</span></span><br><span class="line"><span class="built_in">sudo</span> systemctl <span class="built_in">enable</span> networking</span><br><span class="line"><span class="built_in">sudo</span> systemctl start networking</span><br><span class="line"></span><br><span class="line"><span class="comment"># 手动启动接口</span></span><br><span class="line"><span class="comment"># ip link show 可以查看是否有 eth0</span></span><br><span class="line"><span class="comment"># 编译 kernel 源码时，需要打开网络</span></span><br><span class="line"><span class="built_in">sudo</span> ifup eth0</span><br></pre></td></tr></table></figure><ul><li>方案三(现代方案, 未尝试)</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装 systemd-networkd (通常已包含在基础系统中)</span></span><br><span class="line"><span class="built_in">sudo</span> apt install -y systemd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建网络配置</span></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">tee</span> /etc/systemd/network/20-wired.network &lt;&lt; <span class="string">EOF</span></span><br><span class="line"><span class="string">[Match]</span></span><br><span class="line"><span class="string">Name=eth0</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[Network]</span></span><br><span class="line"><span class="string">DHCP=ipv4</span></span><br><span class="line"><span class="string"># 静态IP配置示例</span></span><br><span class="line"><span class="string"># Address=192.168.1.100/24</span></span><br><span class="line"><span class="string"># Gateway=192.168.1.1</span></span><br><span class="line"><span class="string"># DNS=8.8.8.8</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置DNS解析</span></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">tee</span> /etc/resolv.conf &lt;&lt; <span class="string">EOF</span></span><br><span class="line"><span class="string">nameserver 8.8.8.8</span></span><br><span class="line"><span class="string">nameserver 1.1.1.1</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 启用并启动服务</span></span><br><span class="line"><span class="built_in">sudo</span> systemctl <span class="built_in">enable</span> systemd-networkd</span><br><span class="line"><span class="built_in">sudo</span> systemctl start systemd-networkd</span><br></pre></td></tr></table></figure><ul><li>DNS 配置</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装基础工具</span></span><br><span class="line"><span class="built_in">sudo</span> apt install -y dnsutils</span><br><span class="line"></span><br><span class="line"><span class="comment"># 手动配置 DNS</span></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">tee</span> /etc/resolv.conf &lt;&lt; <span class="string">EOF</span></span><br><span class="line"><span class="string">nameserver 8.8.8.8</span></span><br><span class="line"><span class="string">nameserver 1.1.1.1</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 防止配置被覆盖</span></span><br><span class="line"><span class="built_in">sudo</span> chattr +i /etc/resolv.conf</span><br></pre></td></tr></table></figure><ul><li>配置静态 IP（未尝试）</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ifconfig eth0 10.0.2.15</span><br><span class="line">route add default gw 10.0.2.2</span><br><span class="line"><span class="comment"># 或</span></span><br><span class="line"><span class="comment"># 为 eth0 添加 IP 地址 10.0.2.15，子网掩码为 24 位 (即 255.255.255.0)</span></span><br><span class="line"><span class="built_in">sudo</span> ip addr add 10.0.2.15/24 dev eth0</span><br><span class="line"><span class="comment"># 验证配置</span></span><br><span class="line">ip addr show dev eth0</span><br><span class="line"><span class="comment"># 添加默认路由，网关为 10.0.2.2，出站设备为 eth0</span></span><br><span class="line"><span class="built_in">sudo</span> ip route add default via 10.0.2.2 dev eth0</span><br><span class="line"><span class="comment"># 验证路由</span></span><br><span class="line">ip route show</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>制作可以访问网络的文件系统，关键是通过 <code>chroot</code> 安装各种网络工具。</p>]]></content>
      
      
      <categories>
          
          <category> rootfs </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> rootfs </tag>
            
            <tag> ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux Perf 介绍 —— Perf 示例</title>
      <link href="/2025/08/28/Linux-Perf-%E4%BB%8B%E7%BB%8D-%E2%80%94%E2%80%94-Perf-%E7%A4%BA%E4%BE%8B/"/>
      <url>/2025/08/28/Linux-Perf-%E4%BB%8B%E7%BB%8D-%E2%80%94%E2%80%94-Perf-%E7%A4%BA%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="示例说明"><a href="#示例说明" class="headerlink" title="示例说明"></a>示例说明</h1><hr><p>后续示例完全按照<a href="https://www.brendangregg.com/perf.html">perf 示例</a>执行一遍。</p><p>Perf Linux 性能分析器也被称作 Performance Counters for Linux (PCL)、Linux perf events (LPE) 或 perf_events。后续用 perf_events 描述。</p><h1 id="Perf-events-功能"><a href="#Perf-events-功能" class="headerlink" title="Perf_events 功能"></a>Perf_events 功能</h1><hr><p>perf_events 是一个事件导向的可观测性工具，可以帮助你解决高级性能和故障排除问题。可以回答的问题包括：</p><ul><li>Why is the kernel on-CPU so much? What code-paths? 内核在 CPU 上花费的时间为什么这么多？哪些代码路径？</li><li>Which code-paths are causing CPU level 2 cache misses? 哪些代码路径导致了 CPU 二级缓存缺失？</li><li>Are the CPUs stalled on memory I&#x2F;O? CPU 在进行内存 I&#x2F;O 操作吗？</li><li>Which code-paths are allocating memory, and how much? 哪些代码路径在分配内存，分配了多少？</li><li>What is triggering TCP retransmits? 是什么触发了 TCP 重传？</li><li>Is a certain kernel function being called, and how often? 某个内核函数是否被调用，以及调用的频率是多少？</li><li>What reasons are threads leaving the CPU? 线程离开 CPU 的原因是什么？</li></ul><h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><p>示例在root下执行。</p><h2 id="1-Screenshot"><a href="#1-Screenshot" class="headerlink" title="1. Screenshot"></a>1. Screenshot</h2><hr><p>这是perf跟踪磁盘I&#x2F;O的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"># perf record -e block:block_rq_issue -ag</span><br><span class="line">^C</span><br><span class="line">[ perf record: Woken up 1 times to write data ]</span><br><span class="line">[ perf record: Captured and wrote 0.022 MB perf.data ]</span><br><span class="line"># perf report</span><br><span class="line">Samples: 4  of event &#x27;block:block_rq_issue&#x27;, Event count (approx.): 4</span><br><span class="line">  Children      Self  Command          Shared Object      Symbol</span><br><span class="line">+   75.00%    75.00%  kworker/0:1H-kb  [kernel.kallsyms]  [k] __traceiter_block_rq_issue</span><br><span class="line">+   75.00%     0.00%  kworker/0:1H-kb  [kernel.kallsyms]  [k] ret_from_fork</span><br><span class="line">+   75.00%     0.00%  kworker/0:1H-kb  [kernel.kallsyms]  [k] kthread</span><br><span class="line">+   75.00%     0.00%  kworker/0:1H-kb  [kernel.kallsyms]  [k] worker_thread</span><br><span class="line">+   75.00%     0.00%  kworker/0:1H-kb  [kernel.kallsyms]  [k] process_one_work</span><br><span class="line">+   75.00%     0.00%  kworker/0:1H-kb  [kernel.kallsyms]  [k] blk_mq_requeue_work</span><br><span class="line">+   75.00%     0.00%  kworker/0:1H-kb  [kernel.kallsyms]  [k] blk_mq_run_hw_queues</span><br><span class="line">+   75.00%     0.00%  kworker/0:1H-kb  [kernel.kallsyms]  [k] blk_mq_run_hw_queue</span><br><span class="line">+   75.00%     0.00%  kworker/0:1H-kb  [kernel.kallsyms]  [k] blk_mq_sched_dispatch_requests</span><br><span class="line">+   75.00%     0.00%  kworker/0:1H-kb  [kernel.kallsyms]  [k] __blk_mq_sched_dispatch_requests</span><br><span class="line">+   75.00%     0.00%  kworker/0:1H-kb  [kernel.kallsyms]  [k] blk_mq_dispatch_rq_list</span><br><span class="line">+   75.00%     0.00%  kworker/0:1H-kb  [kernel.kallsyms]  [k] virtio_queue_rq</span><br><span class="line">+   75.00%     0.00%  kworker/0:1H-kb  [kernel.kallsyms]  [k] virtblk_prep_rq.isra.0</span><br><span class="line">+   75.00%     0.00%  kworker/0:1H-kb  [kernel.kallsyms]  [k] blk_mq_start_request</span><br><span class="line">+   25.00%    25.00%  jbd2/vda-8       [kernel.kallsyms]  [k] __traceiter_block_rq_issue</span><br><span class="line">+   25.00%     0.00%  jbd2/vda-8       [kernel.kallsyms]  [k] ret_from_fork</span><br><span class="line">+   25.00%     0.00%  jbd2/vda-8       [kernel.kallsyms]  [k] kthread</span><br><span class="line">+   25.00%     0.00%  jbd2/vda-8       [kernel.kallsyms]  [k] kjournald2</span><br><span class="line">+   25.00%     0.00%  jbd2/vda-8       [kernel.kallsyms]  [k] jbd2_journal_commit_transaction</span><br><span class="line">+   25.00%     0.00%  jbd2/vda-8       [kernel.kallsyms]  [k] blk_finish_plug</span><br><span class="line">+   25.00%     0.00%  jbd2/vda-8       [kernel.kallsyms]  [k] __blk_flush_plug</span><br><span class="line">+   25.00%     0.00%  jbd2/vda-8       [kernel.kallsyms]  [k] blk_mq_flush_plug_list</span><br><span class="line">+   25.00%     0.00%  jbd2/vda-8       [kernel.kallsyms]  [k] blk_mq_flush_plug_list.part.0</span><br><span class="line">+   25.00%     0.00%  jbd2/vda-8       [kernel.kallsyms]  [k] blk_mq_run_hw_queue</span><br><span class="line">+   25.00%     0.00%  jbd2/vda-8       [kernel.kallsyms]  [k] blk_mq_sched_dispatch_requests</span><br><span class="line">+   25.00%     0.00%  jbd2/vda-8       [kernel.kallsyms]  [k] __blk_mq_sched_dispatch_requests</span><br><span class="line">+   25.00%     0.00%  jbd2/vda-8       [kernel.kallsyms]  [k] blk_mq_dispatch_rq_list</span><br><span class="line">+   25.00%     0.00%  jbd2/vda-8       [kernel.kallsyms]  [k] virtio_queue_rq</span><br><span class="line">+   25.00%     0.00%  jbd2/vda-8       [kernel.kallsyms]  [k] virtblk_prep_rq.isra.0</span><br><span class="line">[...]</span><br></pre></td></tr></table></figure><p>使用 perf record 命令跟踪了 block:block_rq_issue 探针，当块设备 I&#x2F;O 请求发出时（磁盘 I&#x2F;O）触发。选项包括 -a 跟踪所有 CPU，和 -g 捕获调用图（堆栈跟踪）。跟踪数据写入到 perf.data 文件，当按下 Ctrl-C 时停止跟踪。使用 perf report 命令打印 perf.data 文件的摘要，该命令从堆栈跟踪构建一棵树，合并常见路径，并显示每个路径的百分比。</p><p>perf 报告输出显示，跟踪了 4 个事件（磁盘 I&#x2F;O），其中 75% 来自 kworker&#x2F;0:1H-kb 命令。这些事件是由内核函数 __traceiter_block_rq_issue() 发出的，最左边的 + 表示该命令可以继续展开，更多调用栈细节可以被追踪显示。通过 ？可以查看帮助文档，了解快捷键使用。</p><h2 id="2-命令示例表"><a href="#2-命令示例表" class="headerlink" title="2. 命令示例表"></a>2. 命令示例表</h2><hr><p>一些有用的单行命令，开销从最低到最高：</p><ul><li>statistics&#x2F;count: increment an integer counter on events 统计&#x2F;计数: 在事件上增加一个整数计数器</li><li>sample: collect details (eg, instruction pointer or stack) from a subset of events (once every …) 抽样: 从事件的子集中收集详细信息（例如，指令指针或堆栈）（每隔…）</li><li>trace: collect details from every event 跟踪: 从每个事件收集详细信息</li></ul><h3 id="2-1-列出事件表"><a href="#2-1-列出事件表" class="headerlink" title="2.1 列出事件表"></a>2.1 列出事件表</h3><hr><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Listing all currently known events:</span></span><br><span class="line">perf list</span><br><span class="line"></span><br><span class="line"><span class="comment"># Listing sched tracepoints:</span></span><br><span class="line">perf list <span class="string">&#x27;sched:*&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="2-2-计数一个事件"><a href="#2-2-计数一个事件" class="headerlink" title="2.2 计数一个事件"></a>2.2 计数一个事件</h3><hr><p>可以随时通过 <code>Perf stat -h</code> 查看选项帮助信息。下述命令中 <code>command</code> 需要用具体命令替换。这是计数型命令，对系统干扰最小。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># CPU counter statistics(统计) for the specified command:</span></span><br><span class="line">perf <span class="built_in">stat</span> <span class="built_in">command</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Detailed CPU counter statistics (includes extras) for the specified command: -d --detailed</span></span><br><span class="line">perf <span class="built_in">stat</span> -d <span class="built_in">command</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># CPU counter statistics for the specified PID, until Ctrl-C:</span></span><br><span class="line">perf <span class="built_in">stat</span> -p PID</span><br><span class="line"></span><br><span class="line"><span class="comment"># CPU counter statistics for the entire system, for 5 seconds: -a --all-cpus</span></span><br><span class="line">perf <span class="built_in">stat</span> -a <span class="built_in">sleep</span> 5</span><br><span class="line"></span><br><span class="line"><span class="comment"># Various basic CPU statistics, system wide, for 10 seconds: 通过 perf list 可以查看 -e 支持的事件</span></span><br><span class="line">perf <span class="built_in">stat</span> -e cycles,instructions,cache-references,cache-misses,bus-cycles -a <span class="built_in">sleep</span> 10</span><br><span class="line"></span><br><span class="line"><span class="comment"># Various CPU level 1 data cache statistics for the specified command:</span></span><br><span class="line">perf <span class="built_in">stat</span> -e L1-dcache-loads,L1-dcache-load-misses,L1-dcache-stores <span class="built_in">command</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Various CPU data TLB statistics for the specified command:</span></span><br><span class="line">perf <span class="built_in">stat</span> -e dTLB-loads,dTLB-load-misses,dTLB-prefetch-misses <span class="built_in">command</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Various CPU last level cache statistics for the specified command:</span></span><br><span class="line">perf <span class="built_in">stat</span> -e LLC-loads,LLC-load-misses,LLC-stores,LLC-prefetches <span class="built_in">command</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># X86 AMD :</span></span><br><span class="line"><span class="comment"># Using raw PMC counters, eg, counting retired instructions:</span></span><br><span class="line"><span class="comment">#  &#123;</span></span><br><span class="line"><span class="comment">#    &quot;EventName&quot;: &quot;ex_ret_instr&quot;,</span></span><br><span class="line"><span class="comment">#    &quot;EventCode&quot;: &quot;0xc0&quot;,</span></span><br><span class="line"><span class="comment">#    &quot;BriefDescription&quot;: &quot;Retired Instructions.&quot;</span></span><br><span class="line"><span class="comment">#  &#125;</span></span><br><span class="line">perf <span class="built_in">stat</span> -e ex_ret_instr <span class="built_in">sleep</span> 5</span><br><span class="line">perf <span class="built_in">stat</span> -e r0c0 <span class="built_in">sleep</span> 5</span><br><span class="line">perf <span class="built_in">stat</span> -e cpu/event=0xc0/ <span class="built_in">sleep</span> 5</span><br><span class="line"></span><br><span class="line"><span class="comment"># X86 AMD :</span></span><br><span class="line"><span class="comment"># PMCs: counting cycles and frontend stalls via raw specification:</span></span><br><span class="line"><span class="comment">#  &#123;</span></span><br><span class="line"><span class="comment">#    &quot;EventName&quot;: &quot;fp_disp_faults.x87_fill_fault&quot;,</span></span><br><span class="line"><span class="comment">#    &quot;EventCode&quot;: &quot;0x0e&quot;,</span></span><br><span class="line"><span class="comment">#    &quot;BriefDescription&quot;: &quot;Floating Point Dispatch Faults. x87 fill fault.&quot;,</span></span><br><span class="line"><span class="comment">#    &quot;UMask&quot;: &quot;0x01&quot;</span></span><br><span class="line"><span class="comment">#  &#125;</span></span><br><span class="line"><span class="comment"># 通过查看json代码或ppr文档可以解析如下命令。inv 表示反向计数，即如果0x0e是记录发生的，那么inv就是计数未发生事件</span></span><br><span class="line">perf <span class="built_in">stat</span> -e cycles -e cpu/event=0x0e,<span class="built_in">umask</span>=0x01,inv,cmask=0x01/ -a <span class="built_in">sleep</span> 5</span><br><span class="line"></span><br><span class="line"><span class="comment"># RISC-V T-head:</span></span><br><span class="line"><span class="comment">#   &#123;</span></span><br><span class="line"><span class="comment">#    &quot;EventName&quot;: &quot;L1_ICACHE_ACCESS&quot;,</span></span><br><span class="line"><span class="comment">#    &quot;EventCode&quot;: &quot;0x00000001&quot;,</span></span><br><span class="line"><span class="comment">#    &quot;BriefDescription&quot;: &quot;L1 instruction cache access&quot;</span></span><br><span class="line"><span class="comment">#   &#125;</span></span><br><span class="line"><span class="comment"># Perf list:</span></span><br><span class="line"><span class="comment">#  L1-icache-loads OR cpu/L1-icache-loads/</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">perf <span class="built_in">stat</span> -e L1-icache-loads <span class="built_in">sleep</span> 3</span><br><span class="line">perf <span class="built_in">stat</span> -e r01 <span class="built_in">sleep</span> 3</span><br><span class="line">perf <span class="built_in">stat</span> -e  cpu/L1-icache-loads/ <span class="built_in">sleep</span> 3</span><br><span class="line"></span><br><span class="line"><span class="comment"># Count syscalls per-second system-wide: -I 1000, 以1000毫秒为周期打印系统调用的次数</span></span><br><span class="line">perf <span class="built_in">stat</span> -e raw_syscalls:sys_enter -I 1000 -a</span><br><span class="line"></span><br><span class="line"><span class="comment"># Count system calls by type for the specified PID, until Ctrl-C:</span></span><br><span class="line">perf <span class="built_in">stat</span> -e <span class="string">&#x27;syscalls:sys_enter_*&#x27;</span> -p PID</span><br><span class="line"></span><br><span class="line"><span class="comment"># Count system calls by type for the entire system, for 5 seconds:</span></span><br><span class="line">perf <span class="built_in">stat</span> -e <span class="string">&#x27;syscalls:sys_enter_*&#x27;</span> -a <span class="built_in">sleep</span> 5</span><br><span class="line"></span><br><span class="line"><span class="comment"># Count scheduler events for the specified PID, until Ctrl-C:</span></span><br><span class="line">perf <span class="built_in">stat</span> -e <span class="string">&#x27;sched:*&#x27;</span> -p PID</span><br><span class="line"></span><br><span class="line"><span class="comment"># Count scheduler events for the specified PID, for 10 seconds:</span></span><br><span class="line">perf <span class="built_in">stat</span> -e <span class="string">&#x27;sched:*&#x27;</span> -p PID <span class="built_in">sleep</span> 10</span><br><span class="line"></span><br><span class="line"><span class="comment"># Count ext4 events for the entire system, for 10 seconds:</span></span><br><span class="line">perf <span class="built_in">stat</span> -e <span class="string">&#x27;ext4:*&#x27;</span> -a <span class="built_in">sleep</span> 10</span><br><span class="line"></span><br><span class="line"><span class="comment"># Count block device I/O events for the entire system, for 10 seconds:</span></span><br><span class="line">perf <span class="built_in">stat</span> -e <span class="string">&#x27;block:*&#x27;</span> -a <span class="built_in">sleep</span> 10</span><br><span class="line"></span><br><span class="line"><span class="comment"># Count all vmscan events, printing a report every second:</span></span><br><span class="line">perf <span class="built_in">stat</span> -e <span class="string">&#x27;vmscan:*&#x27;</span> -a -I 1000</span><br></pre></td></tr></table></figure><h3 id="2-3-采样分析"><a href="#2-3-采样分析" class="headerlink" title="2.3 采样分析"></a>2.3 采样分析</h3><hr><p>使用 perf 工具对系统或应用程序的性能进行采样和分析的过程，如函数调用栈、CPU 使用情况等，从而帮助开发者或系统管理员了解程序的性能瓶颈。<code>Perf record</code> 命令默认采样周期率 1000 Hertz，当没有 -F 参数时使用默认值。使用 <code>perf record</code> 的采样模式时，需要注意开销问题，因为捕获文件可能会迅速达到数百兆字节。</p><p><code>Perf top</code> 是实时采集并显示，不会保存 Perf.data 文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Sample on-CPU functions for the specified command, at 99 Hertz: -F 99 表示采样频率</span></span><br><span class="line">perf record -F 99 <span class="built_in">command</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Sample on-CPU functions for the specified PID, at 99 Hertz, until Ctrl-C:</span></span><br><span class="line">perf record -F 99 -p PID</span><br><span class="line"></span><br><span class="line"><span class="comment"># Sample on-CPU functions for the specified PID, at 99 Hertz, for 10 seconds:</span></span><br><span class="line">perf record -F 99 -p PID <span class="built_in">sleep</span> 10</span><br><span class="line"></span><br><span class="line"><span class="comment"># Sample CPU stack traces (via frame pointers) for the specified PID, at 99 Hertz, for 10 seconds: -g 表示收集调用栈</span></span><br><span class="line">perf record -F 99 -p PID -g -- <span class="built_in">sleep</span> 10</span><br><span class="line"></span><br><span class="line"><span class="comment"># Sample CPU stack traces for the PID, using dwarf (dbg info) to unwind stacks, at 99 Hertz, for 10 seconds:</span></span><br><span class="line">perf record -F 99 -p PID --call-graph dwarf <span class="built_in">sleep</span> 10</span><br><span class="line"></span><br><span class="line"><span class="comment"># Sample CPU stack traces for the entire system, at 99 Hertz, for 10 seconds (&lt; Linux 4.11):</span></span><br><span class="line">perf record -F 99 -ag -- <span class="built_in">sleep</span> 10</span><br><span class="line"></span><br><span class="line"><span class="comment"># Sample CPU stack traces for the entire system, at 99 Hertz, for 10 seconds (&gt;= Linux 4.11):</span></span><br><span class="line">perf record -F 99 -g -- <span class="built_in">sleep</span> 10</span><br><span class="line"></span><br><span class="line"><span class="comment"># If the previous command didn&#x27;t work, try forcing perf to use the cpu-clock event:</span></span><br><span class="line">perf record -F 99 -e cpu-clock -ag -- <span class="built_in">sleep</span> 10</span><br><span class="line"></span><br><span class="line"><span class="comment"># Sample CPU stack traces for a container identified by its /sys/fs/cgroup/perf_event cgroup:</span></span><br><span class="line">perf record -F 99 -e cpu-clock --cgroup=docker/1d567f4393190204...etc... -a -- <span class="built_in">sleep</span> 10</span><br><span class="line"></span><br><span class="line"><span class="comment"># Sample CPU stack traces for the entire system, with dwarf stacks, at 99 Hertz, for 10 seconds:</span></span><br><span class="line">perf record -F 99 -a --call-graph dwarf <span class="built_in">sleep</span> 10</span><br><span class="line"></span><br><span class="line"><span class="comment"># Sample CPU stack traces for the entire system, using last branch record for stacks, ... (&gt;= Linux 4.?):</span></span><br><span class="line">perf record -F 99 -a --call-graph lbr <span class="built_in">sleep</span> 10</span><br><span class="line"></span><br><span class="line"><span class="comment"># Sample CPU stack traces, once every 10,000 Level 1 data cache misses, for 5 seconds:</span></span><br><span class="line">perf record -e L1-dcache-load-misses -c 10000 -ag -- <span class="built_in">sleep</span> 5</span><br><span class="line"></span><br><span class="line"><span class="comment"># Sample CPU stack traces, once every 100 last level cache misses, for 5 seconds:</span></span><br><span class="line">perf record -e LLC-load-misses -c 100 -ag -- <span class="built_in">sleep</span> 5</span><br><span class="line"></span><br><span class="line"><span class="comment"># Sample on-CPU kernel instructions, for 5 seconds:</span></span><br><span class="line">perf record -e cycles:k -a -- <span class="built_in">sleep</span> 5</span><br><span class="line"></span><br><span class="line"><span class="comment"># Sample on-CPU user instructions, for 5 seconds:</span></span><br><span class="line">perf record -e cycles:u -a -- <span class="built_in">sleep</span> 5</span><br><span class="line"></span><br><span class="line"><span class="comment"># Sample on-CPU user instructions precisely (using PEBS), for 5 seconds:</span></span><br><span class="line">perf record -e cycles:up -a -- <span class="built_in">sleep</span> 5</span><br><span class="line"></span><br><span class="line"><span class="comment"># Perform branch tracing (needs HW support), for 1 second: -b 表示对预测为 taken 的分支采样</span></span><br><span class="line">perf record -b -a <span class="built_in">sleep</span> 1</span><br><span class="line"></span><br><span class="line"><span class="comment"># Sample CPUs at 49 Hertz, and show top addresses and symbols, live (no perf.data file):</span></span><br><span class="line">perf top -F 49</span><br><span class="line"></span><br><span class="line"><span class="comment"># Sample CPUs at 49 Hertz, and show top process names and segments, live:</span></span><br><span class="line">perf top -F 49 -ns <span class="built_in">comm</span>,dso</span><br></pre></td></tr></table></figure><h3 id="2-4-静态跟踪"><a href="#2-4-静态跟踪" class="headerlink" title="2.4 静态跟踪"></a>2.4 静态跟踪</h3><hr><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Trace new processes, until Ctrl-C:</span></span><br><span class="line">perf record -e <span class="built_in">sched</span>:sched_process_exec -a</span><br><span class="line"></span><br><span class="line"><span class="comment"># Sample (take a subset of) context-switches, until Ctrl-C:</span></span><br><span class="line">perf record -e context-switches -a</span><br><span class="line"></span><br><span class="line"><span class="comment"># Trace all context-switches, until Ctrl-C:</span></span><br><span class="line">perf record -e context-switches -c 1 -a</span><br><span class="line"></span><br><span class="line"><span class="comment"># Include raw settings used (see: man perf_event_open): 使用 -vv 表示更详细的输出</span></span><br><span class="line">perf record -vv -e context-switches -a</span><br><span class="line"></span><br><span class="line"><span class="comment"># Trace all context-switches via sched tracepoint, until Ctrl-C:</span></span><br><span class="line">perf record -e <span class="built_in">sched</span>:sched_switch -a</span><br><span class="line"></span><br><span class="line"><span class="comment"># Sample context-switches with stack traces, until Ctrl-C:</span></span><br><span class="line">perf record -e context-switches -ag</span><br><span class="line"></span><br><span class="line"><span class="comment"># Sample context-switches with stack traces, for 10 seconds:</span></span><br><span class="line">perf record -e context-switches -ag -- <span class="built_in">sleep</span> 10</span><br><span class="line"></span><br><span class="line"><span class="comment"># Sample CS, stack traces, and with timestamps (&lt; Linux 3.17, -T now default): -T：表示记录时间戳, 默认带时间戳</span></span><br><span class="line">perf record -e context-switches -ag -T</span><br><span class="line"></span><br><span class="line"><span class="comment"># Sample CPU migrations, for 10 seconds:</span></span><br><span class="line">perf record -e migrations -a -- <span class="built_in">sleep</span> 10</span><br><span class="line"></span><br><span class="line"><span class="comment"># Trace all connect()s with stack traces (outbound connections), until Ctrl-C:</span></span><br><span class="line">perf record -e syscalls:sys_enter_connect -ag</span><br><span class="line"></span><br><span class="line"><span class="comment"># Trace all accepts()s with stack traces (inbound connections), until Ctrl-C:</span></span><br><span class="line">perf record -e syscalls:sys_enter_accept* -ag</span><br><span class="line"></span><br><span class="line"><span class="comment"># Trace all block device (disk I/O) requests with stack traces, until Ctrl-C:</span></span><br><span class="line">perf record -e block:block_rq_insert -ag</span><br><span class="line"></span><br><span class="line"><span class="comment"># Sample at most 100 block device requests per second, until Ctrl-C:</span></span><br><span class="line">perf record -F 100 -e block:block_rq_insert -a</span><br><span class="line"></span><br><span class="line"><span class="comment"># Trace all block device issues and completions (has timestamps), until Ctrl-C:</span></span><br><span class="line">perf record -e block:block_rq_issue -e block:block_rq_complete -a</span><br><span class="line"></span><br><span class="line"><span class="comment"># Trace all block completions, of size at least 100 Kbytes, until Ctrl-C:</span></span><br><span class="line"><span class="comment"># nr_sector &gt; 200表示请求的大小大于200个扇区，换算成字节就是200 * 512 = 100 KB</span></span><br><span class="line">perf record -e block:block_rq_complete --filter <span class="string">&#x27;nr_sector &gt; 200&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Trace all block completions, synchronous writes only, until Ctrl-C:</span></span><br><span class="line"><span class="comment"># 筛选出rwbs字段等于&quot;WS&quot;的事件。rwbs字段表示I/O操作的类型和方向，&quot;WS&quot;表示同步写入操作。</span></span><br><span class="line">perf record -e block:block_rq_complete --filter <span class="string">&#x27;rwbs == &quot;WS&quot;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Trace all block completions, all types of writes, until Ctrl-C:</span></span><br><span class="line"><span class="comment">#  &#x27;rwbs ~ &quot;*W*&#x27;&quot; 是rwbs 是一个字段，表示请求的读写类型和块大小等信息。~ 是一个正则表达式匹配操作符，&quot;*W*&quot; 表示匹配包含“W”（表示写操作）的字符串。所以，这个过滤条件的作用是只记录包含写操作的块设备请求完成事件，从而实现追踪所有类型的写操作完成情况。</span></span><br><span class="line">perf record -e block:block_rq_complete --filter <span class="string">&#x27;rwbs ~ &quot;*W*&quot;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Sample minor faults (RSS growth) with stack traces, until Ctrl-C:</span></span><br><span class="line">perf record -e minor-faults -ag</span><br><span class="line"></span><br><span class="line"><span class="comment"># Trace all minor faults with stack traces, until Ctrl-C:</span></span><br><span class="line">perf record -e minor-faults -c 1 -ag</span><br><span class="line"></span><br><span class="line"><span class="comment"># Sample page faults with stack traces, until Ctrl-C:</span></span><br><span class="line">perf record -e page-faults -ag</span><br><span class="line"></span><br><span class="line"><span class="comment"># Trace all ext4 calls, and write to a non-ext4 location, until Ctrl-C:</span></span><br><span class="line">perf record -e <span class="string">&#x27;ext4:*&#x27;</span> -o /tmp/perf.data -a</span><br><span class="line"></span><br><span class="line"><span class="comment"># Trace kswapd wakeup events, until Ctrl-C:</span></span><br><span class="line">perf record -e vmscan:mm_vmscan_wakeup_kswapd -ag</span><br><span class="line"></span><br><span class="line"><span class="comment"># Add Node.js USDT probes (Linux 4.10+):</span></span><br><span class="line">perf buildid-cache --add `<span class="built_in">which</span> node`</span><br><span class="line"></span><br><span class="line"><span class="comment"># Trace the node http__server__request USDT event (Linux 4.10+):</span></span><br><span class="line">perf record -e sdt_node:http__server__request -a</span><br></pre></td></tr></table></figure><h3 id="2-5-动态跟踪"><a href="#2-5-动态跟踪" class="headerlink" title="2.5 动态跟踪"></a>2.5 动态跟踪</h3><hr><p>“perf probe” 是 Linux 系统中 perf 工具的一个子命令，用于在内核或用户空间程序中添加动态追踪点（tracepoint），需要内核编译时支持kprobe&#x2F;uprobe。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Add a tracepoint for the kernel tcp_sendmsg() function entry (&quot;--add&quot; is optional):</span></span><br><span class="line">perf probe --add tcp_sendmsg</span><br><span class="line"></span><br><span class="line"><span class="comment"># Remove the tcp_sendmsg() tracepoint (or use &quot;--del&quot;):</span></span><br><span class="line">perf probe -d tcp_sendmsg</span><br><span class="line"></span><br><span class="line"><span class="comment"># Add a tracepoint for the kernel tcp_sendmsg() function return:</span></span><br><span class="line">perf probe <span class="string">&#x27;tcp_sendmsg%return&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Show available variables for the kernel tcp_sendmsg() function (needs debuginfo):</span></span><br><span class="line">perf probe -V tcp_sendmsg</span><br><span class="line"></span><br><span class="line"><span class="comment"># Show available variables for the kernel tcp_sendmsg() function, plus external vars (needs debuginfo):</span></span><br><span class="line">perf probe -V tcp_sendmsg --externs</span><br><span class="line"></span><br><span class="line"><span class="comment"># Show available line probes for tcp_sendmsg() (needs debuginfo):</span></span><br><span class="line">perf probe -L tcp_sendmsg</span><br><span class="line"></span><br><span class="line"><span class="comment"># Show available variables for tcp_sendmsg() at line number 81 (needs debuginfo):</span></span><br><span class="line">perf probe -V tcp_sendmsg:81</span><br><span class="line"></span><br><span class="line"><span class="comment"># Add a tracepoint for tcp_sendmsg(), with three entry argument registers (platform specific):</span></span><br><span class="line">perf probe <span class="string">&#x27;tcp_sendmsg %ax %dx %cx&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Add a tracepoint for tcp_sendmsg(), with an alias (&quot;bytes&quot;) for the %cx register (platform specific):</span></span><br><span class="line">perf probe <span class="string">&#x27;tcp_sendmsg bytes=%cx&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Trace previously created probe when the bytes (alias) variable is greater than 100:</span></span><br><span class="line">perf record -e probe:tcp_sendmsg --filter <span class="string">&#x27;bytes &gt; 100&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Add a tracepoint for tcp_sendmsg() return, and capture the return value:</span></span><br><span class="line">perf probe <span class="string">&#x27;tcp_sendmsg%return $retval&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Add a tracepoint for tcp_sendmsg(), and &quot;size&quot; entry argument (reliable, but needs debuginfo):</span></span><br><span class="line">perf probe <span class="string">&#x27;tcp_sendmsg size&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Add a tracepoint for tcp_sendmsg(), with size and socket state (needs debuginfo):</span></span><br><span class="line">perf probe <span class="string">&#x27;tcp_sendmsg size sk-&gt;__sk_common.skc_state&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Tell me how on Earth you would do this, but don&#x27;t actually do it (needs debuginfo):</span></span><br><span class="line">perf probe -nv <span class="string">&#x27;tcp_sendmsg size sk-&gt;__sk_common.skc_state&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Trace previous probe when size is non-zero, and state is not TCP_ESTABLISHED(1) (needs debuginfo):</span></span><br><span class="line">perf record -e probe:tcp_sendmsg --filter <span class="string">&#x27;size &gt; 0 &amp;&amp; skc_state != 1&#x27;</span> -a</span><br><span class="line"></span><br><span class="line"><span class="comment"># Add a tracepoint for tcp_sendmsg() line 81 with local variable seglen (needs debuginfo):</span></span><br><span class="line">perf probe <span class="string">&#x27;tcp_sendmsg:81 seglen&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Add a tracepoint for do_sys_open() with the filename as a string (needs debuginfo):</span></span><br><span class="line">perf probe <span class="string">&#x27;do_sys_open filename:string&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Add a tracepoint for myfunc() return, and include the retval as a string:</span></span><br><span class="line">perf probe <span class="string">&#x27;myfunc%return +0($retval):string&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Add a tracepoint for the user-level malloc() function from libc:</span></span><br><span class="line">perf probe -x /lib64/libc.so.6 malloc</span><br><span class="line"></span><br><span class="line"><span class="comment"># Add a tracepoint for this user-level static probe (USDT, aka SDT event):</span></span><br><span class="line">perf probe -x /usr/lib64/libpthread-2.24.so %sdt_libpthread:mutex_entry</span><br><span class="line"></span><br><span class="line"><span class="comment"># List currently available dynamic probes:</span></span><br><span class="line">perf probe -l</span><br></pre></td></tr></table></figure><h3 id="2-6-杂项"><a href="#2-6-杂项" class="headerlink" title="2.6 杂项"></a>2.6 杂项</h3><hr><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Trace system calls by process, showing a summary refreshing every 2 seconds:</span></span><br><span class="line">perf top -e raw_syscalls:sys_enter -ns <span class="built_in">comm</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Trace sent network packets by on-CPU process, rolling output (no clear):</span></span><br><span class="line"><span class="built_in">stdbuf</span> -oL perf top -e net:net_dev_xmit -ns <span class="built_in">comm</span> | strings</span><br><span class="line"></span><br><span class="line"><span class="comment"># Sample stacks at 99 Hertz, and, context switches:</span></span><br><span class="line">perf record -F99 -e cpu-clock -e cs -a -g</span><br><span class="line"></span><br><span class="line"><span class="comment"># Sample stacks to 2 levels deep, and, context switch stacks to 5 levels (needs 4.8):</span></span><br><span class="line">perf record -F99 -e cpu-clock/max-stack=2/ -e cs/max-stack=5/ -a -g</span><br></pre></td></tr></table></figure><h3 id="2-7-cacheline"><a href="#2-7-cacheline" class="headerlink" title="2.7 cacheline"></a>2.7 cacheline</h3><hr><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Record cacheline events (Linux 4.10+):</span></span><br><span class="line">perf c2c record -a -- <span class="built_in">sleep</span> 10</span><br><span class="line"></span><br><span class="line"><span class="comment"># Report cacheline events from previous recording (Linux 4.10+):</span></span><br><span class="line">perf c2c report</span><br></pre></td></tr></table></figure><h3 id="2-8-解析生成报告"><a href="#2-8-解析生成报告" class="headerlink" title="2.8 解析生成报告"></a>2.8 解析生成报告</h3><hr><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Show perf.data in an ncurses browser (TUI) if possible:</span></span><br><span class="line">perf report</span><br><span class="line"></span><br><span class="line"><span class="comment"># Show perf.data with a column for sample count:</span></span><br><span class="line">perf report -n</span><br><span class="line"></span><br><span class="line"><span class="comment"># Show perf.data as a text report, with data coalesced and percentages:</span></span><br><span class="line">perf report --stdio</span><br><span class="line"></span><br><span class="line"><span class="comment"># Report, with stacks in folded format: one line per stack (needs 4.4):</span></span><br><span class="line">perf report --stdio -n -g folded</span><br><span class="line"></span><br><span class="line"><span class="comment"># List all events from perf.data:</span></span><br><span class="line">perf script</span><br><span class="line"></span><br><span class="line"><span class="comment"># List all perf.data events, with data header (newer kernels; was previously default):</span></span><br><span class="line">perf script --header</span><br><span class="line"></span><br><span class="line"><span class="comment"># List all perf.data events, with customized fields (&lt; Linux 4.1):</span></span><br><span class="line">perf script -f <span class="keyword">time</span>,event,trace</span><br><span class="line"></span><br><span class="line"><span class="comment"># List all perf.data events, with customized fields (&gt;= Linux 4.1):</span></span><br><span class="line">perf script -F <span class="keyword">time</span>,event,trace</span><br><span class="line"></span><br><span class="line"><span class="comment"># List all perf.data events, with my recommended fields (needs record -a; newer kernels):</span></span><br><span class="line">perf script --header -F <span class="built_in">comm</span>,pid,tid,cpu,<span class="keyword">time</span>,event,ip,sym,dso</span><br><span class="line"></span><br><span class="line"><span class="comment"># List all perf.data events, with my recommended fields (needs record -a; older kernels):</span></span><br><span class="line">perf script -f <span class="built_in">comm</span>,pid,tid,cpu,<span class="keyword">time</span>,event,ip,sym,dso</span><br><span class="line"></span><br><span class="line"><span class="comment"># Dump raw contents from perf.data as hex (for debugging):</span></span><br><span class="line">perf script -D</span><br><span class="line"></span><br><span class="line"><span class="comment"># Disassemble and annotate instructions with percentages (needs some debuginfo):</span></span><br><span class="line">perf annotate --stdio</span><br></pre></td></tr></table></figure><h3 id="2-9-总结"><a href="#2-9-总结" class="headerlink" title="2.9 总结"></a>2.9 总结</h3><hr><p>尽管上述列举了很多命令，但随着工具的迭代，命令的种类和功能在不断增加。使用 <code>perf help</code> 命令可以查看所有可用的命令。</p>]]></content>
      
      
      <categories>
          
          <category> Perf </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RISC-V </tag>
            
            <tag> Perf </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux Perf 介绍 —— Perf 总结</title>
      <link href="/2025/08/26/Linux-Perf-%E4%BB%8B%E7%BB%8D-%E2%80%94%E2%80%94-Perf-%E6%80%BB%E7%BB%93/"/>
      <url>/2025/08/26/Linux-Perf-%E4%BB%8B%E7%BB%8D-%E2%80%94%E2%80%94-Perf-%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="系列目录"><a href="#系列目录" class="headerlink" title="系列目录"></a>系列目录</h1><hr><p><a href="http://localhost:4000/2025/08/21/Linux-Perf-%E4%BB%8B%E7%BB%8D-%E2%80%94%E2%80%94-Perf-%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/">Linux Perf 介绍 —— Perf 命令行工具</a><br><a href="http://localhost:4000/2025/08/21/Linux-Perf-%E4%BB%8B%E7%BB%8D-%E2%80%94%E2%80%94-Perf-%E5%B7%A5%E5%85%B7%E8%B0%83%E7%94%A8%E5%88%86%E6%9E%90/">Linux Perf 介绍-—— Perf 工具调用分析</a><br><a href="http://localhost:4000/2025/08/26/Linux-Perf-%E4%BB%8B%E7%BB%8D-%E2%80%94%E2%80%94-Perf-%E5%86%85%E6%A0%B8%E5%8F%8A%E9%A9%B1%E5%8A%A8%E6%94%AF%E6%8C%81/">Linux Perf 介绍 —— Perf 内核及驱动支持</a><br><a href="http://localhost:4000/2025/08/26/Linux-Perf-%E4%BB%8B%E7%BB%8D-%E2%80%94%E2%80%94-Perf-opensbi-%E6%94%AF%E6%8C%81/">Linux Perf 介绍 —— Perf opensbi 支持</a><br><a href="http://localhost:4000/2025/08/26/Linux-Perf-%E4%BB%8B%E7%BB%8D-%E2%80%94%E2%80%94-Perf-%E6%80%BB%E7%BB%93/">Linux Perf 介绍 —— Perf 总结</a></p><h1 id="Perf-命令执行流程是怎样的？"><a href="#Perf-命令执行流程是怎样的？" class="headerlink" title="Perf 命令执行流程是怎样的？"></a>Perf 命令执行流程是怎样的？</h1><p>应用层发起 Perf 命令执行，通过调用系统函数 perf_event_open 创建文件描述符来记录性能事件。通过系统调用 write 来执行命令。在执行命令前，发起了 cycles 和 instructions 硬件事件的 ecall 调用，从而获取可用计数器索引，并配置 mhpmevent、mcountinhibit 和 mhpmcounter，启动计数器。当结束命令时，通过 ecall 发起 stop 命令设置 mcountinhibit 从而停止计数，并通过在 s 模式读取 hpmcounter 来获取计数值。</p><p>Perf 执行过程中获取索引是先检查特殊计数器 mcycle 和 minstret，但是必须在不支持 sscofpmf 的条件下才会使用，因为这个扩展给 HPM 提供了溢出和过滤控制，当扩展被实现时会有限使用 HPM 计数器。</p><h1 id="是如何通过-event-idx-获取-mhpmevent-值的？"><a href="#是如何通过-event-idx-获取-mhpmevent-值的？" class="headerlink" title="是如何通过 event_idx 获取 mhpmevent 值的？"></a>是如何通过 event_idx 获取 mhpmevent 值的？</h1><p>event_idx 格式由 SBI PMU Ext. 定义，具体编码由设备树和JSON文件共同定义。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">pmu &#123;</span><br><span class="line">compatible = <span class="string">&quot;riscv,pmu&quot;</span>;</span><br><span class="line">riscv,event-to-mhpmevent =</span><br><span class="line"><span class="comment">/* PMU_HW_BRANCH_INSTRUCTIONS -&gt; inst_branch */</span></span><br><span class="line">&lt;<span class="number">0x00005</span> <span class="number">0x00000000</span> <span class="number">0x00000036</span>&gt;,</span><br><span class="line"><span class="comment">/* 0x00005 是 SBI PMU Ext 定义的 event_idx, type=0,表示 HW 事件类型，code=5,表示 branch 事件。 第二列和第三列合并为64位数据，这个数据将会配置到 mhpmevent 中，表示硬件实现上对应的 branch 事件选择器编码。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/* PMU_HW_BRANCH_MISSES -&gt; inst_branch_mispredict */</span></span><br><span class="line">&lt;<span class="number">0x00006</span> <span class="number">0x00000000</span> <span class="number">0x00000038</span>&gt;,</span><br><span class="line">...</span><br><span class="line"><span class="comment">/* L1D_READ_ACCESS -&gt; l1_dcache_read_access */</span></span><br><span class="line">&lt;<span class="number">0x10000</span> <span class="number">0x00000000</span> <span class="number">0x0000000c</span>&gt;,</span><br><span class="line"><span class="comment">/* 0x10000, bit[19:16] = 1, type=1, CACHE 事件类型，code=0, L1D Cache event 对应 xuantie 事件 0xC, L1 DCache load access */</span></span><br><span class="line"><span class="comment">/* L1D_READ_MISS -&gt; l1_dcache_read_miss */</span></span><br><span class="line">&lt;<span class="number">0x10001</span> <span class="number">0x00000000</span> <span class="number">0x0000000d</span>&gt;,</span><br><span class="line">...</span><br><span class="line">&lt;<span class="number">0x10029</span> <span class="number">0x00000000</span> <span class="number">0x00000001b</span>&gt;;</span><br><span class="line">riscv,event-to-mhpmcounters =</span><br><span class="line"><span class="comment">/* The Xuantie processor only implements 18 mhpmcounters, so the bitmap is</span></span><br><span class="line"><span class="comment">0x7fff8 */</span></span><br><span class="line">&lt;<span class="number">0x00005</span> <span class="number">0x00005</span> <span class="number">0x7fff8</span>&gt;,</span><br><span class="line"><span class="comment">/* 第一列表示 event_idx 开始，第二列表示 event_idx 结束，合起来表示一个事件范围， 第三列表示支持该事件范围的计数器，每个计数器一个比特位表示，共32个计数器。 */</span></span><br><span class="line">&lt;<span class="number">0x00006</span> <span class="number">0x00006</span> <span class="number">0x7fff8</span>&gt;,</span><br><span class="line">...</span><br><span class="line">&lt;<span class="number">0x10029</span> <span class="number">0x10029</span> <span class="number">0x7fff8</span>&gt;;</span><br><span class="line">riscv,raw-event-to-mhpmcounters =</span><br><span class="line"><span class="comment">/* For raw event ID 0x0 0xff */</span></span><br><span class="line">&lt;<span class="number">0x0</span> <span class="number">0x0</span> <span class="number">0xffffffff</span> <span class="number">0xffffff00</span> <span class="number">0x7fff8</span>&gt;;</span><br><span class="line"><span class="comment">/* 第一列和第二列构成64位 事件选择器值，第三/四列构成mask，第五列是计数器位图，事件选择器值与上mask之后直接配置到 mhpmevent */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>转换过程：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sbi_pmu_ctr_cfg_match</span><br><span class="line">  -&gt; pmu_ctr_find_hw</span><br><span class="line">    -&gt; pmu_update_hw_mhpmevent</span><br><span class="line">      -&gt; sbi_platform_pmu_xlate_to_mhpmevent</span><br><span class="line">        -&gt; pmu_xlate_to_mhpmevent</span><br><span class="line">          -&gt; generic_pmu_xlate_to_mhpmevent</span><br><span class="line">            -&gt; evt_val = data; <span class="comment">// data 由 perf 传下来的，是JSON文件中的code, 这个值经过与设备树 raw-event-to-mhpmcounters 的值比较后配置到 mhpmevent</span></span><br><span class="line">            -&gt; fdt_pmu_get_select_value</span><br><span class="line">              -&gt; <span class="keyword">if</span> event-&gt;eidx==event_idx then <span class="keyword">return</span> select <span class="comment">// 针对标准事件，从设备树 event-to-mhpmevent 获取</span></span><br></pre></td></tr></table></figure><p>整个转换过程如上，os 下发 cfg_match function_id， 从而将 event_idx 转换成 data&#x2F;select, 然后配置到 mhpmevent 并返回计数器索引。</p>]]></content>
      
      
      <categories>
          
          <category> Perf </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RISC-V </tag>
            
            <tag> Perf </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux Perf 介绍 —— Perf OpenSBI 支持</title>
      <link href="/2025/08/26/Linux-Perf-%E4%BB%8B%E7%BB%8D-%E2%80%94%E2%80%94-Perf-opensbi-%E6%94%AF%E6%8C%81/"/>
      <url>/2025/08/26/Linux-Perf-%E4%BB%8B%E7%BB%8D-%E2%80%94%E2%80%94-Perf-opensbi-%E6%94%AF%E6%8C%81/</url>
      
        <content type="html"><![CDATA[<h1 id="系列目录"><a href="#系列目录" class="headerlink" title="系列目录"></a>系列目录</h1><hr><p><a href="http://localhost:4000/2025/08/21/Linux-Perf-%E4%BB%8B%E7%BB%8D-%E2%80%94%E2%80%94-Perf-%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/">Linux Perf 介绍 —— Perf 命令行工具</a><br><a href="http://localhost:4000/2025/08/21/Linux-Perf-%E4%BB%8B%E7%BB%8D-%E2%80%94%E2%80%94-Perf-%E5%B7%A5%E5%85%B7%E8%B0%83%E7%94%A8%E5%88%86%E6%9E%90/">Linux Perf 介绍-—— Perf 工具调用分析</a><br><a href="http://localhost:4000/2025/08/26/Linux-Perf-%E4%BB%8B%E7%BB%8D-%E2%80%94%E2%80%94-Perf-%E5%86%85%E6%A0%B8%E5%8F%8A%E9%A9%B1%E5%8A%A8%E6%94%AF%E6%8C%81/">Linux Perf 介绍 —— Perf 内核及驱动支持</a><br><a href="http://localhost:4000/2025/08/26/Linux-Perf-%E4%BB%8B%E7%BB%8D-%E2%80%94%E2%80%94-Perf-opensbi-%E6%94%AF%E6%8C%81/">Linux Perf 介绍 —— Perf OpenSBI 支持</a><br><a href="http://localhost:4000/2025/08/26/Linux-Perf-%E4%BB%8B%E7%BB%8D-%E2%80%94%E2%80%94-Perf-%E6%80%BB%E7%BB%93/">Linux Perf 介绍 —— Perf 总结</a></p><h1 id="初始化的-ecall-跟踪"><a href="#初始化的-ecall-跟踪" class="headerlink" title="初始化的 ecall 跟踪"></a>初始化的 ecall 跟踪</h1><hr><p>整体过程：</p><ol><li><p>获取计数器数量。os 通过 ecall 调用 sbi_pmu_num_ctr 从而返回平台支持的计数器数量，在 xuantie c920v3 中，该函数返回 48 个计数器，包括32个硬件计数器，16 个软件计数器。</p></li><li><p>获取计数器信息。os 通过 ecall 调用 sbi_pmu_get_ctr_info 获取计数器信息，返回计数器信息结构体。<br><img src="/image.png" alt="alt text"><br>因此当为 mcycle 时，返回 0x3fc00, 其中 0xc00 是 csr 地址，0x3f 是计数器宽度，表示64位计数器。若为 FW 计数器，则返回 0x800000000003f000, 其最高位为1，表示计数器是软件计数器，0x3f 表示宽度为64位，csr 地址为 0，因为不需要csr. 这一步会对第一步返回的48个计数器进行遍历。因此，在实现上暗含所有core的pmu相同的信息。</p></li><li><p>停止 cycles&#x2F;instructions 事件<br>由于索引 idx&#x3D;0 是 cycle, idx &#x3D; 1 是 time, idx &#x3D; 2 是 instret，这3个计数器是专用的，因此，opensbi 初始化时，针对这3个计数器设置了专门的标志，而且标志不可修改。因此，初始化时对这3个计数进行了停止操作（置位mcountinhibit）。</p></li></ol><h1 id="运行-Perf-时-ecall-跟踪"><a href="#运行-Perf-时-ecall-跟踪" class="headerlink" title="运行 Perf 时 ecall 跟踪"></a>运行 Perf 时 ecall 跟踪</h1><p>执行命令<code>perf stat -e cycles,instructions date &gt; /dev/null</code>，对 <code>sbi_ecall_pmu_handler</code> 函数断点跟踪。生成日志 <a href="gdb.log_perf_stat_-e_cycles_instructions_date_dev_null">gdblog</a>。</p><p>整理相关参数如下：</p><table><thead><tr><th>No.</th><th>A0</th><th>A1</th><th>A2</th><th>A3</th><th>A6</th><th>备注</th></tr></thead><tbody><tr><td>1</td><td>0</td><td>mask</td><td>0x18</td><td>1</td><td>2</td><td>SBI_EXT_PMU_COUNTER_CFG_MATCH SBI_PMU_CFG_FLAG_SET_VUINH SBI_PMU_CFG_FLAG_SET_VSINH event_idx&#x3D;1 ，对应 pmu_sbi_ctr_get_idx 的 ecall 调用，配置 mhpmevent，事件编码1，HW事件 cpu_cycles, 并返回可用索引值</td></tr><tr><td>2</td><td>0x1f</td><td>1</td><td>1</td><td>ival</td><td>3</td><td>SBI_EXT_PMU_COUNTER_START SBI_PMU_START_FLAG_SET_INIT_VALUE，配置 mcountinhibit 和 mhpmcounter，索引值 0x1f (由上一步返回给os), counter初始值 0x8000000000000001，此步执行后开始计数</td></tr><tr><td>3</td><td>0</td><td>mask</td><td>0x18</td><td>2</td><td>2</td><td>SBI_EXT_PMU_COUNTER_CFG_MATCH SBI_PMU_CFG_FLAG_SET_VUINH SBI_PMU_CFG_FLAG_SET_VSINH event_idx&#x3D;2, 与第一步相似，只是事件编码为2，instruction 事件</td></tr><tr><td>4</td><td>0x1e</td><td>1</td><td>1</td><td>ival</td><td>3</td><td>SBI_EXT_PMU_COUNTER_START SBI_PMU_START_FLAG_SET_INIT_VALUE</td></tr><tr><td>5</td><td>0x1f</td><td>1</td><td>0</td><td>0</td><td>4</td><td>SBI_EXT_PMU_COUNTER_STOP</td></tr><tr><td>6</td><td>0x1f</td><td>1</td><td>1</td><td>0</td><td>4</td><td>SBI_EXT_PMU_COUNTER_STOP SBI_PMU_STOP_FLAG_RESET</td></tr><tr><td>7</td><td>0x1e</td><td>1</td><td>0</td><td>0</td><td>4</td><td>SBI_EXT_PMU_COUNTER_STOP</td></tr><tr><td>8</td><td>0x1e</td><td>1</td><td>1</td><td>0</td><td>4</td><td>SBI_EXT_PMU_COUNTER_STOP SBI_PMU_STOP_FLAG_RESET</td></tr></tbody></table><p>mask&#x3D;0xfffffffffffd;<br>ival&#x3D;0x8000000000000001;</p><ul><li>A0表示counter索引，从0开始到31表示硬件计数器，分别代表cycle, time, instret, hpmN, 32~47表示 FW 计数器。</li><li>A1表示counter mask，每个比特对应一个计数器。</li><li>A2为flag，针对不同的 SBI PMU 扩展类型，解释不同。0x18, 表示设置 VSINH&#x2F;VUINH; 1在START时表示设置初始值，在STOP时表示清理active标志，这个标志表示计数器当前正在统计的事件编码。</li><li>A3为事件索引，格式由 SBI PMU 扩展定义。当A3为ival时表示要写入 counter 的值。</li><li>A4&#x2F;A5在HW事件中未使用；</li><li>A6是 SBI PMU 扩展定义的功能</li><li>A7是固定值，表示ecall触发PMU事件。</li></ul><p>结合代码和调试，perf 命令并未使用 cycle 和 instret 计数器，而是使用 HPM 来实现 cycles 和 instructions 计数，这是因为 xuantie 实现了 sscofpmf 扩展，在这种情况下 opensbi 会优先选择 HPM 计数器。</p><p>因此，整个过程：</p><ol><li>从最后一个计数器开始，搜索可用于 <strong>cycles</strong> 事件的 HPM, 当搜索到 HPM 后，根据传入的 event_idx 从设备树上找到 mhpmevent 的配置值，然后更新 mhpmevent, 若 sscof 扩展支持，需要根据 flag 设置中断溢出 OF 和 INH 字段。最后返回索引值。</li><li>使用第一步返回的索引，设置 mhpmcounter 和 mcountinhibit 寄存器。counter 初始值由 os 下发，根据 flag 决定是否进行初始化。最后启动计数器。</li><li>重复第一、二步，但事件换成 <strong>instructions</strong> 事件。</li><li>Perf 执行完后，发出 STOP 的 ecall 信号(A6&#x3D;4)，并将 phs-&gt;active_events[idx] 标志清除。</li></ol><p>上述过程是最简单的事件统计，当执行 <code>perf stat sleep 1s</code> 这种需要长时间完成的命令时，会因为cpu的时间片到期反复执行上述 <code>cfg_match -&gt; start -&gt; stop</code> 过程，而且 os 还会矫正更新时间，过程更加复杂。</p>]]></content>
      
      
      <categories>
          
          <category> Perf </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RISC-V </tag>
            
            <tag> Perf </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux Perf 介绍 —— Perf 内核及驱动支持</title>
      <link href="/2025/08/26/Linux-Perf-%E4%BB%8B%E7%BB%8D-%E2%80%94%E2%80%94-Perf-%E5%86%85%E6%A0%B8%E5%8F%8A%E9%A9%B1%E5%8A%A8%E6%94%AF%E6%8C%81/"/>
      <url>/2025/08/26/Linux-Perf-%E4%BB%8B%E7%BB%8D-%E2%80%94%E2%80%94-Perf-%E5%86%85%E6%A0%B8%E5%8F%8A%E9%A9%B1%E5%8A%A8%E6%94%AF%E6%8C%81/</url>
      
        <content type="html"><![CDATA[<h1 id="系列目录"><a href="#系列目录" class="headerlink" title="系列目录"></a>系列目录</h1><hr><p><a href="http://localhost:4000/2025/08/21/Linux-Perf-%E4%BB%8B%E7%BB%8D-%E2%80%94%E2%80%94-Perf-%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/">Linux Perf 介绍 —— Perf 命令行工具</a><br><a href="http://localhost:4000/2025/08/21/Linux-Perf-%E4%BB%8B%E7%BB%8D-%E2%80%94%E2%80%94-Perf-%E5%B7%A5%E5%85%B7%E8%B0%83%E7%94%A8%E5%88%86%E6%9E%90/">Linux Perf 介绍-—— Perf 工具调用分析</a><br><a href="http://localhost:4000/2025/08/26/Linux-Perf-%E4%BB%8B%E7%BB%8D-%E2%80%94%E2%80%94-Perf-%E5%86%85%E6%A0%B8%E5%8F%8A%E9%A9%B1%E5%8A%A8%E6%94%AF%E6%8C%81/">Linux Perf 介绍 —— Perf 内核及驱动支持</a><br><a href="http://localhost:4000/2025/08/26/Linux-Perf-%E4%BB%8B%E7%BB%8D-%E2%80%94%E2%80%94-Perf-opensbi-%E6%94%AF%E6%8C%81/">Linux Perf 介绍 —— Perf opensbi 支持</a><br><a href="http://localhost:4000/2025/08/26/Linux-Perf-%E4%BB%8B%E7%BB%8D-%E2%80%94%E2%80%94-Perf-%E6%80%BB%E7%BB%93/">Linux Perf 介绍 —— Perf 总结</a></p><h1 id="Linux-Perf-初始化"><a href="#Linux-Perf-初始化" class="headerlink" title="Linux Perf 初始化"></a>Linux Perf 初始化</h1><hr><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">start_kernel</span><br><span class="line">  -&gt; perf_event_init  <span class="comment">// 初始化 PMU 框架，注册软件和硬件事件源，构建性能事件的内存缓存，验证关键数据结构的内存布局</span></span><br><span class="line">  -&gt; arch_call_rest_init</span><br><span class="line">    -&gt; rest_init</span><br><span class="line">      -&gt; kernel_init</span><br><span class="line">        -&gt; kernel_init_freeable</span><br><span class="line">          -&gt; do_basic_setup</span><br><span class="line">            -&gt; do_initcalls</span><br><span class="line">              -&gt; do_initcall_level</span><br><span class="line">                -&gt; do_one_initcall</span><br><span class="line">                  -&gt; fn (pmu_sbi_devinit) <span class="comment">// PMU 驱动初始化</span></span><br><span class="line">                    -&gt; sbi_probe_extension <span class="comment">// SBI PMU 扩展检测，验证固件是否支持 PMU 扩展</span></span><br><span class="line">                    -&gt; cpuhp_setup_state_multi <span class="comment">// CPU 热插拔回调注册：设置 CPU 上线/下线时的 PMU 配置钩子</span></span><br><span class="line">                    -&gt; platform_driver_register <span class="comment">// 平台驱动注册：为 SBI PMU 注册平台设备</span></span><br><span class="line">                    -&gt; platform_device_register_simple <span class="comment">// 平台驱动注册：为 SBI PMU 注册平台驱动</span></span><br><span class="line">                      -&gt; platform_device_register_resndata</span><br><span class="line">                        -&gt; platform_device_register_full</span><br><span class="line">                          -&gt; platform_device_alloc <span class="comment">// 分配并初始化一个 platform_device 结构体，设置基础名称和ID</span></span><br><span class="line">                          -&gt; platform_device_add_resources <span class="comment">// 资源（内存、IRQ等）关联</span></span><br><span class="line">                          -&gt; platform_device_add_data <span class="comment">// 平台数据绑定</span></span><br><span class="line">                          -&gt; device_create_managed_software_node <span class="comment">// 动态创建设备属性，属性自动随设备释放</span></span><br><span class="line">                          -&gt; platform_device_add  <span class="comment">// 设备注册</span></span><br><span class="line">                            -&gt; device_add</span><br><span class="line">                              -&gt; bus_probe_device</span><br><span class="line">                                -&gt; device_initial_probe</span><br><span class="line">                                  -&gt; __device_attach</span><br><span class="line">                                    -&gt; bus_for_each_drv</span><br><span class="line">                                      -&gt; fn (__device_attach_driver)</span><br><span class="line">                                        -&gt; driver_probe_device</span><br><span class="line">                                          -&gt; __driver_probe_device</span><br><span class="line">                                            -&gt; really_probe</span><br><span class="line">                                              -&gt; call_driver_probe</span><br><span class="line">                                                -&gt; dev-&gt;bus-&gt;probe (platform_probe)</span><br><span class="line">                                                  -&gt; drv-&gt;probe (pmu_sbi_device_probe)</span><br><span class="line"></span><br><span class="line">pmu_sbi_device_probe <span class="comment">//  RISC-V SBI PMU 驱动的 探测（Probe）入口</span></span><br><span class="line">  -&gt; riscv_pmu_alloc <span class="comment">// 分配并初始化 struct riscv_pmu 结构体，包含 PMU 的通用属性和操作函数</span></span><br><span class="line">    -&gt; pmu=kzalloc  <span class="comment">// 为 struct riscv_pmu 分配内存</span></span><br><span class="line">    -&gt; pmu-&gt;hw_events = alloc_percpu_gfp <span class="comment">// 为每个 CPU 分配硬件事件跟踪结构</span></span><br><span class="line">    -&gt; per_cpu_ptr <span class="comment">// 遍历所有可能存在的 CPU（包括离线 CPU）,初始化数据</span></span><br><span class="line">    -&gt; pmu-&gt;pmu-&gt;* = riscv_pmu_* <span class="comment">//PMU 操作回调绑定</span></span><br><span class="line">  -&gt; pmu_sbi_find_num_ctrs <span class="comment">// 通过 SBI 调用（如 sbi_pmu_num_ctr()）获取硬件计数器数量</span></span><br><span class="line">  -&gt; pmu_sbi_get_ctrinfo <span class="comment">// 获取所有计数器的csr地址，宽度，事件类型等计数器信息，mask等</span></span><br><span class="line">  -&gt; pmu_sbi_setup_irqs <span class="comment">// 配置中断，sscof扩展不支持时，不支持 perf 采样和过滤</span></span><br><span class="line">  -&gt; pmu-&gt;* = pmu_sbi_*       <span class="comment">// PMU 操作函数绑定, 每个操作最终通过ecall触发SBI调用</span></span><br><span class="line">  -&gt; cpuhp_state_add_instance <span class="comment">// 将当前 PMU 实例添加到 CPU 热插拔回调列表，确保 CPU 上线/下线时正确配置计数器</span></span><br><span class="line">  -&gt; riscv_pm_pmu_register <span class="comment">// 全局注册 struct riscv_pmu *pmu</span></span><br></pre></td></tr></table></figure><p>从代码上看，perf 的初始化分2部分，<code>perf_event_init</code>和<code>pmu_sbi_device_probe</code>. <code>perf_event_init</code> 主要完成高层次的初始化，如注册FW，HW，SW等事件源；而<code>pmu_sbi_device_probe</code> 主要完成底层的初始化，如操作绑定，每个cpu数据初始化等。</p><p>具体操作绑定如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">pmu-&gt;pmu.attr_groups = riscv_pmu_attr_groups;</span><br><span class="line">pmu-&gt;cmask = cmask;</span><br><span class="line">pmu-&gt;ctr_start = pmu_sbi_ctr_start;</span><br><span class="line">pmu-&gt;ctr_stop = pmu_sbi_ctr_stop;</span><br><span class="line">pmu-&gt;event_map = pmu_sbi_event_map;</span><br><span class="line">pmu-&gt;ctr_get_idx = pmu_sbi_ctr_get_idx;</span><br><span class="line">pmu-&gt;ctr_get_width = pmu_sbi_ctr_get_width;</span><br><span class="line">pmu-&gt;ctr_clear_idx = pmu_sbi_ctr_clear_idx;</span><br><span class="line">pmu-&gt;ctr_read = pmu_sbi_ctr_read;</span><br><span class="line">pmu-&gt;event_init = pmu_sbi_event_init;</span><br><span class="line">pmu-&gt;event_mapped = pmu_sbi_event_mapped;</span><br><span class="line">pmu-&gt;event_unmapped = pmu_sbi_event_unmapped;</span><br><span class="line">pmu-&gt;csr_index = pmu_sbi_csr_index;</span><br><span class="line"></span><br><span class="line">pmu-&gt;pmu = (<span class="keyword">struct</span> pmu) &#123;</span><br><span class="line">.event_init= riscv_pmu_event_init,</span><br><span class="line">.event_mapped= riscv_pmu_event_mapped,</span><br><span class="line">.event_unmapped= riscv_pmu_event_unmapped,</span><br><span class="line">.event_idx= riscv_pmu_event_idx,</span><br><span class="line">.add= riscv_pmu_add,</span><br><span class="line">.del= riscv_pmu_del,</span><br><span class="line">.start= riscv_pmu_start,</span><br><span class="line">.stop= riscv_pmu_stop,</span><br><span class="line">.read= riscv_pmu_read,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>通过对这些函数追踪可以观察到函数的调用关系和Perf的执行流程，以及ecall的调用来源。</p><h1 id="Linux-Perf-响应"><a href="#Linux-Perf-响应" class="headerlink" title="Linux Perf 响应"></a>Linux Perf 响应</h1><hr><p>在执行命令时，首先是通过 <strong>perf_event_open</strong> 创建计数器事件的文件描述符用于测量性能信息。由于不与PMU发生交互，此处省略。后续描述是 Perf write 系统调用时涉及到的执行过程。</p><p>执行命令<code>perf stat -e cycles,instructions date &gt; /dev/null</code>，通过配置 <code>pmu_sbi_ctr_*</code> 和 <code>riscv_pmu_ctr_read*</code> 到 set_ftrace_filter 并打开堆栈选项，执行ftrace，生成日志 <a href="trace.function">trace.function</a>；通过配置 <code>riscv_pmu_s*</code> 到 set_graph_function 生成日志 <a href="trace.graph">trace.graph</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// trace.function</span></span><br><span class="line">            date<span class="number">-262</span>     [<span class="number">001</span>] d..<span class="number">2.</span>   <span class="number">911.415279</span>: pmu_sbi_ctr_get_idx &lt;-riscv_pmu_add</span><br><span class="line">            date<span class="number">-262</span>     [<span class="number">001</span>] d..<span class="number">2.</span>   <span class="number">911.415302</span>: &lt;<span class="built_in">stack</span> trace&gt;</span><br><span class="line"> =&gt; ftrace_call</span><br><span class="line"> =&gt; event_sched_in</span><br><span class="line"> =&gt; merge_sched_in</span><br><span class="line"> =&gt; visit_groups_merge.constprop.<span class="number">0.</span>isra.<span class="number">0</span></span><br><span class="line"> =&gt; ctx_groups_sched_in</span><br><span class="line"> =&gt; ctx_sched_in</span><br><span class="line"> =&gt; ctx_resched</span><br><span class="line"> =&gt; perf_event_exec</span><br><span class="line"> =&gt; begin_new_exec</span><br><span class="line"> =&gt; load_elf_binary</span><br><span class="line"> =&gt; bprm_execve</span><br><span class="line"> =&gt; do_execveat_common.isra.<span class="number">0</span></span><br><span class="line"> =&gt; __riscv_sys_execve</span><br><span class="line"> =&gt; do_trap_ecall_u</span><br><span class="line"> =&gt; ret_from_exception</span><br><span class="line">            date<span class="number">-262</span>     [<span class="number">001</span>] d..<span class="number">2.</span>   <span class="number">911.416165</span>: pmu_sbi_ctr_start &lt;-riscv_pmu_start</span><br><span class="line">            date<span class="number">-262</span>     [<span class="number">001</span>] d..<span class="number">2.</span>   <span class="number">911.416173</span>: &lt;<span class="built_in">stack</span> trace&gt;</span><br><span class="line"> =&gt; ftrace_call</span><br><span class="line"> =&gt; riscv_pmu_add</span><br><span class="line"> =&gt; event_sched_in</span><br><span class="line"> =&gt; merge_sched_in</span><br><span class="line"> =&gt; visit_groups_merge.constprop.<span class="number">0.</span>isra.<span class="number">0</span></span><br><span class="line"> =&gt; ctx_groups_sched_in</span><br><span class="line"> =&gt; ctx_sched_in</span><br><span class="line"> =&gt; ctx_resched</span><br><span class="line"> =&gt; perf_event_exec</span><br><span class="line"> =&gt; begin_new_exec</span><br><span class="line"> =&gt; load_elf_binary</span><br><span class="line"> =&gt; bprm_execve</span><br><span class="line"> =&gt; do_execveat_common.isra.<span class="number">0</span></span><br><span class="line"> =&gt; __riscv_sys_execve</span><br><span class="line"> =&gt; do_trap_ecall_u</span><br><span class="line"> =&gt; ret_from_exception</span><br><span class="line"><span class="comment">// trace.graph</span></span><br><span class="line"> <span class="number">1</span>)               |  riscv_pmu_add() &#123;</span><br><span class="line"> <span class="number">1</span>) + <span class="number">14.300</span> us   |    pmu_sbi_ctr_get_idx();</span><br><span class="line"> <span class="number">1</span>)               |    riscv_pmu_start() &#123;</span><br><span class="line"> <span class="number">1</span>)   <span class="number">2.300</span> us    |      pmu_sbi_ctr_get_width();</span><br><span class="line"> <span class="number">1</span>)               |      riscv_pmu_event_set_period() &#123;</span><br><span class="line"> <span class="number">1</span>)   <span class="number">2.200</span> us    |        pmu_sbi_ctr_get_width();</span><br><span class="line"> <span class="number">1</span>)   <span class="number">2.300</span> us    |        perf_event_update_userpage();</span><br><span class="line"> <span class="number">1</span>) + <span class="number">11.700</span> us   |      &#125;</span><br><span class="line"> <span class="number">1</span>)   <span class="number">6.800</span> us    |      pmu_sbi_ctr_start();</span><br><span class="line"> <span class="number">1</span>)   <span class="number">2.300</span> us    |      perf_event_update_userpage();</span><br><span class="line"> <span class="number">1</span>) + <span class="number">35.500</span> us   |    &#125;</span><br><span class="line"> <span class="number">1</span>)   <span class="number">2.300</span> us    |    perf_event_update_userpage();</span><br><span class="line"> <span class="number">1</span>) + <span class="number">62.200</span> us   |  &#125;</span><br><span class="line"> <span class="number">1</span>)               |  riscv_pmu_del() &#123;</span><br><span class="line"> <span class="number">1</span>)               |    riscv_pmu_stop() &#123;</span><br><span class="line"> <span class="number">1</span>) + <span class="number">17.800</span> us   |      pmu_sbi_ctr_stop();</span><br><span class="line"> <span class="number">1</span>)               |      riscv_pmu_event_update() &#123;</span><br><span class="line"> <span class="number">1</span>)   <span class="number">3.600</span> us    |        pmu_sbi_ctr_get_width();</span><br><span class="line"> <span class="number">1</span>)               |        pmu_sbi_ctr_read() &#123;</span><br><span class="line"> <span class="number">1</span>)   <span class="number">7.000</span> us    |          riscv_pmu_ctr_read_csr();</span><br><span class="line"> <span class="number">1</span>) + <span class="number">47.400</span> us   |        &#125;</span><br><span class="line"> <span class="number">1</span>) + <span class="number">60.900</span> us   |      &#125;</span><br><span class="line"> <span class="number">1</span>) + <span class="number">90.000</span> us   |    &#125;</span><br><span class="line"> <span class="number">1</span>)   <span class="number">9.400</span> us    |    pmu_sbi_ctr_stop();</span><br><span class="line"> <span class="number">1</span>)   <span class="number">3.100</span> us    |    pmu_sbi_ctr_clear_idx();</span><br><span class="line"> <span class="number">1</span>)   <span class="number">2.900</span> us    |    perf_event_update_userpage();</span><br><span class="line"> <span class="number">1</span>) ! <span class="number">130.400</span> us  |  &#125;</span><br></pre></td></tr></table></figure><ul><li>pmu_sbi_ctr_get_idx: 通过 ecall 获取某个事件的可用计数器索引并设置mhpmevent，通过 gdb 调试可知，这个索引指向事件的最大可用计数器编号，如31（mhpmcounter31）;</li><li>pmu_sbi_ctr_get_width: 获取计数器宽度，如64位，在初始化时已经通过 ecall 获取了，所以这里是软件行为；</li><li>pmu_sbi_ctr_start: 通过 ecall 启动计数器，参数为计数器索引和计数器初始化值；</li><li>perf_event_update_userpage：时间矫正，更新用户空间映射的性能事件数据页（perf_event_mmap_page），确保用户态工具（如 perf）能实时读取事件计数器值、累计启用&#x2F;运行时间等；</li><li>riscv_pmu_ctr_read_csr: 从S模式直接读取CSR寄存器从而获取计数值。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Perf </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RISC-V </tag>
            
            <tag> Perf </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux Perf 介绍 —— Perf 工具调用分析</title>
      <link href="/2025/08/21/Linux-Perf-%E4%BB%8B%E7%BB%8D-%E2%80%94%E2%80%94-Perf-%E5%B7%A5%E5%85%B7%E8%B0%83%E7%94%A8%E5%88%86%E6%9E%90/"/>
      <url>/2025/08/21/Linux-Perf-%E4%BB%8B%E7%BB%8D-%E2%80%94%E2%80%94-Perf-%E5%B7%A5%E5%85%B7%E8%B0%83%E7%94%A8%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="系列目录"><a href="#系列目录" class="headerlink" title="系列目录"></a>系列目录</h1><hr><p><a href="http://localhost:4000/2025/08/21/Linux-Perf-%E4%BB%8B%E7%BB%8D-%E2%80%94%E2%80%94-Perf-%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/">Linux Perf 介绍 —— Perf 命令行工具</a><br><a href="http://localhost:4000/2025/08/21/Linux-Perf-%E4%BB%8B%E7%BB%8D-%E2%80%94%E2%80%94-Perf-%E5%B7%A5%E5%85%B7%E8%B0%83%E7%94%A8%E5%88%86%E6%9E%90/">Linux Perf 介绍-—— Perf 工具调用分析</a><br><a href="http://localhost:4000/2025/08/26/Linux-Perf-%E4%BB%8B%E7%BB%8D-%E2%80%94%E2%80%94-Perf-%E5%86%85%E6%A0%B8%E5%8F%8A%E9%A9%B1%E5%8A%A8%E6%94%AF%E6%8C%81/">Linux Perf 介绍 —— Perf 内核及驱动支持</a><br><a href="http://localhost:4000/2025/08/26/Linux-Perf-%E4%BB%8B%E7%BB%8D-%E2%80%94%E2%80%94-Perf-opensbi-%E6%94%AF%E6%8C%81/">Linux Perf 介绍 —— Perf opensbi 支持</a><br><a href="http://localhost:4000/2025/08/26/Linux-Perf-%E4%BB%8B%E7%BB%8D-%E2%80%94%E2%80%94-Perf-%E6%80%BB%E7%BB%93/">Linux Perf 介绍 —— Perf 总结</a></p><h1 id="Perf-命令"><a href="#Perf-命令" class="headerlink" title="Perf 命令"></a>Perf 命令</h1><hr><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">usage: perf [--version] [--help] [OPTIONS] COMMAND [ARGS]</span><br><span class="line"></span><br><span class="line">The most commonly used perf commands are:</span><br><span class="line">  annotate        Read perf.data (created by perf record) and display annotated code</span><br><span class="line">  archive         Create archive with object files with build-ids found in perf.data file</span><br><span class="line">  bench           General framework for benchmark suites</span><br><span class="line">  buildid-cache   Manage build-id cache.</span><br><span class="line">  buildid-list    List the buildids in a perf.data file</span><br><span class="line">  c2c             Shared Data C2C/HITM Analyzer.</span><br><span class="line">  config          Get and set variables in a configuration file.</span><br><span class="line">  daemon          Run record sessions on background</span><br><span class="line">  data            Data file related processing</span><br><span class="line">  diff            Read perf.data files and display the differential profile</span><br><span class="line">  evlist          List the event names in a perf.data file</span><br><span class="line">  ftrace          simple wrapper for kernel&#x27;s ftrace functionality</span><br><span class="line">  inject          Filter to augment the events stream with additional information</span><br><span class="line">  iostat          Show I/O performance metrics</span><br><span class="line">  kallsyms        Searches running kernel for symbols</span><br><span class="line">  kmem            Tool to trace/measure kernel memory properties</span><br><span class="line">  kvm             Tool to trace/measure kvm guest os</span><br><span class="line">  list            List all symbolic event types</span><br><span class="line">  lock            Analyze lock events</span><br><span class="line">  mem             Profile memory accesses</span><br><span class="line">  record          Run a command and record its profile into perf.data</span><br><span class="line">  report          Read perf.data (created by perf record) and display the profile</span><br><span class="line">  sched           Tool to trace/measure scheduler properties (latencies)</span><br><span class="line">  script          Read perf.data (created by perf record) and display trace output</span><br><span class="line">  stat            Run a command and gather performance counter statistics</span><br><span class="line">  test            Runs sanity tests.</span><br><span class="line">  timechart       Tool to visualize total system behavior during a workload</span><br><span class="line">  top             System profiling tool.</span><br><span class="line">  version         display the version of perf binary</span><br><span class="line">  probe           Define new dynamic tracepoints</span><br><span class="line">  trace           strace inspired tool</span><br><span class="line"></span><br><span class="line">See &#x27;perf help COMMAND&#x27; for more information on a specific command.</span><br></pre></td></tr></table></figure><p>每个命令对应的源码：<a href="https://elixir.bootlin.com/linux/v6.6.36/source/tools/perf/perf.c">tools&#x2F;perf&#x2F;perf.c:49</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">cmd_struct</span> <span class="title">commands</span>[] =</span> &#123;</span><br><span class="line">&#123; <span class="string">&quot;archive&quot;</span>,<span class="literal">NULL</span>,<span class="number">0</span> &#125;,</span><br><span class="line">&#123; <span class="string">&quot;buildid-cache&quot;</span>, cmd_buildid_cache, <span class="number">0</span> &#125;,</span><br><span class="line">&#123; <span class="string">&quot;buildid-list&quot;</span>, cmd_buildid_list, <span class="number">0</span> &#125;,</span><br><span class="line">&#123; <span class="string">&quot;config&quot;</span>,cmd_config,<span class="number">0</span> &#125;,</span><br><span class="line">&#123; <span class="string">&quot;c2c&quot;</span>,cmd_c2c,<span class="number">0</span> &#125;,</span><br><span class="line">&#123; <span class="string">&quot;diff&quot;</span>,cmd_diff,<span class="number">0</span> &#125;,</span><br><span class="line">&#123; <span class="string">&quot;evlist&quot;</span>,cmd_evlist,<span class="number">0</span> &#125;,</span><br><span class="line">&#123; <span class="string">&quot;help&quot;</span>,cmd_help,<span class="number">0</span> &#125;,</span><br><span class="line">&#123; <span class="string">&quot;iostat&quot;</span>,<span class="literal">NULL</span>,<span class="number">0</span> &#125;,</span><br><span class="line">&#123; <span class="string">&quot;kallsyms&quot;</span>,cmd_kallsyms,<span class="number">0</span> &#125;,</span><br><span class="line">&#123; <span class="string">&quot;list&quot;</span>,cmd_list,<span class="number">0</span> &#125;,</span><br><span class="line">&#123; <span class="string">&quot;record&quot;</span>,cmd_record,<span class="number">0</span> &#125;,</span><br><span class="line">&#123; <span class="string">&quot;report&quot;</span>,cmd_report,<span class="number">0</span> &#125;,</span><br><span class="line">&#123; <span class="string">&quot;bench&quot;</span>,cmd_bench,<span class="number">0</span> &#125;,</span><br><span class="line">&#123; <span class="string">&quot;stat&quot;</span>,cmd_stat,<span class="number">0</span> &#125;,</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> HAVE_LIBTRACEEVENT</span></span><br><span class="line">&#123; <span class="string">&quot;timechart&quot;</span>,cmd_timechart,<span class="number">0</span> &#125;,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#123; <span class="string">&quot;top&quot;</span>,cmd_top,<span class="number">0</span> &#125;,</span><br><span class="line">&#123; <span class="string">&quot;annotate&quot;</span>,cmd_annotate,<span class="number">0</span> &#125;,</span><br><span class="line">&#123; <span class="string">&quot;version&quot;</span>,cmd_version,<span class="number">0</span> &#125;,</span><br><span class="line">&#123; <span class="string">&quot;script&quot;</span>,cmd_script,<span class="number">0</span> &#125;,</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> HAVE_LIBTRACEEVENT</span></span><br><span class="line">&#123; <span class="string">&quot;sched&quot;</span>,cmd_sched,<span class="number">0</span> &#125;,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> HAVE_LIBELF_SUPPORT</span></span><br><span class="line">&#123; <span class="string">&quot;probe&quot;</span>,cmd_probe,<span class="number">0</span> &#125;,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> HAVE_LIBTRACEEVENT</span></span><br><span class="line">&#123; <span class="string">&quot;kmem&quot;</span>,cmd_kmem,<span class="number">0</span> &#125;,</span><br><span class="line">&#123; <span class="string">&quot;lock&quot;</span>,cmd_lock,<span class="number">0</span> &#125;,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#123; <span class="string">&quot;kvm&quot;</span>,cmd_kvm,<span class="number">0</span> &#125;,</span><br><span class="line">&#123; <span class="string">&quot;test&quot;</span>,cmd_test,<span class="number">0</span> &#125;,</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(HAVE_LIBTRACEEVENT) &amp;&amp; (defined(HAVE_LIBAUDIT_SUPPORT) || defined(HAVE_SYSCALL_TABLE_SUPPORT))</span></span><br><span class="line">&#123; <span class="string">&quot;trace&quot;</span>,cmd_trace,<span class="number">0</span> &#125;,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#123; <span class="string">&quot;inject&quot;</span>,cmd_inject,<span class="number">0</span> &#125;,</span><br><span class="line">&#123; <span class="string">&quot;mem&quot;</span>,cmd_mem,<span class="number">0</span> &#125;,</span><br><span class="line">&#123; <span class="string">&quot;data&quot;</span>,cmd_data,<span class="number">0</span> &#125;,</span><br><span class="line">&#123; <span class="string">&quot;ftrace&quot;</span>,cmd_ftrace,<span class="number">0</span> &#125;,</span><br><span class="line">&#123; <span class="string">&quot;daemon&quot;</span>,cmd_daemon,<span class="number">0</span> &#125;,</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> HAVE_LIBTRACEEVENT</span></span><br><span class="line">&#123; <span class="string">&quot;kwork&quot;</span>,cmd_kwork,<span class="number">0</span> &#125;,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>每个命令都对应一个C文件，在 tools&#x2F;perf 目录。</p><p>后续以 <strong>perf stat ls</strong> 为例进行分析。</p><h1 id="创建计数器"><a href="#创建计数器" class="headerlink" title="创建计数器"></a>创建计数器</h1><hr><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">perf_event_open</span><span class="params">(<span class="keyword">struct</span> perf_event_attr *attr,</span></span><br><span class="line"><span class="params">                    <span class="type">pid_t</span> pid,</span></span><br><span class="line"><span class="params">                    <span class="type">int</span> cpu,</span></span><br><span class="line"><span class="params">                    <span class="type">int</span> group_fd,</span></span><br><span class="line"><span class="params">                    <span class="type">unsigned</span> <span class="type">long</span> flags)</span>;</span><br></pre></td></tr></table></figure><p>perf_event_open() 是 Linux 提供的底层系统调用，用于 性能监控（Performance Monitoring），允许用户空间程序访问 CPU 硬件性能计数器（PMCs）、内核事件（如上下文切换、缺页异常）等。它是 perf 工具的核心实现基础。详细介绍参考<a href="https://man7.org/linux/man-pages/man2/perf_event_open.2.html">perf_event_open</a>。</p><p>perf_event_open() 返回一个文件描述符，用于后续系统调用（如 read(2)、mmap(2)、prctl(2)、fcntl(2) 等）。</p><p>调用 perf_event_open() 可创建一个文件描述符，用于测量性能信息。每个文件描述符对应一个被测量的事件；这些事件可以组合在一起同时测量多个事件。</p><p>事件可以通过两种方式启用和禁用：通过 ioctl(2)和通过 prctl(2)。当一个事件被禁用时，它不会被计数或产生溢出，但仍然存在并保持其计数值。</p><p>创建计数器的调用关系，以<a href="https://elixir.bootlin.com/linux/v6.6.36/source/tools/perf/perf.c">6.6.36</a>, <em>perf stat ls</em>为例(在432处调用的main)：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">perf.c:<span class="number">432</span>:main -&gt;</span><br><span class="line">  perf.c:<span class="number">535</span>:run_argv -&gt;</span><br><span class="line">    perf.c:<span class="number">419</span>:handle_internal_command -&gt;</span><br><span class="line">      perf.c:<span class="number">375</span>:run_builtin -&gt;</span><br><span class="line">        perf.c:<span class="number">322</span>:p-&gt;fn (cmd_stat) -&gt;</span><br><span class="line">          builtin_stat.c:<span class="number">2831</span>:run_perf_stat -&gt;</span><br><span class="line">            builtin_stat.c:<span class="number">960</span>:__run_perf_stat -&gt;</span><br><span class="line">              builtin_stat.c:<span class="number">745</span>:create_perf_stat_counter (evsel__open_per_thread-&gt;*-&gt;evsel__open_cpu) -&gt;</span><br><span class="line">                evsel.c:<span class="number">2073</span>:sys_perf_event_open -&gt;</span><br><span class="line">                  perf-sys.h:<span class="number">17</span>:syscall(__NR_perf_event_open, attr, pid, cpu, group_fd, flags);</span><br></pre></td></tr></table></figure><p>上述流程会反复执行，直到所有cpu&#x2F;events被遍历。此时不涉及PMU，是软件行为。</p><p>sys_perf_event_open 是一个包装函数，用于调用底层的 perf_event_open 系统调用。它通过 syscall 函数调用 __NR_perf_event_open，并传递上述参数。该函数的主要作用是打开一个性能事件，并返回一个文件描述符，用于后续的读取和控制。</p><p>__NR_perf_event_open 是一个系统调用号，用于标识 perf_event_open 系统调用。在 Linux 系统中，每个系统调用都有一个唯一的编号，__NR_perf_event_open 就是 perf_event_open 系统调用的编号。</p><h1 id="计数器计数"><a href="#计数器计数" class="headerlink" title="计数器计数"></a>计数器计数</h1><hr><p>调用过程：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">perf.c:<span class="number">432</span>:main -&gt;</span><br><span class="line">  perf.c:<span class="number">535</span>:run_argv -&gt;</span><br><span class="line">    perf.c:<span class="number">419</span>:handle_internal_command -&gt;</span><br><span class="line">      perf.c:<span class="number">375</span>:run_builtin -&gt;</span><br><span class="line">        perf.c:<span class="number">322</span>:p-&gt;fn (cmd_stat) -&gt;</span><br><span class="line">          builtin_stat.c:<span class="number">2831</span>:run_perf_stat -&gt;</span><br><span class="line">            builtin_stat.c:<span class="number">960</span>:__run_perf_stat -&gt;</span><br><span class="line">              builtin_stat.c:<span class="number">872</span>:evlist__start_workload -&gt;</span><br><span class="line">                evlist.c:<span class="number">1537</span>:write(evlist-&gt;workload_fd, &amp;bf, <span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>write是系统调用, 向 cork_fd 写入一个字节（bf），表示父进程已经准备好，子进程可以开始执行。结合os分析，就是先配置计数器然后再执行 perf 命令，最后关闭计数器。在 <code>builtin_stat.c:934:read_counters</code> 会更新统计结果。</p><h1 id="打印结果"><a href="#打印结果" class="headerlink" title="打印结果"></a>打印结果</h1><hr><p>调用过程：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">perf.c:<span class="number">432</span>:main -&gt;</span><br><span class="line">  perf.c:<span class="number">535</span>:run_argv -&gt;</span><br><span class="line">    perf.c:<span class="number">419</span>:handle_internal_command -&gt;</span><br><span class="line">      perf.c:<span class="number">375</span>:run_builtin -&gt;</span><br><span class="line">        perf.c:<span class="number">322</span>:p-&gt;fn (cmd_stat) -&gt;</span><br><span class="line">          builtin_stat.c:<span class="number">2841</span>:print_counters</span><br></pre></td></tr></table></figure><p>从 run_perf_stat 退出后，会调用 print_counters 函数，打印结果。</p><p>如下，是执行<code>perf stat ls</code>的打印结果<br><img src="/image.png"></p>]]></content>
      
      
      <categories>
          
          <category> Perf </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RISC-V </tag>
            
            <tag> Perf </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux Perf 介绍 —— Perf 命令行工具</title>
      <link href="/2025/08/21/Linux-Perf-%E4%BB%8B%E7%BB%8D-%E2%80%94%E2%80%94-Perf-%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/"/>
      <url>/2025/08/21/Linux-Perf-%E4%BB%8B%E7%BB%8D-%E2%80%94%E2%80%94-Perf-%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<h1 id="系列目录"><a href="#系列目录" class="headerlink" title="系列目录"></a>系列目录</h1><hr><p><a href="http://localhost:4000/2025/08/21/Linux-Perf-%E4%BB%8B%E7%BB%8D-%E2%80%94%E2%80%94-Perf-%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/">Linux Perf 介绍 —— Perf 命令行工具</a><br><a href="http://localhost:4000/2025/08/21/Linux-Perf-%E4%BB%8B%E7%BB%8D-%E2%80%94%E2%80%94-Perf-%E5%B7%A5%E5%85%B7%E8%B0%83%E7%94%A8%E5%88%86%E6%9E%90/">Linux Perf 介绍-—— Perf 工具调用分析</a><br><a href="http://localhost:4000/2025/08/26/Linux-Perf-%E4%BB%8B%E7%BB%8D-%E2%80%94%E2%80%94-Perf-%E5%86%85%E6%A0%B8%E5%8F%8A%E9%A9%B1%E5%8A%A8%E6%94%AF%E6%8C%81/">Linux Perf 介绍 —— Perf 内核及驱动支持</a><br><a href="http://localhost:4000/2025/08/26/Linux-Perf-%E4%BB%8B%E7%BB%8D-%E2%80%94%E2%80%94-Perf-opensbi-%E6%94%AF%E6%8C%81/">Linux Perf 介绍 —— Perf opensbi 支持</a><br><a href="http://localhost:4000/2025/08/26/Linux-Perf-%E4%BB%8B%E7%BB%8D-%E2%80%94%E2%80%94-Perf-%E6%80%BB%E7%BB%93/">Linux Perf 介绍 —— Perf 总结</a></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><hr><ul><li><a href="https://man7.org/linux/man-pages/man2/perf_event_open.2.html">perf_event_open系统函数</a>, 介绍 Linux Perf 子系统的接口定义。</li><li><a href="https://www.kernel.org/doc/html/v6.16/trace/tracepoint-analysis.html">kernel tracepoint</a>, linux Perf 子系统提供的事件跟踪能力，属于软件事件，其他能力包括PMU硬件事件。</li><li><a href="https://perfwiki.github.io/main">linux perf 官方文档</a></li><li><a href="https://www.brendangregg.com/linuxperf.html">非常优秀的 Linux Perf 读物</a></li></ul><p>Perf 命令行工具由 linux kernel 目录下的 tools&#x2F;perf 独立编译生成。用于性能观察和采集。perf_event_open 帮助文档中介绍了 <strong>Events</strong> 的类型，计数型和采集型。详细事件定义时以 PERF_COUNT_ 和  PERF_SAMPLE_ 开头。代码中对 <strong>Events</strong> 的分类主要有：</p><ul><li>PERF_TYPE_HARDWARE ：通用硬件事件，PMU</li><li>PERF_TYPE_SOFTWARE ：软件定义事件</li><li>PERF_TYPE_TRACEPOINT ：内核跟踪点基础设施提供的跟踪点事件</li><li>PERF_TYPE_HW_CACHE ：硬件缓存事件，PMU</li><li>PERF_TYPE_RAW ：PMU提供的 raw 事件，Perf提供的硬件事件接口非常有限，PMU支持的大多数都由raw事件来实现</li><li>PERF_TYPE_BREAKPOINT ：触发器提供断点</li></ul><p>每种类型又可具体定义。上述事件类型是 linux kernel 提供的核心层实现。通过 perf list 命令可以看到类似 <strong>[Hardware event]</strong> 字样用来区分这些类型。</p><h1 id="Perf-命令"><a href="#Perf-命令" class="headerlink" title="Perf 命令"></a>Perf 命令</h1><hr><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">perf -h  # 显示perf工具提供的所有子命令</span><br><span class="line">man perf # 显示perf的帮助文档</span><br><span class="line">perf subcmd -h # 显示子命令的帮助文档, 如 perf stat -h 会显示stat相关的命令选项</span><br><span class="line">man perf subcmd # 显示子命令的完整帮助文档。</span><br><span class="line">perf list # 列出perf支持的所有事件列表</span><br><span class="line">perf list &#x27;sched:*&#x27;</span><br></pre></td></tr></table></figure><h1 id="Linux-Perf-实现"><a href="#Linux-Perf-实现" class="headerlink" title="Linux Perf 实现"></a>Linux Perf 实现</h1><hr><table><thead><tr><th align="left">目录</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">tools&#x2F;perf&#x2F;</td><td align="left">用户空间的 perf 工具实现（核心命令和脚本）。</td></tr><tr><td align="left">kernel&#x2F;events&#x2F;</td><td align="left">内核中的 perf_event 子系统（事件管理和缓冲区）。</td></tr><tr><td align="left">arch&#x2F;riscv&#x2F;kernel&#x2F;perf_event*.c</td><td align="left">架构相关的性能计数器支持。</td></tr><tr><td align="left">include&#x2F;linux&#x2F;perf_event.h</td><td align="left">内核内部使用的 perf 数据结构和接口。</td></tr><tr><td align="left">include&#x2F;uapi&#x2F;linux&#x2F;perf_event.h</td><td align="left">用户空间 API 定义（perf_event_open 参数和常量）。</td></tr><tr><td align="left">kernel&#x2F;trace&#x2F;trace_event_perf.c</td><td align="left">集成 ftrace 跟踪点与 perf。</td></tr><tr><td align="left">samples&#x2F;bpf&#x2F;</td><td align="left">eBPF 与 perf 结合的示例代码。</td></tr><tr><td align="left">Documentation&#x2F;admin-guide&#x2F;perf&#x2F;</td><td align="left">官方文档（配置和使用指南）。</td></tr><tr><td align="left">tools&#x2F;lib&#x2F;perf&#x2F;</td><td align="left">libperf 库，支持其他工具调用 perf 功能。</td></tr><tr><td align="left">drivers&#x2F;perf</td><td align="left">PMU 驱动。</td></tr></tbody></table><h1 id="RISCV-Linux-Perf-架构"><a href="#RISCV-Linux-Perf-架构" class="headerlink" title="RISCV Linux Perf 架构"></a>RISCV Linux Perf 架构</h1><hr><p>RISC-V 对 perf 的支持涉及以下软&#x2F;硬件的框架&#x2F;规范：</p><ul><li>perf 框架主体，包括kernel支持，perf驱动，pmu驱动，perf应用，pmu设备树等，还包括pmu-events json文件，这允许perf工具以名字来指定平台支持的特定事件（tools&#x2F;perf&#x2F;pmu-events&#x2F;arch&#x2F;riscv）;</li><li>SBI PMU Extension;</li><li>RISC-V 硬件规范，包括 Zihpm, HPE, Sscofpmf, sstc 等；</li></ul><p>其关系如下：</p><p><img src="/perf-framework-riscv.png"></p><p><u>PMU events 由 SBI 程序（如opensbi）通过设备树读取并传递到 linux Perf 框架，设备树提供计数器数量，每个计数器支持的事件编码范围等信息，确保内核正确操作硬件。Json文件提供的事件的具体定义，包括名称、编码、描述等，在编译perf工具时 事件由tools&#x2F;perf&#x2F;util&#x2F;pmu.c 解析 JSON 文件生成事件表，json文件是脱离PMU硬件的事件定义，使用哪个HPM来完成事件是由设备树指定的</u>。</p><p><strong>必须指出的是</strong>，perf list 列出的事件表不一定都支持，具体需要看设备树和JSON文件是否有定义。通常而言，perf list 列出的事件表分为2部分：标准事件表和平台特定事件表(raw event)。主要区分是，perf list 列出的标准事件表通常包括事件名称和用方括号在同一行标出的事件类型，这很容易辨认。而平台特定事件，即JSON列出的事件，在tools&#x2F;perf&#x2F;pmu-event&#x2F;arch&#x2F;riscv&#x2F;目录下。比对 perf list 列出的事件和Json文件中定义的事件便很容易发现他们是完全相同的。举例如下，</p><p>在zen3 平台下的perf list 部分截图如下，msr&#x2F;tsc这些是x86下的kernel PMU event 类型标准事件，虽然perf list有列出，但是否真实支持还需要通过设备树确认，而branch: 之后的事件和 tools&#x2F;perf&#x2F;pmu-event&#x2F;arch&#x2F;x86&#x2F;amdzen3 下json文件的定义完全相同。</p><p><img src="/perf-list.png"> <img src="/json.png"></p>]]></content>
      
      
      <categories>
          
          <category> Perf </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RISC-V </tag>
            
            <tag> Perf </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RISC-V 性能计数器简介</title>
      <link href="/2025/07/30/RISC-V-%E6%80%A7%E8%83%BD%E8%AE%A1%E6%95%B0%E5%99%A8%E7%AE%80%E4%BB%8B/"/>
      <url>/2025/07/30/RISC-V-%E6%80%A7%E8%83%BD%E8%AE%A1%E6%95%B0%E5%99%A8%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><hr><p>Zihpm 扩展提供了29个标准的性能事件计数器。HPE(Hart performance events)扩展定义了一组标准性能事件，用于与 Zihpm 计数器配合使用。对于每种标准事件，都指定了名称及其与之关联的精确硬件行为。对于少数标准事件，指定了标准事件选择编码，而对于其他事件，则由实现定义编码。</p><h1 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h1><hr><p><strong>事件</strong> <strong>event</strong> 被定义组织成<strong>组</strong> <strong>group</strong> 形式。<strong>组</strong>中定义了<strong>子事件</strong> <strong>sub-events</strong>. 这些子事件限制了计数的内容。</p><p>事件被分为推测性（speculative）和非推测性（non-speculative）的，分别用<code>.RET</code>和<code>.SPEC</code>表示。<code>.RET</code>事件在退休时进行计数，而<code>.SPEC</code>事件可能包括由不退休指令引发的事件。非推测性事件<code>.RET</code>被定义如下。</p><h2 id="INST-Events"><a href="#INST-Events" class="headerlink" title="INST Events"></a>INST Events</h2><hr><p>指令事件是顶层级别的事件，包含子事件类别，当指令事件名称不包含子事件类别（<code>INST.RET</code>）时表示统计所有指令事件。</p><table><thead><tr><th>指令事件分类</th><th>描述</th></tr></thead><tbody><tr><td>BRJMP</td><td>分支和跳转指令。包括所有 BRANCH, JAL, 和 JALR 操作码，包括压缩版本</td></tr><tr><td>MISPRED</td><td>分支和跳转指令的预测错误</td></tr><tr><td>LOAD</td><td>内存加载指令。包括所有执行<strong>内存读操作</strong>的指令</td></tr><tr><td>STORE</td><td>内存存储指令。包括所有执行<strong>内存写操作</strong>的指令</td></tr><tr><td>LDST</td><td>内存加载和存储指令。代表 LOAD 和 STORE 类别的并集</td></tr><tr><td>MO</td><td>内存排序指令。包括 FENCE 和 FENCE.TSO 指令</td></tr><tr><td>INT</td><td>整数计算指令。包括所有来自 RVxI 的整数计算指令，包括压缩版本。还包括来自 M 扩展和 A 扩展（AMO*）的所有计算指令。是否将 NOP 指令计入其中由实现定义</td></tr><tr><td>FP</td><td>浮点指令。包括来自 F、D、Q 和 Zfa 扩展的所有指令。</td></tr><tr><td>RVV</td><td>向量指令。包括来自 V 扩展的所有指令</td></tr><tr><td>RVC</td><td>压缩指令。包括来自 C 扩展的所有指令</td></tr></tbody></table><h3 id="控制转移指令事件"><a href="#控制转移指令事件" class="headerlink" title="控制转移指令事件"></a>控制转移指令事件</h3><hr><p>控制转移(control transfer)指令类别 <strong>BRJMP</strong> 和 <strong>MISPRED</strong> 包括额外的层次结构，允许按转移指令类型进行计数。当事件名称中未包含类型（例如：INST.BRJMP.RET）时，所有类型都会被计数。</p><table><thead><tr><th>控制转移事件分类</th><th>描述</th></tr></thead><tbody><tr><td>BRANCH</td><td>分支指令</td></tr><tr><td>BRANCH.TK</td><td>分支被执行（taken），跳转条件为真的指令，这是一个预测结果</td></tr><tr><td>BRANCH.NT</td><td>分支不被执行 (no-taken)，跳转条件为假的指令，这是一个预测结果</td></tr><tr><td>IND</td><td>间接（无法推断的）跳转和调用指令</td></tr><tr><td>IND.CALL</td><td>间接（无法推断）调用指令</td></tr><tr><td>IND.JUMP</td><td>无链接的(不需要返回地址)间接（无法推断）跳转指令</td></tr><tr><td>IND.LJUMP</td><td>其他有链接的间接（无法推断）跳转指令</td></tr><tr><td>DIR</td><td>直接（可推断）跳转和调用指令。仅适用于 BRJMP，不适用于 MISPRED</td></tr><tr><td>DIR.CALL</td><td>直接（可推断）的调用指令。仅适用于 BRJMP，不适用于 MISPRED</td></tr><tr><td>DIR.JUMP</td><td>直接（可推断）的无链接跳转指令。仅适用于 BRJMP，不适用于 MISPRED</td></tr><tr><td>DIR.LJUMP</td><td>其他直接（可推断）的带有链接的跳转指令。仅适用于 BRJMP，不适用于 MISPRED</td></tr><tr><td>CORSWAP</td><td>Co-routine swap instructions.协程交换指令</td></tr><tr><td>RETURN</td><td>函数返回指令</td></tr><tr><td>TRAPRET</td><td>陷阱返回指令</td></tr></tbody></table><table><thead><tr><th>控制转移组合事件类型</th><th>描述</th></tr></thead><tbody><tr><td>TK</td><td>JAL, JALR, MRET, SRET, and taken branch instructions</td></tr><tr><td>PRED</td><td>预测分支和跳转指令。BRANCH、IND、CORSWAP 和 RETURN 类型的并集, 仅适用于 BRJMP</td></tr><tr><td>JUMP</td><td>间接和直接跳转指令。包括带有链接的跳转指令，但不包括调用或返回</td></tr><tr><td>CALL</td><td>Indirect and direct call instructions</td></tr><tr><td>RETALL</td><td>所有函数返回指令，RETURN 和 CORSWAP 类型的并集</td></tr><tr><td>CALLALL</td><td>所有函数调用指令，CALL 和 CORSWAP 的并集</td></tr><tr><td>UNCOND</td><td>JAL, JALR, MRET, and SRET instructions</td></tr></tbody></table><p>上述所有类型由trace和Smctr&#x2F;Ssctr扩展定义，摘录如下：控制转移类型定义</p><table><header><tr><th class="head"><p>Transfer Type Name</p></th><th class="head"><p>相关操作</p></th></tr><tr><td rowspan='3'>Indirect call</td><td>JALR x5, rs where rs != x1</td></tr><tr><td>JALR x1, rs where rs != x5</td></tr><tr><td>C.JALR rs1 where rs1 != x5l</td></tr><tr><td rowspan='4'>Direct call</td><td>JAL x1</td></tr><tr><td>JAL x5</td></tr><tr><td>C.JAL</td></tr><tr><td>CM.JALT index</td></tr><tr><td rowspan='2'>Indirect jump (without linkage)</td><td>JALR x0, rs where rs != (x1 or x5)</td></tr><tr><td>C.JR rs1 where rs1 != (x1 or x5)</td></tr><tr><td rowspan='3'>Direct jump (without linkage)</td><td>JAL x0</td></tr><tr><td>C.J</td></tr><tr><td>CM.JT index</td></tr><tr><td rowspan='3'>Co-routine swap</td><td>JALR x1, x5</td></tr><tr><td>JALR x5, x1</td></tr><tr><td>C.JALR x5</td></tr><tr><td rowspan='3'>Function return</td><td>JALR rd, rs where rs == (x1 or x5) and rd != (x1 or x5)</td></tr><tr><td>C.JR rs1 where rs1 == (x1 or x5)</td></tr><tr><td>CM.POPRET(Z)</td></tr><tr><td>Other indirect jump (with linkage)</td><td>JALR rd, rs where rs != (x1 or x5) and rd != (x0, x1, or x5)</td></tr><tr><td>Other direct jump (with linkage)</td><td>JAL rd where rd != (x0, x1, or x5)</td></tr><tr><td rowspan='2'>Trap returns</td><td>MRET</td></tr><tr><td>SRET</td></tr></table><h3 id="内存访问指令事件"><a href="#内存访问指令事件" class="headerlink" title="内存访问指令事件"></a>内存访问指令事件</h3><hr><p>内存访问指令类别 LOAD、STORE 和 LDST 包括额外的层次结构，允许按数据源、地址源或缓存性进行计数。当事件名称中不包括额外的限定符（例如，INST.LOAD.RET）时，所有类型都会被计数。</p><table><thead><tr><th><strong>LOAD、STORE、LDST</strong></th><th>描述</th></tr></thead><tbody><tr><td>UC</td><td>执行对不可缓存内存区域的数据访问的指令</td></tr><tr><td>DSRC.*</td><td><strong>Instructions</strong> that accessed data from the specified source$^\color{teal}{[1]}$</td></tr><tr><td>ASRC.*</td><td><strong>Instructions</strong> whose data address translation came from the specified source$^\color{teal}{[2]}$</td></tr></tbody></table><p>[1] the specified source is one of the following: L1D, LL. 强调 Data Cache.<br>[2] the specified source is one of the following: L1D TLB, LL TLB. 强调 Data TLB.</p><p>注意，这里针对 load&#x2F;store 指令。</p><table><thead><tr><th><strong>DSRC 事件数据源</strong></th><th>描述</th></tr></thead><tbody><tr><td>STLF</td><td>store-to-load forwarding. <strong>Load instructions</strong>，由于store到内存较慢，流水线在执行load时会先检测存储队列，如果发现有未完成的store操作时直接将数据转发给load.</td></tr><tr><td><code>&lt;cache&gt;</code></td><td><strong>Instructions</strong> for which the <strong>data</strong> access hit in the selected cache.</td></tr><tr><td><code>&lt;cache&gt;</code>.MISS</td><td><strong>Instructions</strong> for which the <strong>data</strong> access missed in the selected cache.</td></tr><tr><td><code>&lt;cache&gt;</code>.MERGE</td><td><strong>Instructions</strong> for which the <strong>data</strong> access merged with an outstanding miss in the selected cache.</td></tr><tr><td>LOCAL.MEM</td><td><strong>Instructions</strong> for which the <strong>data</strong> access hit in local$^\color{teal}{[1]}$ memory.</td></tr><tr><td>REMOTE.MEM</td><td><strong>Instructions</strong> for which the <strong>data</strong> access hit in remote$^\color{teal}{[2]}$ memory.</td></tr><tr><td>REMOTE.CACHE</td><td><strong>Instructions</strong> for which the <strong>data</strong> access hit in a remote cache.</td></tr><tr><td>REMOTE.HITM</td><td><strong>Instructions</strong> for which the <strong>data</strong> access hit modified data$^\color{teal}{[3]}$ in a remote cache.</td></tr></tbody></table><p>[1] local: 访问同一NUMA节点的内存。<br>[2] remote: 访问不同NUMA节点的内存或缓存。<br>[3] modified data: 此处的修改是指缓存行。如相同缓存行不同地址的数据，其中一个被修改过，访问没被修改的地址，还是HITM事件。</p><table><thead><tr><th><strong>ASRC 事件地址翻译来源</strong></th><th>描述</th></tr></thead><tbody><tr><td><code>&lt;tlb&gt;</code></td><td>指令的数据地址转换在指定的 TLB 中命中</td></tr><tr><td><code>&lt;tlb&gt;</code>.MISS</td><td>指令的数据地址转换在指定的 TLB 中未命中</td></tr></tbody></table><h3 id="向量指令事件"><a href="#向量指令事件" class="headerlink" title="向量指令事件"></a>向量指令事件</h3><hr><p>RVV 事件包括额外的层次结构，允许按向量指令类型进行计数。当事件名称中未包含类型（例如：INST.RVV.RET）时，所有类型都会被计数。</p><table><thead><tr><th>RVV 事件指令类型</th><th>描述</th></tr></thead><tbody><tr><td>LOAD</td><td>Vector load instructions</td></tr><tr><td>STORE</td><td>Vector store instructions</td></tr><tr><td>LDST</td><td>向量内存指令，LOAD 和 STORE 类型的联合</td></tr><tr><td>CFG</td><td>Vector configuration (VSET{I}VL{I}) instructions</td></tr><tr><td>ARITH</td><td>向量算术指令</td></tr><tr><td>ARITH.INT</td><td>向量整数算术指令</td></tr><tr><td>ARITH.FP</td><td>向量浮点数算术指令</td></tr></tbody></table><p>LOAD、STORE 和 LDST 类型包括额外的层次结构，允许按寻址模式计数。当事件名称中未包含寻址模式（例如：INST.RVV.LOAD.RET）时，所有模式都会被计数。</p><table><thead><tr><th>RVV 内存指令寻址模式</th><th>描述</th></tr></thead><tbody><tr><td>UNIT</td><td>Vector unit-stride access instructions</td></tr><tr><td>IDXU</td><td>Vector indexed-unordered access instructions</td></tr><tr><td>STRD</td><td>Vector strided access instructions</td></tr><tr><td>IDXO</td><td>Vector indexed-ordered access instructions</td></tr></tbody></table><h3 id="指令事件总表"><a href="#指令事件总表" class="headerlink" title="指令事件总表"></a>指令事件总表</h3><hr><table><thead><tr><th>指令事件名称</th><th>描述</th></tr></thead><tbody><tr><td>INST.RET</td><td>Instruction Retired. 所有指令</td></tr><tr><td>INST.BRJMP.RET</td><td>Branches and jumps retired. 所有分支跳转指令</td></tr><tr><td>INST.BRJMP.BRANCH.RET</td><td>条件分支</td></tr><tr><td>INST.BRJMP.BRANCH.TK.RET</td><td>Taken conditional branches retired.</td></tr><tr><td>INST.BRJMP.BRANCH.NT.RET</td><td>Not taken conditional branches retired.</td></tr><tr><td>INST.BRJMP.IND.RET</td><td>Indirect jumps, with and without linkage, and calls retired.</td></tr><tr><td>INST.BRJMP.IND.CALL.RET</td><td>Indirect calls retired.</td></tr><tr><td>INST.BRJMP.IND.JUMP.RET</td><td>Indirect jumps without linkage retired.</td></tr><tr><td>INST.BRJMP.IND.LJUMP.RET</td><td>Other indirect jumps with linkage retired.</td></tr><tr><td>INST.BRJMP.DIR.RET</td><td>Direct jumps, with and without linkage, and calls retired.</td></tr><tr><td>INST.BRJMP.DIR.CALL.RET</td><td>Direct calls retired.</td></tr><tr><td>INST.BRJMP.DIR.JUMP.RET</td><td>Direct jumps without linkage retired.</td></tr><tr><td>INST.BRJMP.DIR.LJUMP.RET</td><td>Other direct jumps with linkage retired.</td></tr><tr><td>INST.BRJMP.CORSWAP.RET</td><td>Co-routine swaps retired.</td></tr><tr><td>INST.BRJMP.RETURN.RET</td><td>Function returns retired.</td></tr><tr><td>INST.BRJMP.TK.RET</td><td>Retired instructions that changed control flow. Includes taken branches and all jumps.</td></tr><tr><td>INST.BRJMP.PRED.RET</td><td>Branches and predicted (indirect) jumps retired. Includes calls and returns.</td></tr><tr><td>INST.MISPRED.RET</td><td>Mispredicted control flow instructions retired.</td></tr><tr><td>INST.MISPRED.BRANCH.RET</td><td>Mispredicted conditional branches retired.</td></tr><tr><td>INST.MISPRED.BRANCH.TK.RET</td><td>Taken conditional branches retired.</td></tr><tr><td>INST.MISPRED.BRANCH.NT.RET</td><td>Not-taken conditional branches retired.</td></tr><tr><td>INST.MISPRED.IND.RET</td><td>Mispredicted indirect jumps, with and without linkage, and calls retired. Does not include function returns.</td></tr><tr><td>INST.MISPRED.IND.CALL.RET</td><td>Mispredicted indirect calls retired.</td></tr><tr><td>INST.MISPRED.IND.JUMP.RET</td><td>Mispredicted indirect jumps without linkage retired.</td></tr><tr><td>INST.MISPRED.IND.LJUMP.RET</td><td>Mispredicted other indirect jumps with linkage retired.</td></tr><tr><td>INST.MISPRED.CORSWAP.RET</td><td>Mispredicted co-routine swaps retired.</td></tr><tr><td>INST.MISPRED.RETURN.RET</td><td>Mispredicted function returns retired.</td></tr><tr><td>INST.MISPRED.IND.LJUMP.RET</td><td>Mispredicted other indirect jumps with linkage retired.</td></tr><tr><td>INST.MISPRED.TK.RET</td><td>Retired instructions that changed control flow and were mispredicted. Includes taken branches and all jumps. Includes the following encodings: FIXME</td></tr><tr><td>INST.TRETURN.RET</td><td>Trap return instructions retired.</td></tr><tr><td>INST.LOAD.RET</td><td>Memory load instructions retired.</td></tr><tr><td>INST.LOAD.UC.RET</td><td>Memory load instructions retired that accessed uncacheable memory.</td></tr><tr><td>INST.LOAD.DSRC.L1D.RET</td><td>Memory load instructions retired that hit in the L1D cache.</td></tr><tr><td>INST.LOAD.DSRC.L1D.MISS.RET</td><td>Memory load instructions retired that missed in the L1D cache.</td></tr><tr><td>INST.LOAD.DSRC.L1D.MERGE.RET</td><td>Memory load instructions retired that merged into an outstanding L1D cache miss request.</td></tr><tr><td>INST.LOAD.DSRC.LL.RET</td><td>Memory load instructions retired that hit in the last level cache.</td></tr><tr><td>INST.LOAD.DSRC.LL.MISS.RET</td><td>Memory load instructions retired that missed in the last level cache.</td></tr><tr><td>INST.LOAD.DSRC.LL.MERGE.RET</td><td>Memory load instructions retired that merged into an outstanding last level cache miss request.</td></tr><tr><td>INST.LOAD.DSRC.STLF.RET</td><td>Memory load instructions retired that had data forwarded from an older store.</td></tr><tr><td>INST.LOAD.DSRC.LOCAL.MEM.RET</td><td>Memory load instructions retired that hit in local memory.</td></tr><tr><td>INST.LOAD.DSRC.REMOTE.MEM.RET</td><td>Memory load instructions retired that hit in remote memory.</td></tr><tr><td>INST.LOAD.DSRC.REMOTE.CACHE.RET</td><td>Memory load instructions retired that hit in a remote cache.</td></tr><tr><td>INST.LOAD.DSRC.REMOTE.HITM.RET</td><td>Memory load instructions retired that hit a modified line in a remote cache.</td></tr><tr><td>INST.LOAD.ASRC.L1.RET</td><td>Memory load instructions retired that hit in the L1 TLB.</td></tr><tr><td>INST.LOAD.ASRC.L1.MISS.RET</td><td>Memory load instructions retired that missed in the L1 TLB.</td></tr><tr><td>INST.LOAD.ASRC.L1.MERGE.RET</td><td>Memory load instructions retired that merged into an outstanding L1 TLB miss request.</td></tr><tr><td>INST.LOAD.ASRC.LL.RET</td><td>Memory load instructions retired that hit in the last level TLB.</td></tr><tr><td>INST.LOAD.ASRC.LL.MISS.RET</td><td>Memory load instructions retired that missed in the last level TLB.</td></tr><tr><td>INST.LOAD.ASRC.LL.MERGE.RET</td><td>Memory load instructions retired that merged into an outstanding last level TLB miss request.</td></tr><tr><td>INST.STORE.RET</td><td>Memory store instructions retired.</td></tr><tr><td>INST.STORE.UC.RET</td><td>Memory store instructions retired that accessed uncacheable memory.</td></tr><tr><td>INST.STORE.DSRC.L1D.RET</td><td>Cacheable memory store instructions retired whose read for ownership hit in the L1D cache.</td></tr><tr><td>INST.STORE.DSRC.L1D.MISS.RET</td><td>Cacheable memory store instructions retired whose read for ownership missed in the L1D cache.</td></tr><tr><td>INST.STORE.DSRC.L1D.MERGE.RET</td><td>Cacheable memory store instructions retired whose read for ownership merged into an outstanding L1D cache miss request.</td></tr><tr><td>INST.STORE.DSRC.LL.RET</td><td>Cacheable memory store instructions retired whose read for ownership hit in the last level cache.</td></tr><tr><td>INST.STORE.DSRC.LL.MISS.RET</td><td>Cacheable memory store instructions retired whose read for ownership missed in the last level cache.</td></tr><tr><td>INST.STORE.DSRC.LL.MERGE.RET</td><td>Cacheable memory store instructions retired whose read for ownership merged into an outstanding last level cache miss request.</td></tr><tr><td>INST.STORE.DSRC.LOCAL.MEM.RET</td><td>Cacheable memory store instructions retired whose read for ownership hit in local memory.</td></tr><tr><td>INST.STORE.DSRC.REMOTE.MEM.RET</td><td>Cacheable memory store instructions retired whose read for ownership hit in remote memory.</td></tr><tr><td>INST.STORE.DSRC.REMOTE.CACHE.RET</td><td>Cacheable memory store instructions retired whose read for ownership hit in a remote cache.</td></tr><tr><td>INST.STORE.DSRC.REMOTE.HITM.RET</td><td>Cacheable memory store instructions retired whose read for ownership hit a modified line in a remote cache.</td></tr><tr><td>INST.STORE.ASRC.L1.RET</td><td>Memory store instructions retired that hit in the L1 TLB.</td></tr><tr><td>INST.STORE.ASRC.L1.MISS.RET</td><td>Memory store instructions retired that missed in the L1 TLB.</td></tr><tr><td>INST.STORE.ASRC.L1.MERGE.RET</td><td>Memory store instructions retired that merged into an outstanding L1 TLB miss request.</td></tr><tr><td>INST.STORE.ASRC.LL.RET</td><td>Memory store instructions retired that hit in the last level TLB.</td></tr><tr><td>INST.STORE.ASRC.LL.MISS.RET</td><td>Memory store instructions retired that missed in the last level TLB.</td></tr><tr><td>INST.STORE.ASRC.LL.MERGE.RET</td><td>Memory store instructions retired that merged into an outstanding last level TLB miss request.</td></tr><tr><td>INST.LDST.RET</td><td>Memory load and&#x2F;or store instructions retired.</td></tr><tr><td>INST.LDST.UC.RET</td><td>Memory load and&#x2F;or store instructions retired that accessed uncacheable memory.</td></tr><tr><td>INST.LDST.DSRC.L1D.RET</td><td>Memory load and&#x2F;or store instructions retired that hit in the L1D cache.</td></tr><tr><td>INST.LDST.DSRC.L1D.MISS.RET</td><td>Memory load and&#x2F;or store instructions retired that missed in the L1D cache.</td></tr><tr><td>INST.LDST.DSRC.L1D.MERGE.RET</td><td>Memory load and&#x2F;or store instructions retired that merged into an outstanding L1D cache miss request.</td></tr><tr><td>INST.LDST.DSRC.LL.RET</td><td>Memory load and&#x2F;or store instructions retired that hit in the last level cache.</td></tr><tr><td>INST.LDST.DSRC.LL.MISS.RET</td><td>Memory load and&#x2F;or store instructions retired that missed in the last level cache.</td></tr><tr><td>INST.LDST.DSRC.LL.MERGE.RET</td><td>Memory load and&#x2F;or store instructions retired that merged into an outstanding last level cache miss request.</td></tr><tr><td>INST.LDST.DSRC.STLF.RET</td><td>Memory load and&#x2F;or store instructions retired that had data forwarded from an older store.</td></tr><tr><td>INST.LDST.DSRC.LOCAL.MEM.RET</td><td>Memory load and&#x2F;or store instructions retired that hit in local memory.</td></tr><tr><td>INST.LDST.DSRC.REMOTE.MEM.RET</td><td>Memory load and&#x2F;or store instructions retired that hit in remote memory.</td></tr><tr><td>INST.LDST.DSRC.REMOTE.CACHE.RET</td><td>Memory load and&#x2F;or store instructions retired that hit in a remote cache.</td></tr><tr><td>INST.LDST.DSRC.REMOTE.HITM.RET</td><td>Memory load and&#x2F;or store instructions retired that hit a modified line in a remote cache.</td></tr><tr><td>INST.LDST.ASRC.L1.RET</td><td>Memory load and&#x2F;or store instructions retired that hit in the L1 TLB.</td></tr><tr><td>INST.LDST.ASRC.L1.MISS.RET</td><td>Memory load and&#x2F;or store instructions retired that missed in the L1 TLB.</td></tr><tr><td>INST.LDST.ASRC.L1.MERGE.RET</td><td>Memory load and&#x2F;or store instructions retired that merged into an outstanding L1 TLB miss request.</td></tr><tr><td>INST.LDST.ASRC.LL.RET</td><td>Memory load and&#x2F;or store instructions retired that hit in the last level TLB.</td></tr><tr><td>INST.LDST.ASRC.LL.MISS.RET</td><td>Memory load and&#x2F;or store instructions retired that missed in the last level TLB.</td></tr><tr><td>INST.LDST.ASRC.LL.MERGE.RET</td><td>Memory load and&#x2F;or store instructions retired that merged into an outstanding last level TLB miss request.</td></tr><tr><td>INST.MO.RET</td><td>Memory ordering instructions retired.</td></tr><tr><td>INST.INT.RET</td><td>Integer computational instructions retired.</td></tr><tr><td>INST.FP.RET</td><td>Floating point instructions retired.</td></tr><tr><td>INST.RVV.RET</td><td>Vector instructions retired.</td></tr><tr><td>INST.RVV.LOAD.RET</td><td>Vector load instructions retired.</td></tr><tr><td>INST.RVV.LOAD.UNIT.RET</td><td>Vector unit-stride load instructions retired.</td></tr><tr><td>INST.RVV.LOAD.IDXU.RET</td><td>Vector indexed-unordered load instructions retired.</td></tr><tr><td>INST.RVV.LOAD.STRD.RET</td><td>Vector strided load instructions retired.</td></tr><tr><td>INST.RVV.LOAD.IDXO.RET</td><td>Vector indexed-ordered load instructions retired.</td></tr><tr><td>INST.RVV.STORE.RET</td><td>Vector store instructions retired.</td></tr><tr><td>INST.RVV.STORE.UNIT.RET</td><td>Vector unit-stride store instructions retired.</td></tr><tr><td>INST.RVV.STORE.IDXU.RET</td><td>Vector indexed-unordered store instructions retired.</td></tr><tr><td>INST.RVV.STORE.STRD.RET</td><td>Vector strided store instructions retired.</td></tr><tr><td>INST.RVV.STORE.IDXO.RET</td><td>Vector indexed-ordered store instructions retired.</td></tr><tr><td>INST.RVV.LDST.RET</td><td>Vector unit-stride load and store instructions retired.</td></tr><tr><td>INST.RVV.LDST.UNIT.RET</td><td>Vector unit-stride load and store instructions retired.</td></tr><tr><td>INST.RVV.LDST.IDXU.RET</td><td>Vector indexed-unordered load and store instructions retired.</td></tr><tr><td>INST.RVV.LDST.STRD.RET</td><td>Vector strided load and store instructions retired.</td></tr><tr><td>INST.RVV.LDST.IDXO.RET</td><td>Vector indexed-ordered load and store instructions retired.</td></tr><tr><td>INST.RVV.ARITH.RET</td><td>Vector arithmetic instructions retired.</td></tr><tr><td>INST.RVV.ARITH.INT.RET</td><td>Vector arithmetic vector-integer instructions retired.</td></tr><tr><td>INST.RVV.ARITH.FP.RET</td><td>Vector arithmetic vector-FP instructions retired.</td></tr><tr><td>INST.RVV.CFG.RET</td><td>Vector configuration (VSET{I}VL{I}) instructions retired.</td></tr><tr><td>INST.RVC.RET</td><td>Compressed instructions retired.</td></tr></tbody></table><h2 id="LOAD-STORE-LDST-Events"><a href="#LOAD-STORE-LDST-Events" class="headerlink" title="LOAD&#x2F;STORE&#x2F;LDST Events"></a>LOAD&#x2F;STORE&#x2F;LDST Events</h2><hr><p>该组包含由指令执行的显式加载和存储操作的事件。它不计算预取访问或隐式访问，例如页表查找。</p><p>该组中的每个事件都有推测性（.SPEC）和非推测性（.RET）版本.</p><p>注意,<strong>这些事件会计算每个内存访问</strong>。<strong>INST.{LOAD,STORE,LDST}事件只计数指令</strong>，而有些指令可能会执行多次访问。</p><table><thead><tr><th>LOAD, STORE, and LDST Events</th><th>描述</th></tr></thead><tbody><tr><td>LOAD.RET</td><td>Memory load operations retired.</td></tr><tr><td>LOAD.UC.RET</td><td>Memory load operations retired that accessed uncacheable memory.</td></tr><tr><td>LOAD.DSRC.L1D.RET</td><td>Memory load operations retired that hit in the L1D cache.</td></tr><tr><td>LOAD.DSRC.L1D.MISS.RET</td><td>Memory load operations retired that missed in the L1D cache.</td></tr><tr><td>LOAD.DSRC.L1D.MERGE.RET</td><td>Memory load operations retired that merged into an outstanding L1D cache miss request.</td></tr><tr><td>LOAD.DSRC.LL.RET</td><td>Memory load operations retired that hit in the last level cache.</td></tr><tr><td>LOAD.DSRC.LL.MISS.RET</td><td>Memory load operations retired that missed in the last level cache.</td></tr><tr><td>LOAD.DSRC.LL.MERGE.RET</td><td>Memory load operations retired that merged into an outstanding last level cache miss request.</td></tr><tr><td>LOAD.DSRC.STLF.RET</td><td>Memory load operations retired that had data forwarded from an older store.</td></tr><tr><td>LOAD.DSRC.LOCAL.MEM.RET</td><td>Memory load operations retired that hit in local memory.</td></tr><tr><td>LOAD.DSRC.REMOTE.MEM.RET</td><td>Memory load operations retired that hit in remote memory.</td></tr><tr><td>LOAD.DSRC.REMOTE.CACHE.RET</td><td>Memory load operations retired that hit in a remote cache.</td></tr><tr><td>LOAD.DSRC.REMOTE.HITM.RET</td><td>Memory load operations retired that hit a modified line in a remote cache.</td></tr><tr><td>LOAD.ASRC.L1.RET</td><td>Memory load operations retired that hit in the L1 TLB.</td></tr><tr><td>LOAD.ASRC.L1.MISS.RET</td><td>Memory load operations retired that missed in the L1 TLB.</td></tr><tr><td>LOAD.ASRC.L1.MERGE.RET</td><td>Memory load operations retired that merged into an outstanding L1 TLB miss request.</td></tr><tr><td>LOAD.ASRC.LL.RET</td><td>Memory load operations retired that hit in the last level TLB.</td></tr><tr><td>LOAD.ASRC.LL.MISS.RET</td><td>Memory load operations retired that missed in the last level TLB.</td></tr><tr><td>LOAD.ASRC.LL.MERGE.RET</td><td>Memory load operations retired that merged into an outstanding last level TLB miss request.</td></tr><tr><td>STORE.RET</td><td>Memory store operations retired.</td></tr><tr><td>STORE.UC.RET</td><td>Memory store operations retired that accessed uncacheable memory.</td></tr><tr><td>STORE.DSRC.L1D.RET</td><td>Cacheable memory store operations retired whose read for ownership hit in the L1D cache.</td></tr><tr><td>STORE.DSRC.L1D.MISS.RET</td><td>Cacheable memory store operations retired whose read for ownership missed in the L1D cache.</td></tr><tr><td>STORE.DSRC.L1D.MERGE.RET</td><td>Cacheable memory store operations retired whose read for ownership merged into an outstanding L1D cache miss request.</td></tr><tr><td>STORE.DSRC.LL.RET</td><td>Cacheable memory store operations retired whose read for ownership hit in the last level cache.</td></tr><tr><td>STORE.DSRC.LL.MISS.RET</td><td>Cacheable memory store operations retired whose read for ownership missed in the last level cache.</td></tr><tr><td>STORE.DSRC.LL.MERGE.RET</td><td>Cacheable memory store operations retired whose read for ownership merged into an outstanding last level cache miss request.</td></tr><tr><td>STORE.DSRC.LOCAL.MEM.RET</td><td>Cacheable memory store operations retired whose read for ownership hit in local memory.</td></tr><tr><td>STORE.DSRC.REMOTE.MEM.RET</td><td>Cacheable memory store operations retired whose read for ownership hit in remote memory.</td></tr><tr><td>STORE.DSRC.REMOTE.CACHE.RET</td><td>Cacheable memory store operations retired whose read for ownership hit in a remote cache.</td></tr><tr><td>STORE.DSRC.REMOTE.HITM.RET</td><td>Cacheable memory store operations retired whose read for ownership hit a modified line in a remote cache.</td></tr><tr><td>STORE.ASRC.L1.RET</td><td>Memory store operations retired that hit in the L1 TLB.</td></tr><tr><td>STORE.ASRC.L1.MISS.RET</td><td>Memory store operations retired that missed in the L1 TLB.</td></tr><tr><td>STORE.ASRC.L1.MERGE.RET</td><td>Memory store operations retired that merged into an outstanding L1 TLB miss request.</td></tr><tr><td>STORE.ASRC.LL.RET</td><td>Memory store operations retired that hit in the last level TLB.</td></tr><tr><td>STORE.ASRC.LL.MISS.RET</td><td>Memory store operations retired that missed in the last level TLB.</td></tr><tr><td>STORE.ASRC.LL.MERGE.RET</td><td>Memory store operations retired that merged into an outstanding last level TLB miss request.</td></tr><tr><td>LDST.RET</td><td>Memory load and&#x2F;or store operations retired.</td></tr><tr><td>LDST.UC.RET</td><td>Memory load and&#x2F;or store operations retired that accessed uncacheable memory.</td></tr><tr><td>LDST.DSRC.L1D.RET</td><td>Memory load and&#x2F;or store operations retired that hit in the L1D cache.</td></tr><tr><td>LDST.DSRC.L1D.MISS.RET</td><td>Memory load and&#x2F;or store operations retired that missed in the L1D cache.</td></tr><tr><td>LDST.DSRC.L1D.MERGE.RET</td><td>Memory load and&#x2F;or store operations retired that merged into an outstanding L1D cache miss request.</td></tr><tr><td>LDST.DSRC.LL.RET</td><td>Memory load and&#x2F;or store operations retired that hit in the last level cache.</td></tr><tr><td>LDST.DSRC.LL.MISS.RET</td><td>Memory load and&#x2F;or store operations retired that missed in the last level cache.</td></tr><tr><td>LDST.DSRC.LL.MERGE.RET</td><td>Memory load and&#x2F;or store operations retired that merged into an outstanding last level cache miss request.</td></tr><tr><td>LDST.DSRC.STLF.RET</td><td>Memory load and&#x2F;or store operations retired that had data forwarded from an older store.</td></tr><tr><td>LDST.DSRC.LOCAL.MEM.RET</td><td>Memory load and&#x2F;or store operations retired that hit in local memory.</td></tr><tr><td>LDST.DSRC.REMOTE.MEM.RET</td><td>Memory load and&#x2F;or store operations retired that hit in remote memory.</td></tr><tr><td>LDST.DSRC.REMOTE.CACHE.RET</td><td>Memory load and&#x2F;or store operations retired that hit in a remote cache.</td></tr><tr><td>LDST.DSRC.REMOTE.HITM.RET</td><td>Memory load and&#x2F;or store operations retired that hit a modified line in a remote cache.</td></tr><tr><td>LDST.ASRC.L1.RET</td><td>Memory load and&#x2F;or store operations retired that hit in the L1 TLB.</td></tr><tr><td>LDST.ASRC.L1.MISS.RET</td><td>Memory load and&#x2F;or store operations retired that missed in the L1 TLB.</td></tr><tr><td>LDST.ASRC.L1.MERGE.RET</td><td>Memory load and&#x2F;or store operations retired that merged into an outstanding L1 TLB miss request.</td></tr><tr><td>LDST.ASRC.LL.RET</td><td>Memory load and&#x2F;or store operations retired that hit in the last level TLB.</td></tr><tr><td>LDST.ASRC.LL.MISS.RET</td><td>Memory load and&#x2F;or store operations retired that missed in the last level TLB.</td></tr><tr><td>LDST.ASRC.LL.MERGE.RET</td><td>Memory load and&#x2F;or store operations retired that merged into an outstanding last level TLB miss request.</td></tr></tbody></table><h2 id="Cache-Events"><a href="#Cache-Events" class="headerlink" title="Cache Events"></a>Cache Events</h2><hr><p>这个组包含指令、数据和统一缓存的事件。组中的事件从缓存的角度计数访问；如果一条指令执行两次缓存访问，它们将被分别计数。此外，组中的所有事件都会计数推测性访问。</p><p>CACHE 事件层次结构的顶层标识与事件关联的缓存。标准缓存命名方案如下详细说明。</p><ul><li>第一个字符是 L，表示层次。</li><li>第二个字符表示缓存级别。最近的缓存是级别 1，其次是级别 2，依此类推。级别 L 表示最后一级缓存。</li><li>可选的第三个字符表示缓存是仅由指令获取（I）还是仅由数据访问（D）访问。</li></ul><table><thead><tr><th>CACHE 事件缓存示例</th><th>描述</th></tr></thead><tbody><tr><td>L1D</td><td>Level 1 data cache</td></tr><tr><td>L1I</td><td>Level 1 instruction cache</td></tr><tr><td>L2</td><td>Level 2 cache</td></tr><tr><td>L3</td><td>Level 3 cache</td></tr><tr><td>LL</td><td>Last level cache</td></tr></tbody></table><p>最后一级缓存的事件可能会被别名化为上述某一级缓存的事件。如 LL别名化为L3.</p><p>这些缓存事件是针对每个硬件线程的。对于可能由多个硬件线程共享的缓存，缓存事件仅在与本地硬件线程直接相关的发生时递增。</p><table><thead><tr><th>CACHE 事件访问或操作类型</th><th>描述</th></tr></thead><tbody><tr><td>RD</td><td>Data reads that lookup the cache. This includes explicit reads (e.g., the LW instruction) and implicit reads (e.g., page table walks).</td></tr><tr><td>RD.DATA</td><td>The subset of reads that are <strong>data load</strong> operations.</td></tr><tr><td>RD.CODE</td><td>The subset of reads that are <strong>code fetch</strong> reads.</td></tr><tr><td>WR</td><td>Data writes to the cache. This includes explicit writes (e.g., the SW instruction) and implicit writes (e.g., page accessed&#x2F;dirty attribute updates).</td></tr><tr><td>RW</td><td>Data reads and writes, the union of the RD and WR types above.</td></tr><tr><td>PREF</td><td>Prefetch requests that lookup the cache.</td></tr><tr><td>FILL</td><td>Cache misses or prefetches that result in a line in the cache being filled with data from memory or a higher-level cache$^\color{teal}{[1]}$.</td></tr><tr><td>WB</td><td>Modified lines written out from the cache to memory or to a higher-level cache.</td></tr><tr><td>SNOOP$^\color{teal}{[2]}$</td><td>Cache coherency snoops that lookup the cache.</td></tr><tr><td>OPREF$^\color{teal}{[3]}$</td><td><strong>O</strong>utbound <strong>pref</strong>etches, for the purpose of pulling lines into the associated cache.</td></tr></tbody></table><p>[1] higher-level cache 表示更靠近内存的缓存。<br>[2] SNOOP 是一种缓存一致性协议，通过探测（snoop）操作维护缓存一致性。<br>[3] OPREF 出站预取，一种缓存操作，用于将数据从更高层次的缓存或主内存拉入当前缓存，以提高数据访问效率。这种操作通常由缓存控制器发起，目的是减少未来的缓存未命中（miss）和访问延迟。这个操作通常在后台进行，<strong>不需要处理器的直接干预</strong>。PREF是对指定缓存的预取，OPREF是从指定缓存发起的预取。</p><p>对于可能由多个 hart 共享的缓存，查找事件（RD*、WR、RW、PREF、SNOOP）应仅对本地 hart 的请求进行计数。FILL 和 WB 事件应仅对本地 hart 请求导致的填充和写回进行计数。<strong>OPREF 事件不应计数</strong>。</p><p>在 CACHE 事件层次结构中，某些事件包括额外的级别。对于缓存查找访问类型（RD*、WR 或 RW），第三级按查找结果计数。</p><table><thead><tr><th>CACHE 事件查找结果</th><th>描述</th></tr></thead><tbody><tr><td>ACCESS</td><td>Cache lookups</td></tr><tr><td>HIT</td><td>Cache hits</td></tr><tr><td>MISS</td><td>Cache misses</td></tr><tr><td>MERGE</td><td>Lookups that merged with an outstanding miss</td></tr></tbody></table><p>对于 RD.DATA 和 RD.CODE 类型，还存在一个 MISS.CYCLES 事件，在从 cache 加载（load）或取指 (fetch) 未命中时，该事件会以 Zicntr cycle 计数器的速率计数核心周期，从发现缓存未命中开始，到完成数据&#x2F;指令加载并恢复执行所经历的时钟周期，反映了缓存未命中对处理器执行效率的负面影响。</p><p>SNOOP 类型的事件具有两级额外的层次结构。</p><table><thead><tr><th>CACHE Event Snoop Types</th><th>描述</th></tr></thead><tbody><tr><td>LOCAL</td><td>Snoops from accesses local to the hart</td></tr><tr><td>REMOTE</td><td>Snoops from remote harts</td></tr></tbody></table><p>如果事件名称中既不包含 LOCAL 也不包含 REMOTE 修饰符，则所有 snoop 都会被计数。</p><table><thead><tr><th>CACHE 事件 snoop 结果</th><th>描述</th></tr></thead><tbody><tr><td>ACCESS</td><td>Snoop lookups</td></tr><tr><td>HIT</td><td>Snoops that hit unmodified data</td></tr><tr><td>HITM</td><td>Snoops that hit modified data</td></tr><tr><td>MISS</td><td>Snoops that miss</td></tr></tbody></table><h3 id="Cache-事件总表"><a href="#Cache-事件总表" class="headerlink" title="Cache 事件总表"></a>Cache 事件总表</h3><hr><table><thead><tr><th>CACHE Events</th><th>描述</th></tr></thead><tbody><tr><td>CACHE.L1D.RD.ACCESS</td><td>Read accesses to the L1D cache.</td></tr><tr><td>CACHE.L1D.RD.MISS</td><td>Read accesses that miss the L1D cache.</td></tr><tr><td>CACHE.L1D.RD.HIT</td><td>Read accesses that hit the L1D cache.</td></tr><tr><td>CACHE.L1D.RD.MERGE</td><td>Read accesses that merge into an outstanding L1D cache miss request.</td></tr><tr><td>CACHE.L1D.RD.DATA.ACCESS</td><td>Demand data read accesses to the L1D cache.</td></tr><tr><td>CACHE.L1D.RD.DATA.MISS</td><td>Demand data read accesses that miss the L1D cache.</td></tr><tr><td>CACHE.L1D.RD.DATA.HIT</td><td>Demand data read accesses that hit the L1D cache.</td></tr><tr><td>CACHE.L1D.RD.DATA.MERGE</td><td>Demand data read accesses that merge into an outstanding L1D cache miss request.</td></tr><tr><td>CACHE.L1D.RD.DATA.MISS.CYCLES</td><td>Cycles while at least one L1D read miss is outstanding.</td></tr><tr><td>CACHE.L1D.WR.ACCESS</td><td>Write accesses to the L1D cache.</td></tr><tr><td>CACHE.L1D.WR.MISS</td><td>Write accesses that miss the L1D cache.</td></tr><tr><td>CACHE.L1D.WR.HIT</td><td>Write accesses that hit the L1D cache.</td></tr><tr><td>CACHE.L1D.WR.MERGE</td><td>Write accesses that write-combine into an outstanding L1D cache write.</td></tr><tr><td>CACHE.L1D.ACCESS</td><td>Any accesses to the L1D cache.</td></tr><tr><td>CACHE.L1D.MISS</td><td>Any accesses that miss the L1D cache.</td></tr><tr><td>CACHE.L1D.HIT</td><td>Any accesses that hit the L1D cache.</td></tr><tr><td>CACHE.L1D.MERGE</td><td>Any accesses that merge into an outstanding L1D cache miss request.</td></tr><tr><td>CACHE.L1D.OPREF</td><td>Prefetch issued by the L1D prefetcher.</td></tr><tr><td>CACHE.L1D.SNOOP.LOCAL.ACCESS</td><td>Local snoops to the L1D cache.</td></tr><tr><td>CACHE.L1D.SNOOP.LOCAL.MISS</td><td>Local snoops that miss the L1D cache.</td></tr><tr><td>CACHE.L1D.SNOOP.LOCAL.HIT</td><td>Local snoops that hit the L1D cache.</td></tr><tr><td>CACHE.L1D.SNOOP.LOCAL.HITM</td><td>Local snoops that hit a modified line in the L1D cache.</td></tr><tr><td>CACHE.L1D.SNOOP.REMOTE.ACCESS</td><td>Remote snoops to the L1D cache.</td></tr><tr><td>CACHE.L1D.SNOOP.REMOTE.MISS</td><td>Remote snoops that miss the L1D cache.</td></tr><tr><td>CACHE.L1D.SNOOP.REMOTE.HIT</td><td>Remote snoops that hit the L1D cache.</td></tr><tr><td>CACHE.L1D.SNOOP.REMOTE.HITM</td><td>Remote snoops that hit a modified line in the L1D cache.</td></tr><tr><td>CACHE.L1D.SNOOP.ACCESS</td><td>Snoops to the L1D cache.</td></tr><tr><td>CACHE.L1D.SNOOP.MISS</td><td>Snoops that miss the L1D cache.</td></tr><tr><td>CACHE.L1D.SNOOP.HIT</td><td>Snoops that hit the L1D cache.</td></tr><tr><td>CACHE.L1D.SNOOP.HITM</td><td>Snoops that hit a modified line in the L1D cache.</td></tr><tr><td>CACHE.L1D.REFILL</td><td>Cacheline refills to the L1D cache.</td></tr><tr><td>CACHE.L1D.WB</td><td>Cacheline writebacks from the L1D cache.</td></tr><tr><td>CACHE.L1I.RD.ACCESS</td><td>Read accesses to the L1I cache.</td></tr><tr><td>CACHE.L1I.RD.MISS</td><td>Read accesses that miss the L1I cache.</td></tr><tr><td>CACHE.L1I.RD.HIT</td><td>Read accesses that hit the L1I cache.</td></tr><tr><td>CACHE.L1I.RD.MERGE</td><td>Read accesses that merge into an outstanding L1I cache miss request.</td></tr><tr><td>CACHE.L1I.RD.CODE.ACCESS</td><td>Code fetches to the L1I cache.</td></tr><tr><td>CACHE.L1I.RD.CODE.MISS</td><td>Code fetches that miss the L1I cache.</td></tr><tr><td>CACHE.L1I.RD.CODE.HIT</td><td>Code fetches that hit the L1I cache.</td></tr><tr><td>CACHE.L1I.RD.CODE.MERGE</td><td>Code fetches that merge into an outstanding L1I cache miss request.</td></tr><tr><td>CACHE.L1I.RD.CODE.MISS.CYCLES</td><td>Cycles while at least one L1I read miss is outstanding.</td></tr><tr><td>CACHE.L1I.SNOOP.LOCAL.ACCESS</td><td>Local snoops to the L1I cache.</td></tr><tr><td>CACHE.L1I.SNOOP.LOCAL.MISS</td><td>Local snoops that miss the L1I cache.</td></tr><tr><td>CACHE.L1I.SNOOP.LOCAL.HIT</td><td>Local snoops that hit the L1I cache.</td></tr><tr><td>CACHE.L1I.SNOOP.REMOTE.ACCESS</td><td>Remote snoops to the L1I cache.</td></tr><tr><td>CACHE.L1I.SNOOP.REMOTE.MISS</td><td>Remote snoops that miss the L1I cache.</td></tr><tr><td>CACHE.L1I.SNOOP.REMOTE.HIT</td><td>Remote snoops that hit the L1I cache.</td></tr><tr><td>CACHE.L1I.SNOOP.ACCESS</td><td>Snoops to the L1I cache.</td></tr><tr><td>CACHE.L1I.SNOOP.MISS</td><td>Snoops that miss the L1I cache.</td></tr><tr><td>CACHE.L1I.SNOOP.HIT</td><td>Snoops that hit the L1I cache.</td></tr><tr><td>CACHE.L1I.REFILL</td><td>Cacheline refills to the L1I cache.</td></tr><tr><td>CACHE.L2.RD.ACCESS</td><td>Read accesses to the L2 cache.</td></tr><tr><td>CACHE.L2.RD.MISS</td><td>Read accesses that miss the L2 cache.</td></tr><tr><td>CACHE.L2.RD.HIT</td><td>Read accesses that hit the L2 cache.</td></tr><tr><td>CACHE.L2.RD.MERGE</td><td>Read accesses that merge into an outstanding L2 cache miss request.</td></tr><tr><td>CACHE.L2.RD.DATA.ACCESS</td><td>Demand data read accesses to the L2 cache.</td></tr><tr><td>CACHE.L2.RD.DATA.MISS</td><td>Demand data read accesses that miss the L2 cache.</td></tr><tr><td>CACHE.L2.RD.DATA.HIT</td><td>Demand data read accesses that hit the L2 cache.</td></tr><tr><td>CACHE.L2.RD.DATA.MERGE</td><td>Demand data read accesses that merge into an outstanding L2 cache miss request.</td></tr><tr><td>CACHE.L2.RD.DATA.MISS.CYCLES</td><td>Cycles while at least one L2 read miss is outstanding.</td></tr><tr><td>CACHE.L2.WR.ACCESS</td><td>Write accesses to the L2 cache.</td></tr><tr><td>CACHE.L2.WR.MISS</td><td>Write accesses that miss the L2 cache.</td></tr><tr><td>CACHE.L2.WR.HIT</td><td>Write accesses that hit the L2 cache.</td></tr><tr><td>CACHE.L2.WR.MERGE</td><td>Write accesses that write-combine into an outstanding L2 cache write.</td></tr><tr><td>CACHE.L2.RD.PREF.ACCESS</td><td>Prefetches to the L2 cache.</td></tr><tr><td>CACHE.L2.RD.PREF.MISS</td><td>Prefetches that miss the L2 cache.</td></tr><tr><td>CACHE.L2.RD.PREF.HIT</td><td>Prefetches that hit the L2 cache.</td></tr><tr><td>CACHE.L2.RD.PREF.MERGE</td><td>Prefetches that merge into an outstanding L2 cache miss request.</td></tr><tr><td>CACHE.L2.RD.CODE.ACCESS</td><td>Code fetches to the L2 cache.</td></tr><tr><td>CACHE.L2.RD.CODE.MISS</td><td>Code fetches that miss the L2 cache.</td></tr><tr><td>CACHE.L2.RD.CODE.HIT</td><td>Code fetches that hit the L2 cache.</td></tr><tr><td>CACHE.L2.RD.CODE.MERGE</td><td>Code fetches that merge into an outstanding L2 cache miss request.</td></tr><tr><td>CACHE.L2.ACCESS</td><td>Any accesses to the L2 cache.</td></tr><tr><td>CACHE.L2.MISS</td><td>Any accesses that miss the L2 cache.</td></tr><tr><td>CACHE.L2.HIT</td><td>Any accesses that hit the L2 cache.</td></tr><tr><td>CACHE.L2.MERGE</td><td>Any accesses that merge into an outstanding L2 cache miss request.</td></tr><tr><td>CACHE.L2.OPREF</td><td>Prefetch issued by the L2 prefetcher.</td></tr><tr><td>CACHE.L2.SNOOP.LOCAL.ACCESS</td><td>Local snoops to the L2 cache.</td></tr><tr><td>CACHE.L2.SNOOP.LOCAL.MISS</td><td>Local snoops that miss the L2 cache.</td></tr><tr><td>CACHE.L2.SNOOP.LOCAL.HIT</td><td>Local snoops that hit the L2 cache.</td></tr><tr><td>CACHE.L2.SNOOP.LOCAL.HITM</td><td>Local snoops that hit a modified line in the L2 cache.</td></tr><tr><td>CACHE.L2.SNOOP.REMOTE.ACCESS</td><td>Remote snoops to the L2 cache.</td></tr><tr><td>CACHE.L2.SNOOP.REMOTE.MISS</td><td>Remote snoops that miss the L2 cache.</td></tr><tr><td>CACHE.L2.SNOOP.REMOTE.HIT</td><td>Remote snoops that hit the L2 cache.</td></tr><tr><td>CACHE.L2.SNOOP.REMOTE.HITM</td><td>Remote snoops that hit a modified line in the L2 cache.</td></tr><tr><td>CACHE.L2.SNOOP.ACCESS</td><td>Snoops to the L2 cache.</td></tr><tr><td>CACHE.L2.SNOOP.MISS</td><td>Snoops that miss the L2 cache.</td></tr><tr><td>CACHE.L2.SNOOP.HIT</td><td>Snoops that hit the L2 cache.</td></tr><tr><td>CACHE.L2.SNOOP.HITM</td><td>Snoops that hit a modified line in the L2 cache.</td></tr><tr><td>CACHE.L2.REFILL</td><td>Cacheline refills to the L2 cache.</td></tr><tr><td>CACHE.L2.WB</td><td>Cacheline writebacks from the L2 cache.</td></tr><tr><td>CACHE.L3.RD.ACCESS</td><td>Read accesses to the L3 cache.</td></tr><tr><td>CACHE.L3.RD.MISS</td><td>Read accesses that miss the L3 cache.</td></tr><tr><td>CACHE.L3.RD.HIT</td><td>Read accesses that hit the L3 cache.</td></tr><tr><td>CACHE.L3.RD.MERGE</td><td>Read accesses that merge into an outstanding L3 cache miss request.</td></tr><tr><td>CACHE.L3.RD.DATA.ACCESS</td><td>Demand data read accesses to the L3 cache.</td></tr><tr><td>CACHE.L3.RD.DATA.MISS</td><td>Demand data read accesses that miss the L3 cache.</td></tr><tr><td>CACHE.L3.RD.DATA.HIT</td><td>Demand data read accesses that hit the L3 cache.</td></tr><tr><td>CACHE.L3.RD.DATA.MERGE</td><td>Demand data read accesses that merge into an outstanding L3 cache miss request.</td></tr><tr><td>CACHE.L3.RD.DATA.MISS.CYCLES</td><td>Cycles while at least one L3 read miss is outstanding.</td></tr><tr><td>CACHE.L3.WR.ACCESS</td><td>Write accesses to the L3 cache.</td></tr><tr><td>CACHE.L3.WR.MISS</td><td>Write accesses that miss the L3 cache.</td></tr><tr><td>CACHE.L3.WR.HIT</td><td>Write accesses that hit the L3 cache.</td></tr><tr><td>CACHE.L3.WR.MERGE</td><td>Write accesses that write-combine into an outstanding L3 cache write.</td></tr><tr><td>CACHE.L3.RD.PREF.ACCESS</td><td>Prefetches to the L3 cache.</td></tr><tr><td>CACHE.L3.RD.PREF.MISS</td><td>Prefetches that miss the L3 cache.</td></tr><tr><td>CACHE.L3.RD.PREF.HIT</td><td>Prefetches that hit the L3 cache.</td></tr><tr><td>CACHE.L3.RD.PREF.MERGE</td><td>Prefetches that merge into an outstanding L3 cache miss request.</td></tr><tr><td>CACHE.L3.RD.CODE.ACCESS</td><td>Code fetches to the L3 cache.</td></tr><tr><td>CACHE.L3.RD.CODE.MISS</td><td>Code fetches that miss the L3 cache.</td></tr><tr><td>CACHE.L3.RD.CODE.HIT</td><td>Code fetches that hit the L3 cache.</td></tr><tr><td>CACHE.L3.RD.CODE.MERGE</td><td>Code fetches that merge into an outstanding L3 cache miss request.</td></tr><tr><td>CACHE.L3.ACCESS</td><td>Any accesses to the L3 cache.</td></tr><tr><td>CACHE.L3.MISS</td><td>Any accesses that miss the L3 cache.</td></tr><tr><td>CACHE.L3.HIT</td><td>Any accesses that hit the L3 cache.</td></tr><tr><td>CACHE.L3.MERGE</td><td>Any accesses that merge into an outstanding L3 cache miss request.</td></tr><tr><td>CACHE.L3.OPREF</td><td>Prefetch issued by the L3 prefetcher.</td></tr><tr><td>CACHE.L3.SNOOP.LOCAL.ACCESS</td><td>Local snoops to the L3 cache.</td></tr><tr><td>CACHE.L3.SNOOP.LOCAL.MISS</td><td>Local snoops that miss the L3 cache.</td></tr><tr><td>CACHE.L3.SNOOP.LOCAL.HIT</td><td>Local snoops that hit the L3 cache.</td></tr><tr><td>CACHE.L3.SNOOP.LOCAL.HITM</td><td>Local snoops that hit a modified line in the L3 cache.</td></tr><tr><td>CACHE.L3.SNOOP.REMOTE.ACCESS</td><td>Remote snoops to the L3 cache.</td></tr><tr><td>CACHE.L3.SNOOP.REMOTE.MISS</td><td>Remote snoops that miss the L3 cache.</td></tr><tr><td>CACHE.L3.SNOOP.REMOTE.HIT</td><td>Remote snoops that hit the L3 cache.</td></tr><tr><td>CACHE.L3.SNOOP.REMOTE.HITM</td><td>Remote snoops that hit a modified line in the L3 cache.</td></tr><tr><td>CACHE.L3.SNOOP.ACCESS</td><td>Snoops to the L3 cache.</td></tr><tr><td>CACHE.L3.SNOOP.MISS</td><td>Snoops that miss the L3 cache.</td></tr><tr><td>CACHE.L3.SNOOP.HIT</td><td>Snoops that hit the L3 cache.</td></tr><tr><td>CACHE.L3.SNOOP.HITM</td><td>Snoops that hit a modified line in the L3 cache.</td></tr><tr><td>CACHE.L3.REFILL</td><td>Cacheline refills to the L3 cache.</td></tr><tr><td>CACHE.L3.WB</td><td>Cacheline writebacks from the L3 cache.</td></tr><tr><td>CACHE.LL.RD.ACCESS</td><td>Read accesses to the last level cache.</td></tr><tr><td>CACHE.LL.RD.MISS</td><td>Read accesses that miss the last level cache.</td></tr><tr><td>CACHE.LL.RD.HIT</td><td>Read accesses that hit the last level cache.</td></tr><tr><td>CACHE.LL.RD.MERGE</td><td>Read accesses that merge into an outstanding last level cache miss request.</td></tr><tr><td>CACHE.LL.RD.DATA.ACCESS</td><td>Demand data read accesses to the last level cache.</td></tr><tr><td>CACHE.LL.RD.DATA.MISS</td><td>Demand data read accesses that miss the last level cache.</td></tr><tr><td>CACHE.LL.RD.DATA.HIT</td><td>Demand data read accesses that hit the last level cache.</td></tr><tr><td>CACHE.LL.RD.DATA.MERGE</td><td>Demand data read accesses that merge into an outstanding last level cache miss request.</td></tr><tr><td>CACHE.LL.RD.DATA.MISS.CYCLES</td><td>Cycles while at least one last level cache read miss is outstanding.</td></tr><tr><td>CACHE.LL.WR.ACCESS</td><td>Write accesses to the last level cache.</td></tr><tr><td>CACHE.LL.WR.MISS</td><td>Write accesses that miss the last level cache.</td></tr><tr><td>CACHE.LL.WR.HIT</td><td>Write accesses that hit the last level cache.</td></tr><tr><td>CACHE.LL.WR.MERGE</td><td>Write accesses that write-combine into an outstanding last level cache write.</td></tr><tr><td>CACHE.LL.RD.PREF.ACCESS</td><td>Prefetches to the last level cache.</td></tr><tr><td>CACHE.LL.RD.PREF.MISS</td><td>Prefetches that miss the last level cache.</td></tr><tr><td>CACHE.LL.RD.PREF.HIT</td><td>Prefetches that hit the last level cache.</td></tr><tr><td>CACHE.LL.RD.PREF.MERGE</td><td>Prefetches that merge into an outstanding last level cache miss request.</td></tr><tr><td>CACHE.LL.RD.CODE.ACCESS</td><td>Code fetches to the last level cache.</td></tr><tr><td>CACHE.LL.RD.CODE.MISS</td><td>Code fetches that miss the last level cache.</td></tr><tr><td>CACHE.LL.RD.CODE.HIT</td><td>Code fetches that hit the last level cache.</td></tr><tr><td>CACHE.LL.RD.CODE.MERGE</td><td>Code fetches that merge into an outstanding last level cache miss request.</td></tr><tr><td>CACHE.LL.ACCESS</td><td>Any accesses to the last level cache.</td></tr><tr><td>CACHE.LL.MISS</td><td>Any accesses that miss the last level cache.</td></tr><tr><td>CACHE.LL.HIT</td><td>Any accesses that hit the last level cache.</td></tr><tr><td>CACHE.LL.MERGE</td><td>Any accesses that merge into an outstanding last level cache miss request.</td></tr><tr><td>CACHE.LL.OPREF</td><td>Prefetch issued by the last level cache prefetcher.</td></tr><tr><td>CACHE.LL.SNOOP.LOCAL.ACCESS</td><td>Local snoops to the last level cache.</td></tr><tr><td>CACHE.LL.SNOOP.LOCAL.MISS</td><td>Local snoops that miss the last level cache.</td></tr><tr><td>CACHE.LL.SNOOP.LOCAL.HIT</td><td>Local snoops that hit the last level cache.</td></tr><tr><td>CACHE.LL.SNOOP.LOCAL.HITM</td><td>Local snoops that hit a modified line in the last level cache.</td></tr><tr><td>CACHE.LL.SNOOP.REMOTE.ACCESS</td><td>Remote snoops to the last level cache.</td></tr><tr><td>CACHE.LL.SNOOP.REMOTE.MISS</td><td>Remote snoops that miss the last level cache.</td></tr><tr><td>CACHE.LL.SNOOP.REMOTE.HIT</td><td>Remote snoops that hit the last level cache.</td></tr><tr><td>CACHE.LL.SNOOP.REMOTE.HITM</td><td>Remote snoops that hit a modified line in the last level cache.</td></tr><tr><td>CACHE.LL.SNOOP.ACCESS</td><td>Snoops to the last level cache.</td></tr><tr><td>CACHE.LL.SNOOP.MISS</td><td>Snoops that miss the last level cache.</td></tr><tr><td>CACHE.LL.SNOOP.HIT</td><td>Snoops that hit the last level cache.</td></tr><tr><td>CACHE.LL.SNOOP.HITM</td><td>Snoops that hit a modified line in the last level cache.</td></tr><tr><td>CACHE.LL.REFILL</td><td>Cacheline refills to the last level cache.</td></tr><tr><td>CACHE.LL.WB</td><td>Cacheline writebacks from the last level cache.</td></tr></tbody></table><h2 id="TLB-Events"><a href="#TLB-Events" class="headerlink" title="TLB Events"></a>TLB Events</h2><hr><p>该组包含翻译查找缓冲区（TLB）的事件。此组中的事件从 TLB 的角度计算访问次数；如果一条指令执行了两次地址转换，它们将被分别计数。此外，此组中的所有事件都将计算推测性访问。</p><table><thead><tr><th>TLB 事件缓存示例</th><th>描述</th></tr></thead><tbody><tr><td>L1D</td><td>Level 1 data TLB (DTLB)</td></tr><tr><td>L1I</td><td>Level 1 instruction TLB (ITLB)</td></tr><tr><td>LL</td><td>Level 2 shared TLB (STLB)</td></tr></tbody></table><table><thead><tr><th>TLB Event Access or Operation Type</th><th>描述</th></tr></thead><tbody><tr><td>ACCESS</td><td>TLB lookups</td></tr><tr><td>HIT</td><td>TLB hits</td></tr><tr><td>MISS</td><td>TLB misses</td></tr><tr><td>MERGE</td><td>Lookups that merged with an outstanding miss</td></tr></tbody></table><p>对于 LDST 和 CODE 类型，还存在一个 MISS.CYCLES 事件，从处理器发现未命中开始，到数据&#x2F;指令加载到缓存并恢复执行截止，记录 cycles 数。</p><table><thead><tr><th>TLB Events</th><th>描述</th></tr></thead><tbody><tr><td>TLB.L1D.LOAD.ACCESS</td><td>Load address translation requests to the L1 TLB.</td></tr><tr><td>TLB.L1D.LOAD.MISS</td><td>Load address translation requests that miss the L1 TLB.</td></tr><tr><td>TLB.L1D.LOAD.HIT</td><td>Load address translation requests that hit the L1 TLB.</td></tr><tr><td>TLB.L1D.LOAD.MERGE</td><td>Load address translation requests that merge into an outstanding L1 TLB miss.</td></tr><tr><td>TLB.L1D.STORE.ACCESS</td><td>Store address translation requests to the L1 TLB.</td></tr><tr><td>TLB.L1D.STORE.MISS</td><td>Store address translation requests that miss the L1 TLB.</td></tr><tr><td>TLB.L1D.STORE.HIT</td><td>Store address translation requests that hit the L1 TLB.</td></tr><tr><td>TLB.L1D.STORE.MERGE</td><td>Store address translation requests that merge into an outstanding L1 TLB miss.</td></tr><tr><td>TLB.L1D.LDST.ACCESS</td><td>Load or store address translation requests to the L1 TLB.</td></tr><tr><td>TLB.L1D.LDST.MISS</td><td>Load or store address translation requests that miss the L1 TLB.</td></tr><tr><td>TLB.L1D.LDST.HIT</td><td>Load or store address translation requests that hit the L1 TLB.</td></tr><tr><td>TLB.L1D.LDST.MERGE</td><td>Load or store address translation requests that merge into an outstanding L1 TLB miss.</td></tr><tr><td>TLB.L1D.LDST.MISS.CYCLES</td><td>Cycles while at least one L1 TLB load or store translation miss is outstanding.</td></tr><tr><td>TLB.L1I.CODE.ACCESS</td><td>Instruction fetch address translation requests to the L1 TLB.</td></tr><tr><td>TLB.L1I.CODE.MISS</td><td>Instruction fetch address translation requests that miss the L1 TLB.</td></tr><tr><td>TLB.L1I.CODE.HIT</td><td>Instruction fetch address translation requests that hit the L1 TLB.</td></tr><tr><td>TLB.L1I.CODE.MERGE</td><td>Instruction fetch address translation requests that merge into an outstanding L1 TLB miss.</td></tr><tr><td>TLB.L1I.CODE.MISS.CYCLES</td><td>Cycles while at least one L1 TLB instruction fetch translation miss is outstanding.</td></tr><tr><td>TLB.LL.LOAD.ACCESS</td><td>Load address translation requests to the last level TLB.</td></tr><tr><td>TLB.LL.LOAD.MISS</td><td>Load address translation requests that miss the last level TLB.</td></tr><tr><td>TLB.LL.LOAD.HIT</td><td>Load address translation requests that hit the last level TLB.</td></tr><tr><td>TLB.LL.LOAD.MERGE</td><td>Load address translation requests that merge into an outstanding last level TLB miss.</td></tr><tr><td>TLB.LL.STORE.ACCESS</td><td>Store address translation requests to the last level TLB.</td></tr><tr><td>TLB.LL.STORE.MISS</td><td>Store address translation requests that miss the last level TLB.</td></tr><tr><td>TLB.LL.STORE.HIT</td><td>Store address translation requests that hit the last level TLB.</td></tr><tr><td>TLB.LL.STORE.MERGE</td><td>Store address translation requests that merge into an outstanding last level TLB miss.</td></tr><tr><td>TLB.LL.LDST.ACCESS</td><td>Load or store address translation requests to the last level TLB.</td></tr><tr><td>TLB.LL.LDST.MISS</td><td>Load or store address translation requests that miss the last level TLB.</td></tr><tr><td>TLB.LL.LDST.HIT</td><td>Load or store address translation requests that hit the last level TLB.</td></tr><tr><td>TLB.LL.LDST.MERGE</td><td>Load or store address translation requests that merge into an outstanding last level TLB miss.</td></tr><tr><td>TLB.LL.LDST.MISS.CYCLES</td><td>Cycles while at least one last level TLB load or store translation miss is outstanding.</td></tr><tr><td>TLB.LL.CODE.ACCESS</td><td>Instruction fetch address translation requests to the last level TLB.</td></tr><tr><td>TLB.LL.CODE.MISS</td><td>Instruction fetch address translation requests that miss the last level TLB.</td></tr><tr><td>TLB.LL.CODE.HIT</td><td>Instruction fetch address translation requests that hit the last level TLB.</td></tr><tr><td>TLB.LL.CODE.MERGE</td><td>Instruction fetch address translation requests that merge into an outstanding last level TLB miss.</td></tr><tr><td>TLB.LL.CODE.MISS.CYCLES</td><td>Cycles while at least one last level TLB instruction fetch translation miss is outstanding.</td></tr></tbody></table><h2 id="FETCH-Events"><a href="#FETCH-Events" class="headerlink" title="FETCH Events"></a>FETCH Events</h2><hr><p>该组包含<strong>计数指令取址请求</strong>的事件，按地址转换源或指令数据源细分。所有事件都计数推测性取址请求。</p><table><thead><tr><th>FETCH Event Categories</th><th>描述</th></tr></thead><tbody><tr><td>DSRC.*</td><td><strong>Instruction fetches</strong> that accessed data from the specified source$^\color{teal}{[1]}$</td></tr><tr><td>ASRC.*</td><td><strong>Instruction fetches</strong> whose address translation came from the specified source$^\color{teal}{[2]}$</td></tr></tbody></table><p>[1] the specified source is one of the following: L1I, L2, L3, LL. 强调<strong>指令Cache</strong>.<br>[2] the specified source is one of the following: L1I TLB, L2 TLB, LL TLB. 强调指令地址转换Cache.</p><p>注意，这里针对 fetch 事件。</p><table><thead><tr><th>DSRC 事件指令获取数据源</th><th>描述</th></tr></thead><tbody><tr><td><code>&lt;cache&gt;</code></td><td><strong>Instruction fetches</strong> for which the <strong><strong>instruction data</strong></strong> access hit in the selected cache.</td></tr><tr><td><code>&lt;cache&gt;</code>.MISS</td><td><strong>Instruction fetches</strong> for which the <strong><strong>instruction data</strong></strong> access missed in the selected cache.</td></tr><tr><td><code>&lt;cache&gt;</code>.MERGE</td><td><strong>Instruction fetches</strong> for which the <strong><strong>instruction data</strong></strong> access merged with an outstanding miss in the selected cache.</td></tr><tr><td>LOCAL.MEM</td><td><strong>Instruction fetches</strong> for which the <strong><strong>instruction data</strong></strong> access hit in local memory.</td></tr><tr><td>REMOTE.MEM</td><td><strong>Instruction fetches</strong> for which the <strong><strong>instruction data</strong></strong> access hit in remote memory.</td></tr><tr><td>REMOTE.CACHE</td><td><strong>Instruction fetches</strong> for which the <strong><strong>instruction data</strong></strong> access hit in a remote cache.</td></tr><tr><td>REMOTE.HITM</td><td><strong>Instruction fetches</strong> for which the <strong><strong>instruction data</strong></strong> access hit modified data in a remote cache.</td></tr></tbody></table><table><thead><tr><th>ASRC 事件指令获取地址转换来源</th><th>描述</th></tr></thead><tbody><tr><td><code>&lt;tlb&gt;</code></td><td><strong>Instruction fetches</strong> for which the address translation hit in the selected TLB.</td></tr><tr><td><code>&lt;tlb&gt;</code>.MISS</td><td>Instruction fetches for which the address translation missed in the selected.</td></tr></tbody></table><p><strong>注意</strong>，在 INSN 事件中也有相同的分类，但是对象不同，INSN 事件章节强调的是 load&#x2F;store 指令，对象是数据，而此处只针对 fetch 指令，对象是指令。</p><table><thead><tr><th>FETCH Events</th><th>Description</th></tr></thead><tbody><tr><td>FETCH.DSRC.L1I</td><td>Instruction fetches that <strong>hit</strong> in the L1I cache.</td></tr><tr><td>FETCH.DSRC.L1I.MISS</td><td>Instruction fetches that missed in the L1I cache.</td></tr><tr><td>FETCH.DSRC.L1I.MERGE</td><td>Instruction fetches that merged into an outstanding L1I cache miss request.</td></tr><tr><td>FETCH.DSRC.LL</td><td>Instruction fetches that hit in the last level cache.</td></tr><tr><td>FETCH.DSRC.LL.MISS</td><td>Instruction fetches that missed in the last level cache.</td></tr><tr><td>FETCH.DSRC.LL.MERGE</td><td>Instruction fetches that merged into an outstanding last level cache miss request.</td></tr><tr><td>FETCH.DSRC.LOCAL.MEM</td><td>Instruction fetches that hit in local memory.</td></tr><tr><td>FETCH.DSRC.REMOTE.MEM</td><td>Instruction fetches that hit in remote memory.</td></tr><tr><td>FETCH.DSRC.REMOTE.CACHE</td><td>Instruction fetches that hit in a remote cache.</td></tr><tr><td>FETCH.DSRC.REMOTE.HITM</td><td>Instruction fetches that hit a modified line in a remote cache.</td></tr><tr><td>FETCH.ASRC.L1</td><td>Instruction fetch address translation requests that hit in the L1 TLB.</td></tr><tr><td>FETCH.ASRC.L1.MISS</td><td>Instruction fetch address translation requests that missed in the L1 TLB.</td></tr><tr><td>FETCH.ASRC.L1.MERGE</td><td>Instruction fetch address translation requests that merged into an outstanding L1 TLB miss request.</td></tr><tr><td>FETCH.ASRC.LL</td><td>Instruction fetch address translation requests that hit in the last level TLB.</td></tr><tr><td>FETCH.ASRC.LL.MISS</td><td>Instruction fetch address translation requests that missed in the last level TLB.</td></tr><tr><td>FETCH.ASRC.LL.MERGE</td><td>Instruction fetch address translation requests that merged into an outstanding last level TLB miss request.</td></tr></tbody></table><h2 id="TMA-事件"><a href="#TMA-事件" class="headerlink" title="TMA 事件"></a>TMA 事件</h2><hr><p>该组包含用于使用自顶向下微架构分析（Top-down Microarchitecture Analysis）方法的事件。</p><p>TMA 是由 Intel 引入的一种行业标准方法，用于表征 SPEC CPU2006 在 Intel CPU 上的性能，并且后来用于表征 HPC 工作负载、GPU 工作负载、微架构更改、硅前性能验证失败等。</p><p>在给定的工作负载中，瓶颈存在于何处。TMA通过计算微架构中每个流水线“槽”的利用率来实现这一点。例如，在一个 4 宽的实现中，每个时钟周期都有 4 个槽需要考虑。当硬件以最佳效率利用时，每个槽都会被一条指令或微操作（uop）占用，该指令或微操作将执行并退休。当出现瓶颈时，可能是由于缓存缺失、分支预测错误或其他微架构条件，某些槽可能会未被使用或被丢弃，从而导致效率低下和性能降低。TMA 能够识别这些浪费的槽位，以及导致这些槽位未被使用的停顿、清除、缺失或其他事件。这使开发人员能够在调优代码时做出明智的决策。</p><p>TMA 通过定义每个 uop 插槽所属的一系列层次状态来实现这一点。每个时钟周期，处理器的前端（负责指令获取和解码）可以向后端（指令执行和退休）发出一些由实现定义的数量（N）的指令&#x2F;uop。因此，每个时钟周期有 N 个 issue slots 需要分类。在 TMA 层次结构的最高层，issue slots 的分类如下所述。</p><p><img src="/tma-l1.svg"></p><table><thead><tr><th>Topdown <strong>Level 1</strong> State Descriptions</th><th>描述</th></tr></thead><tbody><tr><td>Frontend Bound</td><td>Slots where the frontend did not issue a uop to the backend, despite the backend being able to accept uops. Example causes include stalls that result from cache or TLB misses during instruction fetch.</td></tr><tr><td>Backend Bound</td><td>Slots where the backend could not consume a uop from the frontend. Example causes include backpressure that results from cache or TLB misses on data (load&#x2F;store) accesses, or from oversubscribed execution units.</td></tr><tr><td>Bad Speculation</td><td><strong>Uops that are dropped, as a result of a pipeline flush</strong>. Example flushes include <u>branch&#x2F;jump mispredictions</u>, <u>memory ordering clears</u>, <u>exceptions</u>, and <u>interrupts</u>. This state also includes slots that are <u>unfilled</u> by the frontend as the pipeline recovers from the flush, slots that otherwise would have been classified as Frontend Bound.</td></tr><tr><td>Retiring</td><td>Uops retired. Ideally the majority of slots fall into this state.</td></tr></tbody></table><p>上述事件是 level 1 层级的，还有 level 2 层级， level 3 层级，分别简写为 L1, L2, L3. <strong>这与缓存的层级是不同的概念</strong>。</p><p>The full standard hierarchy of TMA states is illustrated below.</p><p><img src="/tma-full2.svg"></p><ul><li><strong>前端限制 Frontend Bound</strong><ul><li><strong>前端延迟限制 Frontend Latency Bound</strong><ul><li>前端延迟的插槽是解码器正在等待获取数据的情况，因此没有 uops 可以交付给后端。前端延迟进一步细分为三个标准 L3 状态。</li><li><strong>地址 Frontend Address Latency</strong><ul><li>前端地址延迟是指前端在<strong>等待指令地址转换完成</strong>时的延迟。这段时间插槽未被填充。如，ITLB 缺失。当处理器<strong>fetch instruction</strong>时,会将指令的虚拟地址发送到 ITLB 进行地址转换。ITLB 缺失会进行 PTW 来获取物理地址。地址转换未完成，前端无法将物理地址发送到<strong>指令缓存</strong>。</li></ul></li><li><strong>数据 Frontend Data Latency</strong><ul><li>前端数据延迟是指前端在<strong>等待指令数据返回</strong>时的延迟。这段时间插槽未被填充。如，L1I Cache 未命中。当物理地址发送到指令缓存 I-Cache 时，如果 I-Cache 中没有对应的数据，会向更高层缓存或内存发起miss 请求。</li></ul></li><li><strong>重定向 Frontend Redirect Latency</strong><ul><li>是指由于<strong>控制转移</strong>指令（如跳转或分支）导致的前端流水线插槽被丢弃（空闲）的延迟。这种延迟主要发生在处理器的前端（Frontend），即指令获取（Instruction Fetch）和解码（Decode）阶段。<strong>控制转移</strong>是指程序执行流程的改变，如跳转、分支、函数调用或返回。<strong>前端重定向</strong>指当控制转移指令被执行时处理器需要从新的地址获取指令的过程，包括，指令预测、指令获取、流水线重置。</li></ul></li></ul></li><li><strong>前端带宽限制 Frontend bandwidth Bound</strong><ul><li>前端由于解码器的限制而没有向后端传递微操作（uop）的那些槽位，这些槽位没有被充分利用。解码器无法在一个时钟周期内解码<strong>足够</strong>的指令。<strong>前端带宽（Frontend Bandwidth）</strong> 是指前端在每个时钟周期内能够向后端提供的指令或微操作（uops）的数量。</li></ul></li></ul></li><li><strong>后端限制 Backend Bound</strong><ul><li><strong>核心限制 Core Bound</strong><ul><li>表示后端因除内存引起的停滞之外的其他原因停滞的槽位。只有一个标准的 L3 事件。</li><li><strong>Serialization Bound</strong>，为了保证指令顺序序列化而导致流水线<strong>暂停</strong>而阻塞的槽位。通常是为了维护内存一致性或处理同步指令。包括，fence、AMO、CSR指令等。</li><li><strong>Backpressure Bound</strong>，回压不是一个标准的 L3 事件，但也会导致 Core Bound slots 产生。回压主要是长延迟算术操作和执行单元过载引起。长延迟算术操作会导致执行单元被长时间占用，执行单元过载是指执行单元被分配了过多的任务。都会导致流水线插槽阻塞。</li></ul></li><li><strong>内存访问限制 Memory Bound</strong><ul><li>后端因内存操作（加载和存储）引起的停滞槽位，导致后端无法从前端接受 uops。可进一步细分为两个标准 L3 状态。</li><li><strong>内存地址限制 Memory Address Bound</strong><ul><li>内存地址限制表示后端因等待数据地址转换而停滞的槽位，例如由于 DTLB 缺失。这与前端的地址延迟类似，前端是指令地址转换，后端是数据地址转换。</li><li><strong>L1 TLB</strong></li><li><strong>LL TLB</strong></li><li><strong>Page Walk</strong></li></ul></li><li><strong>内存数据限制 Memory Data Bound</strong><ul><li>内存数据限制表示后端因等待加载或存储访问完成而停滞的槽位，例如由于 L1D 缓存缺失。这与前端数延迟类似，前端是指令，后端是内存数据。</li><li><strong>L1 D-Cache</strong></li><li><strong>LL Cache</strong></li><li><strong>External Memory</strong></li></ul></li></ul></li></ul></li></ul><table><thead><tr><th>TMA 事件</th><th>描述</th></tr></thead><tbody><tr><td>TOPDOWN.SLOTS$^\color{teal}{[1]}$</td><td>TMA slots available for an unhalted hart.</td></tr><tr><td>TOPDOWN.FRONTEND_BOUND.SLOTS</td><td>TMA slots stalled in the frontend, which implies slots where the frontend was unable to deliver a uop to the backend despite the backend being able to accept uops.</td></tr><tr><td><font size="1">TOPDOWN.FRONTEND_BOUND.BANDWIDTH.SLOTS</font></td><td>TMA slots stalled in the frontend due to decode bandwidth limitations, resulting in a reduced number of uops delivered to the backend.</td></tr><tr><td><font size="1">TOPDOWN.FRONTEND_BOUND.LATENCY.SLOTS</font></td><td>TMA slots stalled in the frontend due to fetch latency, resulting in no uops delivered to the backend.</td></tr><tr><td><font size="1">TOPDOWN.FRONTEND_BOUND.LATENCY.ADDR.SLOTS</font></td><td>TMA slots stalled in the frontend due to fetch address translation latency.</td></tr><tr><td><font size="1">TOPDOWN.FRONTEND_BOUND.LATENCY.DATA.SLOTS</font></td><td>TMA slots stalled in the frontend due to fetch data latency.</td></tr><tr><td><font size="1">TOPDOWN.FRONTEND_BOUND.LATENCY.REDIRECT.SLOTS</font></td><td>TMA slots stalled in the frontend due to fetch pipeline bubbles resulting from control transfer redirects.</td></tr><tr><td>TOPDOWN.BAD_SPECULATION.SLOTS</td><td>TMA slots wasted due to incorrect speculations. This includes slots used to issue uops that do not eventually retire, and slots for which the frontend did not deliver uops due to recovery from earlier incorrect speculation.</td></tr><tr><td><font size="1">TOPDOWN.BAD_SPECULATION.MISPREDICT.SLOTS$^\color{teal}{[2]}$</font></td><td>TMA slots wasted due to mispredicted branch or jump instructions.</td></tr><tr><td><font size="1">TOPDOWN.BAD_SPECULATION.MEM_ORDERING.SLOTS$^\color{teal}{[3]}$</font></td><td>TMA slots wasted due to pipeline clears that result from memory ordering violations.</td></tr><tr><td>TOPDOWN.BACKEND_BOUND.SLOTS</td><td>TMA slots backend stalled, which implies slots where the backend cannot accept uops due to a lack of backend resources.</td></tr><tr><td><font size="1">TOPDOWN.BACKEND_BOUND.MEMORY.SLOTS</font></td><td>TMA slots backend stalled due to stalls caused by load and store instructions.</td></tr><tr><td>TOPDOWN.BACKEND_BOUND.CORE.SLOTS</td><td>TMA slots backend stalled due to stalls caused by non-memory operations.</td></tr><tr><td><font size="1">TOPDOWN.BACKEND_BOUND.CORE.SERIALIZING.SLOTS</font></td><td>TMA slots backend stalled due to serializing operations like fence or csr accesses.</td></tr><tr><td><font size="1">TOPDOWN.BACKEND_BOUND.MEMORY.ADDR.SLOTS</font></td><td>TMA slots backend stalled waiting for address generation and translation.</td></tr><tr><td><font size="1">TOPDOWN.BACKEND_BOUND.MEMORY.ADDR.TLB.L1_MISS.SLOTS</font></td><td>TMA slots backend stalled waiting for address translations that missed the L1 TLB.</td></tr><tr><td><font size="1">TOPDOWN.BACKEND_BOUND.MEMORY.ADDR.TLB.LL_MISS.SLOTS</font></td><td>TMA slots backend stalled waiting for address translations that missed the last-level TLB.</td></tr><tr><td><font size="1">TOPDOWN.BACKEND_BOUND.MEMORY.DATA.SLOTS</font></td><td>TMA slots backend stalled waiting for load reads or store writes to complete.</td></tr><tr><td><font size="1">TOPDOWN.BACKEND_BOUND.MEMORY.DATA.L1_MISS.SLOTS</font></td><td>TMA slots backend stalled awaiting completion of loads or stores that missed the L1 cache.</td></tr><tr><td><font size="1">TOPDOWN.BACKEND_BOUND.MEMORY.DATA.LL_MISS.SLOTS</font></td><td>TMA slots backend stalled awaiting completion of loads or stores that missed the last-level cache.</td></tr></tbody></table><p>[1] 表示在给定时间段内处理器同时使用的指令槽位数量。它反映了处理器在每个时钟周期内可以处理的指令数量。假设处理器的流水线宽度为 $\omega$，程序运行的总时钟周期数为 <code>cpu_cycles</code>，则 TOPDOWN.SLOTS 的总数为：$\omega \times \text{cpu_cycles}$.<br>[2] 由于分支 (branch) 或跳转 (jump) 指令预测错误浪费的槽位。<br>[3] 由于内存排序违规导致的流水线<strong>清除</strong>而浪费的槽位。注意，Serialization 是针对流水线<strong>暂停</strong>。</p><h2 id="Other-Events"><a href="#Other-Events" class="headerlink" title="Other Events"></a>Other Events</h2><hr><p>该组包含不归属于其他组的一般事件。</p><table><thead><tr><th>Other Events</th><th>Description</th></tr></thead><tbody><tr><td>CYCLES.HART$^\color{teal}{[1]}$</td><td>Clock cycles executed by the processor core on which the hart is running. Ceases to increment when the hart is paused, such as during WFI, even if another hart running on the same core remains active. This clock is subject to clock-gating and frequency variations.</td></tr><tr><td>CYCLES.REF</td><td>Reference clock cycles. This event counts at a fixed frequency.</td></tr><tr><td>UOP.RET</td><td>Number of micro-operations retired.</td></tr><tr><td>UOP.SPEC</td><td>Number of micro-operations issued.</td></tr><tr><td>FLUSH.SPEC</td><td>Occurences of backend pipeline flushes, such as mispredictions or memory ordering violations.</td></tr><tr><td>FLUSH.CYCLES</td><td>Cycles to recover from backend pipeline flushes, such as mispredictions or memory ordering violations. Counts cycles the frontend is unable to deliver uops to the backend in the shadow of a backend pipeline flush.</td></tr><tr><td>RESTEER.SPEC$^\color{teal}{[2]}$</td><td>Occurences of frontend resteers, such as taken branch predictions, that introduce pipeline bubbles when resteering fetch to the target pc address.</td></tr><tr><td>RESTEER.CYCLES</td><td>Cycles to recover from frontend resteers, such as taken branch predictions, that introduce pipeline bubbles when resteering fetch to the target pc address. Counts the bubble cycles lost as a result of the resteers.</td></tr><tr><td>CTR.UPDATE.RET</td><td>Instructions retired and&#x2F;or traps delivered that are recorded by Control Transfer Records (CTR).</td></tr><tr><td>TRACE.STALL.CYCLES</td><td>Core cycles where retirement is stalled due to trace backpressure.</td></tr></tbody></table><p>[1] 预期 HPM CSR 和 cycle CSR 统计的结果相同。CPU空转是否计数？<br>[2] 前端重定向的次数。当预测为 taken branch 时，会进行重定向。当预测错误时，纠正重定向等。</p><h1 id="标准事件编码"><a href="#标准事件编码" class="headerlink" title="标准事件编码"></a>标准事件编码</h1><hr><p>RV Spec 定义了以下的标准事件编码。编码使用<code>mhpmeventX[4:0]</code>作为<code>SEL</code>字段。</p><table><thead><tr><th>mhpmeventX.SEL</th><th>描述</th></tr></thead><tbody><tr><td>0</td><td>No event</td></tr><tr><td>1</td><td>CYCLES.HART</td></tr><tr><td>2</td><td>INST.RET</td></tr><tr><td>3</td><td>CACHE.L1.RD.DATA.ACCESS</td></tr><tr><td>4</td><td>CACHE.L1.RD.DATA.MISS</td></tr><tr><td>5</td><td>INST.BRJMP.SPEC</td></tr><tr><td>6</td><td>INST.MISPRED.SPEC</td></tr><tr><td>7</td><td>Reserved, no event</td></tr><tr><td>8</td><td>Reserved, no event</td></tr><tr><td>9</td><td>Reserved, no event</td></tr><tr><td>10</td><td>CYCLES.REF</td></tr><tr><td>11</td><td>CACHE.L1I.RD.CODE.ACCESS</td></tr><tr><td>12</td><td>CACHE.L1I.RD.CODE.MISS</td></tr><tr><td>13</td><td>CACHE.LL.RD.DATA.ACCESS</td></tr><tr><td>14</td><td>CACHE.LL.RD.DATA.MISS</td></tr><tr><td>15</td><td>TLB.L1.LDST.ACCESS</td></tr><tr><td>16</td><td>TLB.L1.LDST.MISS</td></tr><tr><td>17</td><td>TLB.L1I.CODE.ACCESS</td></tr><tr><td>18</td><td>TLB.L1I.CODE.MISS</td></tr><tr><td>19</td><td>INST.BRJMP.TK.RET</td></tr><tr><td>20</td><td>TOPDOWN.SLOTS</td></tr><tr><td>21</td><td>TOPDOWN.RETIRING.SLOTS</td></tr><tr><td>22</td><td>TOPDOWN.FRONTEND_BOUND.SLOTS</td></tr><tr><td>23</td><td>TOPDOWN.BACKEND_BOUND.SLOTS</td></tr><tr><td>24</td><td>TOPDOWN.BAD_SPECULATION.SLOTS</td></tr><tr><td>25</td><td>Reserved, no event</td></tr><tr><td>26</td><td>Reserved, no event</td></tr><tr><td>27</td><td>Reserved, no event</td></tr><tr><td>28</td><td>Reserved, no event</td></tr><tr><td>29</td><td>Reserved, no event</td></tr><tr><td>30</td><td>Reserved, no event</td></tr><tr><td>31</td><td>Reserved, no event</td></tr></tbody></table><p>与 Linux Perf <strong>Hardware Events</strong> 的对应关系：</p><table><thead><tr><th><strong>Linux Perf Hardware Event</strong></th><th><strong>mhpmeventX.SEL</strong></th></tr></thead><tbody><tr><td>CPU_CYCLES</td><td>1 (CYCLES.HART)</td></tr><tr><td>INSTRUCTIONS</td><td>2 (INST.RET)</td></tr><tr><td>CACHE_REFERENCES</td><td>3 (CACHE.L1.RD.DATA.ACCESS)</td></tr><tr><td>CACHE_MISSES</td><td>4 (CACHE.L1.RD.DATA.MISS)</td></tr><tr><td>BRANCH_INSTRUCTIONS</td><td>5 (INST.BRJMP.SPEC)</td></tr><tr><td>BRANCH_MISSES</td><td>6 (INST.MISPRED.SPEC)</td></tr><tr><td>REF_CPU_CYCLES</td><td>10 (CYCLES.REF)</td></tr></tbody></table><p>与 Linux Perf <strong>Cache Events</strong> 的对应关系：</p><table><thead><tr><th><strong>Linux Perf Cache Event</strong></th><th><strong>mhpmeventX.SEL</strong></th></tr></thead><tbody><tr><td>CACHE_L1D_READ_ACCESS</td><td>3 (CACHE.L1.RD.DATA.ACCESS)</td></tr><tr><td>CACHE_L1D_READ_MISS</td><td>4 (CACHE.L1.RD.DATA.MISS)</td></tr><tr><td>CACHE_L1I_READ_ACCESS</td><td>11 (CACHE.L1I.RD.CODE.ACCESS)</td></tr><tr><td>CACHE_L1I_READ_MISS</td><td>12 (CACHE.L1I.RD.CODE.MISS)</td></tr><tr><td>CACHE_LL_READ_ACCESS</td><td>13 (CACHE.LL.RD.DATA.ACCESS)</td></tr><tr><td>CACHE_LL_READ_MISS</td><td>14 (CACHE.LL.RD.DATA.MISS)</td></tr><tr><td>CACHE_DTLB_READ_ACCESS</td><td>15 (TLB.L1.LDST.ACCESS)</td></tr><tr><td>CACHE_DTLB_READ_MISS</td><td>16 (TLB.L1.LDST.MISS)</td></tr><tr><td>CACHE_ITLB_READ_ACCESS</td><td>17 (TLB.L1I.CODE.ACCESS)</td></tr><tr><td>CACHE_ITLB_READ_MISS</td><td>18 (TLB.L1I.CODE.ACCESS)</td></tr><tr><td>CACHE_BPU_READ_ACCESS</td><td>5 (INST.BRJMP.SPEC)</td></tr><tr><td>CACHE_BPU_READ_MISS</td><td>6 (INST.MISPRED.SPEC)</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Performance </category>
          
          <category> RISC-V </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Zihpm </tag>
            
            <tag> HPE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搭建 x86 下的 riscv linux 开发平台</title>
      <link href="/2025/07/23/%E6%90%AD%E5%BB%BA-x86-%E4%B8%8B%E7%9A%84-riscv-linux-%E5%B9%B3%E5%8F%B0/"/>
      <url>/2025/07/23/%E6%90%AD%E5%BB%BA-x86-%E4%B8%8B%E7%9A%84-riscv-linux-%E5%B9%B3%E5%8F%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="搭建-riscv-linux-运行环境的方案"><a href="#搭建-riscv-linux-运行环境的方案" class="headerlink" title="搭建 riscv linux 运行环境的方案"></a>搭建 riscv linux 运行环境的方案</h1><ol><li>通过 qemu-system-riscv64 模拟 riscv linux 运行环境；</li></ol><ul><li>优点：运行环境搭建简单，适用于代码开发，方便固件、内核、用户代码调试；</li><li>缺点：带 linux 启动较慢，修改源码后需要反复重启；</li></ul><ol start="2"><li>通过 docker 提供 riscv linux 运行环境；</li></ol><ul><li>优点：可提供稳定的 os 环境，适用于应用代码开发测试；</li></ul><h1 id="搭建-docker-riscv-linux-运行环境"><a href="#搭建-docker-riscv-linux-运行环境" class="headerlink" title="搭建 docker riscv linux 运行环境"></a>搭建 docker riscv linux 运行环境</h1><p>wsl 中已安装docker，直接使用命令运行即可：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --privileged -p 1234:1234  -v &quot;$&#123;PWD&#125;&quot;:/workspace --platform linux/riscv64 -it riscv64/ubuntu</span><br></pre></td></tr></table></figure><p>在容器中可以安装gcc、gdb(不能使用)、make等工具。</p><h1 id="在容器中调试代码"><a href="#在容器中调试代码" class="headerlink" title="在容器中调试代码"></a>在容器中调试代码</h1><p>由于容器使用qemu模拟，所以gdb是不受支持的，可以通过qemu-riscv64-static暴露端口，然后使用gdb连接qemu，调试代码。</p><ol><li><p>在容器中：<br><code>qemu-riscv64-static -g 1234 test</code></p></li><li><p>在主机上：<br><code>riscv64-unknown-linux-gnu-gdb test -ex &quot;target remote localhost:1234&quot; -ex &#39;b main&#39;</code></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
          <category> riscv </category>
          
      </categories>
      
      
        <tags>
            
            <tag> riscv </tag>
            
            <tag> docker </tag>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RISC-V Debug Spec 学习笔记</title>
      <link href="/2025/06/30/RISC-V-Debug-Spec-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2025/06/30/RISC-V-Debug-Spec-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><hr><ul><li><a href="https://github.com/riscv/riscv-debug-spec">RISC-V Debug Spec</a></li><li>[RISC-V Debug Spec 学习笔记](RISC-V Debug Spec.xmind)</li></ul><h1 id="调试分类"><a href="#调试分类" class="headerlink" title="调试分类"></a>调试分类</h1><hr><p>下表是一些与调试相关的概率模型，阅读后可以建立一些对调试的认知。</p><table><thead><tr><th>分类维度</th><th>类型</th><th>适用场景</th><th>工具示例</th></tr></thead><tbody><tr><td>环境</td><td>本地调试</td><td>开发阶段快速验证</td><td>IDEA, GDB本地模式</td></tr><tr><td></td><td>远程调试</td><td>生产环境、嵌入式设备</td><td>GDB远程连接</td></tr><tr><td></td><td>交叉调试</td><td>跨平台</td><td>OpenOCD, JTAG</td></tr><tr><td>执行模式</td><td>静态调试</td><td>代码审查与早期错误检测</td><td>静态分析工具</td></tr><tr><td></td><td>动态调试</td><td>运行时问题定位</td><td>断点调试器</td></tr><tr><td>代码层级</td><td>源码级调试</td><td>应用逻辑错误</td><td>GDB带符号表, IDE调试器</td></tr><tr><td></td><td>机器级调试</td><td>底层系统开发</td><td>JTAG, 无符号表GDB</td></tr></tbody></table><p>RISC-V Debug Specification v1.0 中提到了2种调试的概率：<strong>Native Debug (sometimes called self-hosted Debug)</strong> 和 <strong>External Debug</strong>。<strong>Native Debug</strong> 有时被翻译成<u>本地调试</u>，有时被翻译成<u>原生调试</u>。这里将 <strong>Native Debug</strong> 简单的理解为本地调试，在 RISC-V 平台上运行的调试软件用于调试同一平台, 依赖处理器的调试单元，直接访问寄存器&#x2F;内存&#x2F;汇报指令。外部调试 <strong>External Debug</strong> 是指其他地方运行的调试软件，通过JTAG等调试传输方式调试 RISC-V 平台。</p><p>通读 Spec 全文后，<strong>Native Debug</strong> 和 <strong>External Debug</strong> 的明显区别是，<u><strong>Native Debug</strong> 依赖调试模块的触发器，通过异常机制触发，调试软件本身可能是系统的异常处理程序或监控程序，处于 Machine Mode 模式。<strong>External Debug</strong> 则必须通过 JTAG 等接通在其他平台上的调试软件，被调试的 RISC-V 平台的 CPU 受到外部调试软件的控制，通常处于 Debug Mode 模式（ CPU 的实现可能支持 CPU 运行状态下被调试）</u>。</p><p>Qemu 对模拟的 RISC-V 平台的调试，完全不依赖 RISC-V 内部的调试模块和触发器模块，而是 Qemu 本身提供的动态翻译器（ TCG ）模拟实现（断点设置、单步执行、寄存器读写等）。</p><h1 id="RISC-V-调试系统"><a href="#RISC-V-调试系统" class="headerlink" title="RISC-V 调试系统"></a>RISC-V 调试系统</h1><hr><h2 id="color-teal-RISC-V-调试系统简介"><a href="#color-teal-RISC-V-调试系统简介" class="headerlink" title="$\color{teal}{RISC-V 调试系统简介}$"></a>$\color{teal}{RISC-V 调试系统简介}$</h2><hr><p>基于外部调试的平台框图如下，</p><p><img src="/overview.png"></p><p>外部调试器 GDB, 将命令下发给命令翻译器 OpenOCD, OpenOCD将命令翻译成<strong>抽象命令</strong>（ Abstract Commands ）, OpenOCD与调试传输硬件（ JLINK ）进行通信，调试传输硬件与 RISC-V 平台上的调试接口（debug port， mipi-10 ）相连, 调试接口将收下来的串行序列输入<strong>调试传输模块</strong>（ Debug Transport Module ）, 调试传输模块 DTM 将串行数据转换成地址和数据，用于配置 DTM 中的寄存器。这些寄存器可以通过<strong>调试模块接口</strong> DMI 访问<strong>调试模块</strong> DM, 从而进一步控制整个系统。</p><p>DMI 可以支持7位到32位地址宽度。每个地址指向一个<strong>32位的寄存器</strong>。DMI 的总线管理器是 DTM, 下属是 DM. DMI 可以用 TileLink 或 AMBA 高级外围总线 APB 来实现。DTM 有自己的寄存器用于复位 DTM 模块本身和发起 DMI 事务。</p><p><em>通常</em>一个 core 中的所有 Hart 都由同一个调试模块控制。大多数 RISC-V 硬件平台上只包含一个调试模块。hart 是异构的也可以被同一个调试模块控制。规范不限制一个平台的 DM 数量，也不限制控制方式，但一个 Hart 只由一个调试模块控制，一个 DM 可控制 2^20 个 hart。</p><p>DM 包括 reset&#x2F;halt&#x2F;resume 控制模块，如 Rocket-Chip 上该功能由 <a href="https://github.com/chipsalliance/rocket-chip/tree/master/scripts/debug_rom">Debug ROM</a> 中的固化代码实现（后文图片中有该模块）。</p><p>DM 包括 <strong>Abstract Commands</strong> (AC)，用于查看 GPRs&#x2F;CSRs 寄存器、查看内存、执行程序缓冲区（ Program Buffer，最大支持64字节 ）。</p><p>可选地，DM 提供了 bus access 功能，直接和 System Bus 相连，绕过hart直接访问 Memory 空间。</p><p><strong>触发器模块</strong>（ Trigger Module ）是 Hart 内部的一部分，可用于<strong>Native Debug</strong>, 或 <strong>External Debug</strong>, Spec 提供了多种触发器：mcontrol，icount, itrigger, etrigger, tmexttrigger (tm ext trigger)。</p><h2 id="color-teal-Rocket-Chip-调试系统实现"><a href="#color-teal-Rocket-Chip-调试系统实现" class="headerlink" title="$\color{teal}{Rocket-Chip 调试系统实现}$"></a>$\color{teal}{Rocket-Chip 调试系统实现}$</h2><hr><p>下图是 Rocket-Chip 的调试系统结构。JTAG Interface 负责接收数据，与 DTM 一起将串行数据转换成寄存器地址和数据，从而发起 DMI 事务。图中 “External” 部分实现了 Spec 中的 “JTAG DTM” 模块（6.1章节）。</p><p><img src="/Rocket-Chip.png" alt="alt text"></p><p>DM 模块分 <strong>Outer</strong> 部分和 <strong>Inner</strong> 部分，</p><p><strong>Outer</strong> 处理 DMI 与内部调试模块之间的接口。它维护即使在主系统复位时也需要访问的寄存器：</p><ul><li>DMCONTROL: 调试控制寄存器</li><li>HARTINFO: Hart 特性信息</li><li>HAWINDOWSEL&#x2F;HAWINDOW: 硬件线程数组选择用于多硬件线程系统</li></ul><p>有如下功能:</p><ul><li>Hart selection logic</li><li>Debug module activation</li><li>Reset control</li><li>Hart array mask for multi-Hart operations</li><li>Halt-on-reset functionality</li></ul><p><strong>Inner</strong> 实现了核心调试功能：</p><ul><li>Debug ROM and RAM, 负责 reset&#x2F;halt&#x2F;resume 等控制</li><li>Abstract Command Engine</li><li>Program Buffer</li><li>Register access mechanisms</li><li>System Bus Access interface</li></ul><p>负责处理:</p><ul><li>Execution of abstract commands (register access)</li><li>Program buffer execution</li><li>Halt&#x2F;resume&#x2F;reset of harts(debug rom)</li><li>System bus access for memory and peripheral debugging</li></ul><p>**抽象命令（Abstract Command）**机制是 DM 模块的核心功能。Rocket-Chip DM 模块通过 Debug ROM 模块提供了基本的复位&#x2F;暂停（停止）&#x2F;单步&#x2F;恢复等 Hart 的运行状态控制功能，而抽象命令则提供了 Hart 内部 CSRs 和 GPRs 的访问功能。</p><p><strong>Program buffer</strong>是一个最大64字节的 RAM 空间，调试器可以将任意 Hart 支持的指令写入该区域，然后通过抽象命令使 Hart 执行 program buffer 中的指令。</p><p><strong>System Bus Access</strong> SBA 是 Rocket-Chip DM 模块提供的一种用于访问内存和外设的机制。模块直接与系统总线相连，可绕过 hart。</p><h2 id="color-teal-OpenOCD-调试模型"><a href="#color-teal-OpenOCD-调试模型" class="headerlink" title="$\color{teal}{OpenOCD 调试模型}$"></a>$\color{teal}{OpenOCD 调试模型}$</h2><hr><p>OpenOCD 支持 RISC-V Debug Specification v1.0, 针对规范实现模型如下，</p><p><img src="/OpenOCD_debug.png" alt="alt text"></p><p>OpenOCD 实现了规范要求的和可选的<strong>3种抽象命令</strong>，包括寄存器访问、内存访问、程序缓冲区，以及非抽象访问的系统总线访问。hart 控制部分未在途中体现。</p><h3 id="vdash-寄存器访问实现"><a href="#vdash-寄存器访问实现" class="headerlink" title="$\vdash$ 寄存器访问实现"></a>$\vdash$ 寄存器访问实现</h3><hr><p>寄存器访问是命令类型 <strong>cmdtype &#x3D; 0</strong> 的抽象命令。OpenOCD 实现的访问流程如下，</p><ol><li>确认命令是否可以执行，通常是通过cmderr状态查看；</li><li>配置将访问的 Hart，设置命令编码；</li><li>将命令写入调试模块，执行命令；</li><li>检查目标 Hart 是否正在执行命令，检查是否有报错；</li><li>命令执行完成，没有错误时，从 DM_DATA 寄存器中回读数据；</li><li>若命令执行错误，则处理错误；</li></ol><p><img src="/Register_access.png" alt="alt text"></p><h3 id="vdash-内存访问实现"><a href="#vdash-内存访问实现" class="headerlink" title="$\vdash$ 内存访问实现"></a>$\vdash$ 内存访问实现</h3><hr><p>内存访问是命令类型 <strong>cmdetype &#x3D; 2</strong> 的抽象命令。OpenOCD 实现的访问流程如下，</p><ol><li>先对总线状态进行检查，若总线可用，没有错误需要处理，则可发起内存访问；</li><li>实际进行读写访问。图中read&#x2F;write是OpenOCD对访问方向的抽象，并不是寄存器的字段；</li><li>检查命令是否执行完成，若完成，则检查执行结果，是否有报错；</li><li>根据错误情况进行相应处理；</li></ol><p><img src="/Memory_access.png" alt="alt text"></p><p><a id="调试数据链路"> </a></p><h2 id="color-teal-调试数据链路"><a href="#color-teal-调试数据链路" class="headerlink" title="$\color{teal}{调试数据链路}$"></a>$\color{teal}{调试数据链路}$</h2><hr><p>以下是平台侧的数据链路示意图，</p><ul><li>JTAG DTM 转换 JTAG Port 上的数据，主要实现 DMI 事务的生成工作；</li><li>DMI 事务发送给 DM 模块处理，dmcontrol 寄存器可以实现 Hart 选择、暂停、恢复等的控制，command 寄存器则是实际抽象命令，progbuf0<del>15 寄存器用于对程序缓冲区的写入，data0</del>11 寄存器用于数据的访问，sbcs&#x2F;sbdata&#x2F;sbaddress 寄存器则用于对内存的访问；</li><li>寄存器访问抽象命令中使用 regno 字段来映射要访问的 GPRs 或 CSRs；</li><li>Hart 内部实现了 RISC-V Debug Spec 定义的 Sdext 和 Sdtrig ISA 扩展。</li></ul><p><img src="/data_chain.png" alt="alt text"></p><h1 id="RISC-V-Debug-Spec"><a href="#RISC-V-Debug-Spec" class="headerlink" title="RISC-V Debug Spec"></a>RISC-V Debug Spec</h1><hr><h2 id="color-teal-RISC-V-Debug-Spec-组织形式"><a href="#color-teal-RISC-V-Debug-Spec-组织形式" class="headerlink" title="$\color{teal}{RISC-V Debug Spec 组织形式}$"></a>$\color{teal}{RISC-V Debug Spec 组织形式}$</h2><hr><ol><li>第一章简要介绍了调试的必要性、术语、规范适用于哪些标准的指令集扩展、历史版本、寄存器定义、<strong>ISA 与 non-ISA</strong>、调试定义、<strong>常用调试场景</strong>、<strong>规范中描述的调试接口支持的特性</strong>。</li><li>第二章简要介绍了 RISC-V 调试平台。</li><li>第三章详细介绍了调试模块 DM，这是 non-ISA 部分，相关寄存器通过地址 Map 偏移给出而不是 CSRs. <u>该部分详细约定了 DMI，系统复位控制、Hart 选择、调试状态、分组、抽象命令、程序缓冲区、系统总线访问、最小侵入调试、安全、DM 寄存器等内容</u>。</li><li>第四章介绍 Sdext ISA 扩展，由于是 ISA 扩展，这部分的寄存器 dpc&#x2F;dcsr&#x2F;dscratch 是通过 CSRs 方式访问。<u>该扩展只用于外部调试，定义了与外部调试相关的行为规范。定义了<strong>调试模式</strong>、lr&#x2F;sc&#x2F;wfi&#x2F;wrs等指令在调试模式的处理、单步调试、hart 复位、暂停、恢复、寄存器。</u>要实现外部调试就必须实现第三章约定的 DM non-ISA 规范和第四章的 Sdext ISA 扩展(必要)。</li><li>第五章介绍 Sdtrig ISA 扩展，定义了触发器模块的行为规范。触发器可以提供断点功能，可以使调试器在任意位置进行调试。此外，本地调试的实现离不开触发器。</li><li>第六章介绍了 JTAG DTM，Port, JTAG TAP等，约束了物理上的连接器。</li><li>附录A介绍了规范的硬件实现，附录B介绍了调试器的实现，这部分<strong>提供了很多示例</strong>。</li></ol><h2 id="color-teal-调试模块-DM"><a href="#color-teal-调试模块-DM" class="headerlink" title="$\color{teal}{调试模块 DM}$"></a>$\color{teal}{调试模块 DM}$</h2><hr><p>此节对于 Spec 的第三章。</p><h3 id="vdash-复位控制"><a href="#vdash-复位控制" class="headerlink" title="$\vdash$ 复位控制"></a>$\vdash$ 复位控制</h3><hr><p>调试模块支持3种复位方式和区域：</p><ol><li>dmcontrol.ndmreset: 复位 not debug module 区域。除了 DM&#x2F;DTM&#x2F;DMI, 平台上的其余部分都复位。</li><li>dmcontrol.hartreset: 重置选中的 harts.</li><li>dmcontrol.dmactive: 调试模块自身的状态和寄存器重置。</li></ol><h3 id="vdash-Harts-选择"><a href="#vdash-Harts-选择" class="headerlink" title="$\vdash$ Harts 选择"></a>$\vdash$ Harts 选择</h3><hr><p>调试器需要调试哪个 Hart, 或同时<u>暂停、恢复和复位</u>哪些 harts，由 dmcontrol.hartsel、hawindowsel、hawindow 等寄存器控制。hartsel 有20位，所以一个 DM 可以支持最多2^20个 Hart. DM 内部维护一个 Hart 数组掩码寄存器，每个位对应一个 Hart. 通过 hawindowsel * 32 + hawindow 来设置这些位。</p><p>调试模块提供的抽象命令功能不支持多 Hart 访问机制，仅对 hartsel 选中的 Hart 有效。</p><h3 id="vdash-Hart-DM-状态"><a href="#vdash-Hart-DM-状态" class="headerlink" title="$\vdash$ Hart DM 状态"></a>$\vdash$ Hart DM 状态</h3><hr><p>每个可以被选择的 Hart 都处于以下四种 <u>DM 状态</u>之一：<strong>不存在</strong>、<strong>不可用</strong>、<strong>运行</strong>或<strong>停止</strong>。可以通过执行命令并检查 dmstatus 寄存器查询。</p><h3 id="vdash-运行控制"><a href="#vdash-运行控制" class="headerlink" title="$\vdash$ 运行控制"></a>$\vdash$ 运行控制</h3><hr><p>对于可访问的 Hart, DM 会跟踪4个概念状态位（内部）：<strong>halt request</strong>, <strong>resume ack</strong>, <strong>halt-on-reset request</strong>, <strong>Hart reset</strong>. 并在 dmstatus 寄存器中提供状态位来表示其状态。</p><h3 id="vdash-暂停组（Halt-groups），恢复组（resume-groups），外部触发器"><a href="#vdash-暂停组（Halt-groups），恢复组（resume-groups），外部触发器" class="headerlink" title="$\vdash$ 暂停组（Halt groups），恢复组（resume groups），外部触发器"></a>$\vdash$ 暂停组（Halt groups），恢复组（resume groups），外部触发器</h3><hr><p>Hart&#x2F;外部触发器在一个时刻恰好只能属于一个暂停组和一个恢复组（二者缺一不可，不能属于多个暂停组或多个恢复组，可控性和一致性），组号为0是特殊的，组0中的 Hart 暂停&#x2F;恢复时，全系统暂停&#x2F;恢复。实现时可以硬件固定也可软件配置。分组和多hart选择一起实现同构&#x2F;异构hart的<strong>多核多线程同步调试</strong>。DM 重置时，所有 Hart 被放置在 Hart 可以被放置的最低编号的 halt 组和 resume 组（通常是组0）。</p><p>暂停组中的任何 Hart 暂停或组中的外部触发器触发时，暂停组中正在运行的 Hart 迅速暂停。这些 Hart 的原因应设置为6（group）或3（haltreq）。暂停组中正在恢复的hart也迅速暂停。</p><p>恢复组中任何 Hart 恢复或组中的外部触发器触发时，恢复组中所有被暂停的 hart，只要当前执行的抽象命令完成，就迅速恢复。正在暂停过程中的 Hart 应完成暂停过程并保持暂停状态。</p><p>外部触发器，是一个抽象概念，可以向 DM 发送信号或从 DM 接收信号，通过 dmcs2 寄存器来完成，外部触发器通过编号来引用。硬件平台中并非所有的内核都是 RISC-V 的，使用外部触发器可以实现所有内核几乎同时暂停&#x2F;恢复。</p><h3 id="vdash-抽象命令"><a href="#vdash-抽象命令" class="headerlink" title="$\vdash$ 抽象命令"></a>$\vdash$ 抽象命令</h3><hr><p>调试器通过将32位的抽象命令写入 command 寄存器来发起抽象命令的执行，写入时 abstractcs.busy 被设置。抽象命名分3种，</p><ol><li>访问寄存器命令：通过 regno 来映射 GPRs 和 CSRs, 从而读取 Hart 内部的通用寄存器和 CSRs 寄存器。</li><li>快速访问（quick access）：不访问任何寄存器或内存，而是执行程序缓冲区中的代码。</li><li>访问内存命令：通过 Hart 执行的方式访问内存空间。注意，通过总线访问内存空间不属于抽象命令。</li></ol><p>DM 模块提供了 data0~data11 来作为抽象命令的参数，arg0&#x2F;arg1&#x2F;arg2，具体分配如下，</p><table><thead><tr><th align="center">Argument width</th><th>arg0&#x2F;return value</th><th>arg1&#x2F;address</th><th>arg2</th></tr></thead><tbody><tr><td align="center">32</td><td>data0</td><td>data1</td><td>data2</td></tr><tr><td align="center">64</td><td>data0, data1</td><td>data2, data3</td><td>data4, data5</td></tr><tr><td align="center">128</td><td>data0-data3</td><td>data4-data7</td><td>data8-data11</td></tr><tr><td align="center">数据组装采用LSB方式。</td><td></td><td></td><td></td></tr></tbody></table><h3 id="vdash-程序缓冲区"><a href="#vdash-程序缓冲区" class="headerlink" title="$\vdash$ 程序缓冲区"></a>$\vdash$ 程序缓冲区</h3><hr><p>程序缓冲区最大支持64字节，最小支持4字节。程序缓冲区的代码必须以 ebreak 指令结束。ebreak 可以是程序缓冲区内的代码，也可以是硬件实现的代码，在程序缓冲区代码执行后紧跟着执行。当 Halted 时，可以直接将指令填充到流水线中执行而不是地址RAM空间，这在程序缓冲区只有4字节时适用。而大于4字节时，程序缓冲区可能实现为 RAM。Hart 像执行 M 模式的程序代码那样执行程序缓冲区的代码。</p><h3 id="vdash-Hart-调试状态（Debug-States）"><a href="#vdash-Hart-调试状态（Debug-States）" class="headerlink" title="$\vdash$ Hart 调试状态（Debug States）"></a>$\vdash$ Hart 调试状态（Debug States）</h3><hr><p>下图是 Spec 提供的<strong>单 Hart 运行&#x2F;暂停过程中经过的状态的概念视图</strong>，这些状态和转换受到 dmcontrol、 abstractcs、abstractauto 和 command 中不同字段的影响。</p><p><img src="/abstract_commands.png"></p><p>寄存器&#x2F;内存访问抽象命令可以在 Hart 暂停&#x2F;运行时被发起，快速访问只能在 Hart 运行的状态下发起。否则，将发生错误。在发起抽象命令而执行程序缓冲区代码时，Hart 保持在调试模式。是否处于调试模式可以通过 dcsr 寄存器判读。</p><h3 id="vdash-系统总线访问-SBA"><a href="#vdash-系统总线访问-SBA" class="headerlink" title="$\vdash$ 系统总线访问 SBA"></a>$\vdash$ 系统总线访问 SBA</h3><hr><p>DM 模块提供了 sbdata*, sbaddress*, sbcs 寄存器来控制对总线上的内存空间的访问，而不影响 Hart 的执行。通过读写 sbdata0 来发起对内存空间的访问。</p><h3 id="vdash-最小侵入调试"><a href="#vdash-最小侵入调试" class="headerlink" title="$\vdash$ 最小侵入调试"></a>$\vdash$ 最小侵入调试</h3><hr><p>最小侵入调试，对 Hart 的影响最小，有3种方式，</p><ol><li>规范允许所有抽象命令在不中断 Hart 的情况下执行，取决于实现；</li><li>快速访问抽象命令可以用来暂停 Hart,快速执行程序缓冲区的内容,然后让 Hart 再次运行；</li><li>系统总线访问可以在hart运行时用来访问系统内存。</li></ol><h3 id="vdash-安全"><a href="#vdash-安全" class="headerlink" title="$\vdash$ 安全"></a>$\vdash$ 安全</h3><hr><p>规范定义了 authdata 寄存器用于密钥认证方式解锁&#x2F;上锁 DM。并规范了上锁状态下调试器的访问范围。</p><h3 id="vdash-Debug-Module-Registers"><a href="#vdash-Debug-Module-Registers" class="headerlink" title="$\vdash$ Debug Module Registers"></a>$\vdash$ Debug Module Registers</h3><hr><h4 id="vDash-DM-寄存器的访问方式"><a href="#vDash-DM-寄存器的访问方式" class="headerlink" title="$\vDash$ DM 寄存器的访问方式"></a>$\vDash$ DM 寄存器的访问方式</h4><p>由于 DM 模块是 non-ISA 的，所以寄存器是以偏移的形式存在，而不是 CSRs. Spec 上描述了 DM 寄存器是通过 DMI 总线访问的，并未说明是否通过 Memory-Mapped 的方式暴露给 Hart. 但是，从 Rocket-Chip 或其他实现上看，是有暴露的。</p><p>以下是 <a href="https://github.com/pulp-platform/riscv-dbg/blob/master/doc/debug-system.md">Rocket-Chip 实现的系统框图</a><br><img src="/debugsys_schematic.svg"></p><p>Rocket-Chip：调试模块作为设备连接到系统总线，暴露<strong>调试内存</strong>（程序缓冲区和调试 ROM），并作为系统总线访问（SBA）功能的主机。调试模块通过其设备总线接口暴露了 16 kB 的内存。该内存称为调试内存，它由一个包含 Debug ROM 模块的 ROM 部分、多个内存映射的控制和状态寄存器以及一个 RAM 部分，程序缓冲区组成。调试内存仅应在调试模式下由 CPU 访问。</p><p>Rocket-Chip，暴露的 Memory-Mapped 映射表如下。</p><table><thead><tr><th>Address</th><th>Description</th></tr></thead><tbody><tr><td>0x0 to 0x0ff</td><td><em>unused</em></td></tr><tr><td>0x100</td><td>Halted. Write to this address to acknowledge that the core is halted.</td></tr><tr><td>0x108</td><td>Going. Write to this address to acknowledge that the core is executing.</td></tr><tr><td>0x110</td><td>Resuming. Write to this address to acknowledge that the core is resuming non-debug operation.</td></tr><tr><td>0x118</td><td>Exception. An exception was triggered while the core was in debug mode.</td></tr><tr><td>0x300</td><td>WhereTo</td></tr><tr><td>0x338 to 0x35f</td><td>AbstractCmd</td></tr><tr><td>0x360 to 0x37f</td><td>Program Buffer (8 words)</td></tr><tr><td>0x380 to 0x388</td><td>DataAddr</td></tr><tr><td>0x400 to 0x7ff</td><td>Flags</td></tr><tr><td>0x800 to 0x1000</td><td>Debug ROM</td></tr><tr><td>0x800</td><td>HaltAddress. Entry point into the Debug Module. The core must jump to this address when it was requested to halt.</td></tr><tr><td>0x808</td><td>ResumeAddress. Entry point into the Debug Module. Jumping to this address instructs the debug module to bring the core out of debug mode and back into normal operation mode.</td></tr><tr><td>0x810</td><td>ExceptionAddress. Entry point into the Debug Module. The core must jump to this address when it receives an exception while being in debug mode.</td></tr></tbody></table><p>从映射表看，映射的实现<strong>并不是</strong>将 DM 寄存器整体打包映射到某个基地址，而是对 DM 的单个寄存器或字段集中映射到一个地址段。比如，Program Buffer 实际就是用 RAM 实现的，然后整体映射到 DM 的 progbuf0~15 上。又如，Halted, Going, Resuming 等是对 DM 寄存器请求位相关<strong>字段</strong>的映射而非当个寄存器。</p><h4 id="vDash-Spec-定义的寄存器"><a href="#vDash-Spec-定义的寄存器" class="headerlink" title="$\vDash$ Spec 定义的寄存器"></a>$\vDash$ Spec 定义的寄存器</h4><table><thead><tr><th>Address</th><th>Name</th><th>Spec. Section</th></tr></thead><tbody><tr><td>0x04</td><td>Abstract Data 0 (data0)</td><td>Section 3.14.14</td></tr><tr><td>0x05</td><td>Abstract Data 1 (data1)</td><td></td></tr><tr><td>0x06</td><td>Abstract Data 2 (data2)</td><td></td></tr><tr><td>0x07</td><td>Abstract Data 3 (data3)</td><td></td></tr><tr><td>0x08</td><td>Abstract Data 4 (data4)</td><td></td></tr><tr><td>0x09</td><td>Abstract Data 5 (data5)</td><td></td></tr><tr><td>0x0a</td><td>Abstract Data 6 (data6)</td><td></td></tr><tr><td>0x0b</td><td>Abstract Data 7 (data7)</td><td></td></tr><tr><td>0x0c</td><td>Abstract Data 8 (data8)</td><td></td></tr><tr><td>0x0d</td><td>Abstract Data 9 (data9)</td><td></td></tr><tr><td>0x0e</td><td>Abstract Data 10 (data10)</td><td></td></tr><tr><td>0x0f</td><td>Abstract Data 11 (data11)</td><td></td></tr><tr><td>0x10</td><td>Debug Module Control (dmcontrol)</td><td>Section 3.14.2</td></tr><tr><td>0x11</td><td>Debug Module Status (dmstatus)</td><td>Section 3.14.1</td></tr><tr><td>0x12</td><td>Hart Info (hartinfo)</td><td>Section 3.14.3</td></tr><tr><td>0x13</td><td>Halt Summary 1 (haltsum1)</td><td>Section 3.14.19</td></tr><tr><td>0x14</td><td>Hart Array Window Select (hawindowsel)</td><td>Section 3.14.4</td></tr><tr><td>0x15</td><td>Hart Array Window (hawindow)</td><td>Section 3.14.5</td></tr><tr><td>0x16</td><td>Abstract Control and Status (abstractcs)</td><td>Section 3.14.6</td></tr><tr><td>0x17</td><td>Abstract Command (command)</td><td>Section 3.14.7</td></tr><tr><td>0x18</td><td>Abstract Command Autoexec (abstractauto)</td><td>Section 3.14.8</td></tr><tr><td>0x19</td><td>Configuration Structure Pointer 0 (confstrptr0)</td><td>Section 3.14.9</td></tr><tr><td>0x1a</td><td>Configuration Structure Pointer 1 (confstrptr1)</td><td>Section 3.14.10</td></tr><tr><td>0x1b</td><td>Configuration Structure Pointer 2 (confstrptr2)</td><td>Section 3.14.11</td></tr><tr><td>0x1c</td><td>Configuration Structure Pointer 3 (confstrptr3)</td><td>Section 3.14.12</td></tr><tr><td>0x1d</td><td>Next Debug Module (nextdm)</td><td>Section 3.14.13</td></tr><tr><td>0x1f</td><td>Custom Features (custom)</td><td>Section 3.14.31</td></tr><tr><td>0x20</td><td>Program Buffer 0 (progbuf0)</td><td>Section 3.14.15</td></tr><tr><td>0x21</td><td>Program Buffer 1 (progbuf1)</td><td></td></tr><tr><td>0x22</td><td>Program Buffer 2 (progbuf2)</td><td></td></tr><tr><td>0x23</td><td>Program Buffer 3 (progbuf3)</td><td></td></tr><tr><td>0x24</td><td>Program Buffer 4 (progbuf4)</td><td></td></tr><tr><td>0x25</td><td>Program Buffer 5 (progbuf5)</td><td></td></tr><tr><td>0x26</td><td>Program Buffer 6 (progbuf6)</td><td></td></tr><tr><td>0x27</td><td>Program Buffer 7 (progbuf7)</td><td></td></tr></tbody></table><h2 id="color-teal-Sdext-ISA-扩展"><a href="#color-teal-Sdext-ISA-扩展" class="headerlink" title="$\color{teal}{Sdext ISA 扩展}$"></a>$\color{teal}{Sdext ISA 扩展}$</h2><hr><p>此节对应 Spec 的第四章。<strong>Sdext 扩展仅在与外部调试结合使用时才需要</strong>。该扩展定义了外部调试时<strong>需要 RISC-V 内核所做的最小修改</strong>，包括定义了调试模式和一些CSR，DM负责外部调试的其余部分。Sdext 扩展对 Halt&#x2F;resume&#x2F;step&#x2F;reset 等行为进行了定义。</p><h3 id="vdash-调试模式"><a href="#vdash-调试模式" class="headerlink" title="$\vdash$ 调试模式"></a>$\vdash$ 调试模式</h3><hr><p>调试模式是一种特殊的处理器模式,仅在 hart 因外部调试而停止时进入调试模式。dcsr 寄存器会更新，类似于trap时mstatus更新，cause 字段会记录进入调试模式的原因（具体参见<a href="#%E6%9A%82%E5%81%9C%E6%B5%81%E7%A8%8B">暂停流程</a>）。</p><p>调试模式具有比 M 模式更高的特权等级。</p><p>当 Hart <strong>由于抽象命令而执行代码</strong>时（寄存器访问和快速访问都会导致 Hart 执行程序缓冲区中的代码，除此之外，Rocket-Chip 还会因为resume等操作而执行 Debug ROM 中的代码，但这本身就在调试模式。在 Hart 暂停的状态下让 Hart 运行，可以通过 resume 达到，这会退出调试模式，也可以通过执行 Program buffer 达到，这不会退出调试模式，也不会更新 dcsr ，所以还在调试模式），<strong>Hart 保持在调试模式中</strong>。规范支持在 Hart 运行时发起寄存器&#x2F;内存访问抽象命令，快速命令需要在 Hart 运行时发起。</p><p>执行程序缓冲区时，</p><ul><li>代码以 M 特权执行，执行PMP检查；</li><li>所有中断（包括 NMI ）都禁用；</li><li>所有异常都禁用；</li><li>触发器不匹配不触发；</li><li>计数器不计数；</li><li>几乎所有改变特权模式的指令（ ecall, *ret ）都未指定行为，ebreak 例外，执行时会结束程序缓冲区的执行。</li></ul><p>进入调试模式时，由于不同原因，优先级也不同，</p><table><thead><tr><th align="center">cause 字段编码（高优先级到低优先级）</th><th>描述</th></tr></thead><tbody><tr><td align="center">5</td><td>resethaltreq</td></tr><tr><td align="center">6</td><td>halt group</td></tr><tr><td align="center">3</td><td>haltreq</td></tr><tr><td align="center">2</td><td>trigger （由于触发器类型不同，还可以细分，见 Spec.）</td></tr><tr><td align="center">1</td><td>ebreak</td></tr><tr><td align="center">4</td><td>step</td></tr></tbody></table><h3 id="vdash-单步-Step"><a href="#vdash-单步-Step" class="headerlink" title="$\vdash$ 单步 Step"></a>$\vdash$ 单步 Step</h3><hr><ol><li>当 dcsr.step &#x3D; 1 时，暂停的 Hart 执行单个指令后会<strong>重新进入调试模式</strong>；</li><li>通过触发器 icount 匹配到执行的指令数量后会在 action &#x3D; 1 时进入调试模式；</li></ol><h3 id="vdash-Hart-复位"><a href="#vdash-Hart-复位" class="headerlink" title="$\vdash$ Hart 复位"></a>$\vdash$ Hart 复位</h3><hr><p>dmcontrol.haltreq &#x3D; 1 或 dmstatus.hasresethaltreq &#x3D; 1 时，Hart 复位后，在执行第一条指令时（还未执行）先进入调试模式。</p><p><a id="暂停流程"></a></p><h3 id="vdash-暂停（halt）流程"><a href="#vdash-暂停（halt）流程" class="headerlink" title="$\vdash$ 暂停（halt）流程"></a>$\vdash$ 暂停（halt）流程</h3><hr><ol><li>dcsr.cause dcsr.prv, dcsr.v，dcsr.pelp 被更新；</li><li>dpc 被更新；</li><li>当前指令可以部分执行并且需要重新启动才能完成，则会更新执行了的部分关联的状态（也就是说可以部分执行的指令会被halt行为打断执行状态，为了保证能正常恢复执行，需要保存中间态）。例如，向量执行过程中被halt行为打断，则需要更新vstart来记录恢复后需要从哪开始继续执行；</li><li>Hart 进入调试模式；</li></ol><h3 id="vdash-恢复（resume）流程"><a href="#vdash-恢复（resume）流程" class="headerlink" title="$\vdash$ 恢复（resume）流程"></a>$\vdash$ 恢复（resume）流程</h3><hr><ol><li>PC 更新为 dpc;</li><li>当前特权模式&#x2F;虚拟化模式更改为 prv&#x2F;v 指定的模式，dcsr 更新；</li><li>新的特权模式（dcsr.prv 指定）比 M 特权级别低，mstatus.mprv 被清除；</li><li>若双陷阱扩展 Smdbltrp 被实现，则更新 MDT&#x2F;SDT 字段；</li><li>Hart 退出调试模式并运行；</li></ol><h3 id="vdash-Core-Debug-Registers"><a href="#vdash-Core-Debug-Registers" class="headerlink" title="$\vdash$ Core Debug Registers"></a>$\vdash$ Core Debug Registers</h3><hr><p>Sdext 扩展是 ISA 扩展，寄存器是 CSRs.</p><table><thead><tr><th>Address</th><th>Name</th><th>Spec. Section</th></tr></thead><tbody><tr><td>0x7b0</td><td>Debug Control and Status (dcsr)</td><td>Section 4.9.1</td></tr><tr><td>0x7b1</td><td>Debug PC (dpc)</td><td>Section 4.9.2</td></tr><tr><td>0x7b2</td><td>Debug Scratch Register 0 (dscratch0)</td><td>Section 4.9.3</td></tr><tr><td>0x7b3</td><td>Debug Scratch Register 1 (dscratch1)</td><td>Section 4.9.4</td></tr></tbody></table><h2 id="color-teal-Sdtrig-ISA-扩展"><a href="#color-teal-Sdtrig-ISA-扩展" class="headerlink" title="$\color{teal}{Sdtrig ISA 扩展}$"></a>$\color{teal}{Sdtrig ISA 扩展}$</h2><hr><p>此节对应 Spec 的第五章。针对 Hart 内部的<strong>触发器 Trigger Module</strong> 进行定义。触发可以导致断点异常、进入调试模式或跟踪操作,而无需执行特殊指令。GDB等调试器的 breakpoints, watchpoints 基于触发器实现。</p><h3 id="vdash-触发后行为动作-Actions"><a href="#vdash-触发后行为动作-Actions" class="headerlink" title="$\vdash$ 触发后行为动作 Actions"></a>$\vdash$ 触发后行为动作 Actions</h3><hr><p>Action 是触发器寄存器的一个字段，每类触发器寄存器都有这个字段，用于约定触发器触发后的硬件行为。Spec 定义了如下几种行为，</p><table><thead><tr><th align="center">action 字段编码</th><th>描述</th></tr></thead><tbody><tr><td align="center"><strong>0</strong></td><td>设置断点异常。用于软件希望使用触发器模块而无需连接外部调试器时。用于实现本地调试。</td></tr><tr><td align="center"><strong>1</strong></td><td>进入调试模式。</td></tr><tr><td align="center">2</td><td>Trace on.</td></tr><tr><td align="center">3</td><td>Trace off.</td></tr><tr><td align="center">4</td><td>Trace notify.</td></tr><tr><td align="center">5</td><td>Reserved for trace.</td></tr><tr><td align="center">8-9</td><td>向触发器模块外部输出0&#x2F;1</td></tr><tr><td align="center">other</td><td>Reserved.</td></tr></tbody></table><h3 id="vdash-触发器优先级"><a href="#vdash-触发器优先级" class="headerlink" title="$\vdash$ 触发器优先级"></a>$\vdash$ 触发器优先级</h3><hr><p>触发器通过断点异常触发时，异常编码为3（breakpoint），在异常处理中的优先级如下，</p><table border='1'>  <thead align='center'>    <tr>      <td> Priority </td>      <td> Exception Code </td>      <td> Description </td>      <td> Trigger </td>    </tr>  </thead>  <tbody align='left'>    <tr>      <td rowspan='4' align='center'> Highest </td>      <td> 3 </td>      <td rowspan='4'>  </td>      <td> etrigger </td>    </tr>    <tr>      <td> 3 </td>      <td> icount </td>    </tr>    <tr>      <td> 3 </td>      <td> itrigger </td>    </tr>    <tr>      <td> 3 </td>      <td> mcontrol/mcontrol6 after (on previous instruction) </td>    </tr>    <tr>      <td>  </td>      <td> 3 </td>      <td> Instruction address breakpoint </td>      <td> mcontrol/mcontrol6 execute address before </td>    </tr>    <tr>      <td>  </td>      <td> 12, 20, 1 </td>      <td> During instruction address translation: First encountered page fault, guest-page fault, or access fault </td>      <td>  </td>    </tr>    <tr>      <td>  </td>      <td> 1 </td>      <td> With physical address for instruction: Instruction access fault </td>      <td>  </td>    </tr>    <tr>      <td>  </td>      <td> 3 </td>      <td>  </td>      <td> mcontrol/mcontrol6 execute data before </td>    </tr>    <tr>      <td rowspan='6'>  </td>      <td> 2 </td>      <td > Illegal instruction </td>      <td  rowspan='5'> </td>    </tr>    <tr>      <td> 22 </td>      <td > Virtual instruction </td>    </tr>    <tr>      <td> 0 </td>      <td > Instruction address misaligned </td>    </tr>    <tr>      <td>8, 9, 10, 11 </td>      <td > Environment call </td>    </tr>    <tr>      <td>3 </td>      <td > Environment break </td>    </tr>    <tr>      <td>3 </td>      <td > Load/Store/AMO address breakpoint </td>      <td > mcontrol/mcontrol6 load/store address before, store data before</td>    </tr>    <tr>      <td >  </td>      <td> 4, 6 </td>      <td > Optionally: Load/Store/AMO address misaligned </td>      <td > </td>    </tr>    <tr>      <td >  </td>      <td> 13, 15, 21, 23, 5, 7 </td>      <td > During address translation for an explicit memory access: First encountered page fault, guest-page fault, or access fault </td>      <td > </td>    </tr>    <tr>      <td >  </td>      <td> 5, 7 </td>      <td > With physical address for an explicit memory access: Load/store/AMO access fault </td>      <td > </td>    </tr>    <tr>      <td >  </td>      <td> 4, 6 </td>      <td > If not higher priority: Load/store/AMO address misaligned </td>      <td > </td>    </tr>    <tr>      <td align='center'> Lowest </td>      <td> 3 </td>      <td >  </td>      <td> mcontrol/mcontrol6 load data before </td>    </tr></table><h3 id="vdash-触发器类型"><a href="#vdash-触发器类型" class="headerlink" title="$\vdash$ 触发器类型"></a>$\vdash$ 触发器类型</h3><hr><p><strong>触发器编号</strong>是平台上所有触发器的唯一身份识别。通过 Sdtrig 扩展定义的 tselect CSR 寄存器进行配置选择。</p><p>而<strong>触发器类型</strong>则是根据触发器的匹配原理的分类，如 mcontrol 触发器类型是利用地址&#x2F;数据匹配来进行触发，而 icount 则是统计指令执行数量达到设定数值触发。一个触发器可能支持多种类型，这由 tinfo 寄存器指定。</p><p>规范定义了 <strong>tdata1</strong> CSR 寄存器，用于设置触发器的匹配方式。tselect 选择需要配置的触发器，调试器根据 tinfo 读回的信息确定是否有需要的触发类型。tdata1 最高4位 type 指定触发器类型，每种触发类型会定义剩下的位。type 定义如下，</p><table><thead><tr><th align="center">type 字段编码</th><th>描述</th></tr></thead><tbody><tr><td align="center">0</td><td>无，tselect 没有指定触发器</td></tr><tr><td align="center">1</td><td>lagacy, 触发器是 SiFive 地址匹配触发器。这不应被实现。</td></tr><tr><td align="center">2</td><td>mcontrol, 一个地址&#x2F;数据匹配触发器。已弃用，新实现应使用 mcontrol6 代替。</td></tr><tr><td align="center">3</td><td>icount, 一个执行指令数量计数触发器，当执行的指令数量和配置一致是触发。</td></tr><tr><td align="center">4</td><td>itrigger, 一个中断触发器，当设置的中断号发生中断陷阱时触发，中断号设置在 tdata2 中。</td></tr><tr><td align="center">5</td><td>etrigger, 一个异常触发器，当设置异常发生时触发, 异常编码设置在 tdata2 中。</td></tr><tr><td align="center">6</td><td>mcontrol6, 一个地址&#x2F;数据匹配触发器。取代 mcontrol.</td></tr><tr><td align="center">7</td><td>tmexttrigger, 该触发器本身在 Hart 内部，触发器输入信号（触发源）来自于 Trigger Module 之外。使用16个比特来支持最多16个触发源。</td></tr></tbody></table><p>上述每一种触发类型都会重新定义 tdata1 的字段（除了 type）, 具体可参考 Spec.</p><h4 id="vDash-mcontrol6-触发器"><a href="#vDash-mcontrol6-触发器" class="headerlink" title="$\vDash$ mcontrol6 触发器"></a>$\vDash$ mcontrol6 触发器</h4><p>触发器可以配置地址&#x2F;数据来作为匹配对象，如设置断点地址，当调试时PC值等于断点地址时触发，从而进入调试模式。该触发器提供了<strong>等于</strong>，<strong>napot</strong>，<strong>大于等于</strong>，<strong>小于</strong>，<strong>mask low</strong>，<strong>mask high</strong>，<strong>不等</strong>，<strong>not mask low</strong>，<strong>not mask high</strong>等匹配方式。除了匹配方式外，该触发器还提供了多触发器串联的链式触发机制。一个触发链只能在链中的每个触发器都由相同的指令匹配时才触发。</p><p>如附录 B.2.9 Triggers 部分列举的示例，当在地址 0x80001234 处的指令被执行时进入调试模式。其配置如下，</p><table><tr><td>tdata1</td><td>0x6980105C</td><td> type=6, dmode=1, action=1, select=0, match=0, m=1, s=1, u=1, vs=1, vu=1, execute=1</td></tr><tr><td>tdata2</td><td>0x80001234</td> <td> address</td></tr></table><ul><li>type&#x3D;6：选择 mcontrol6 类型触发器</li><li>dmode&#x3D;1: 只能在调试模式下修改 tselect 选定的触发器的 tdata* 寄存器</li><li>action&#x3D;1: 触发时进入调试模式</li><li>select&#x3D;0: tdata2 中值为 address 匹配对象</li><li>match&#x3D;0: 匹配方式为<strong>相等</strong>匹配</li><li>m&#x2F;s&#x2F;u&#x2F;vs&#x2F;vu&#x3D;1: 允许触发器在 m&#x2F;s&#x2F;u&#x2F;vs&#x2F;vu 模式下触发</li><li>execute&#x3D;1: 触发器在 Hart 执行指令的地址 <strong>等于</strong> tdata2 中的<strong>地址</strong>时，触发</li></ul><h4 id="vDash-icount-触发器"><a href="#vDash-icount-触发器" class="headerlink" title="$\vDash$ icount 触发器"></a>$\vDash$ icount 触发器</h4><p>在<u>本地调试</u>中，通过 icount 触发器可实现单步调试。如下指令段是 icount 触发器异常处理程序中常用的代码段，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">li t0, count=<span class="number">4</span>, action=<span class="number">0</span>, m=<span class="number">1</span></span><br><span class="line">csrw tdata1, t0 <span class="comment">/* Write the trigger. */</span></span><br><span class="line">lw t0, <span class="number">8</span>(sp) <span class="comment">/* Restore t0, count decrements to 3 */</span></span><br><span class="line">lw sp, <span class="number">0</span>(sp) <span class="comment">/* Restore sp, count decrements to 2 */</span></span><br><span class="line">mret <span class="comment">/* Return to program being debugged. count decrements to 1 */</span></span><br></pre></td></tr></table></figure><p>在上述代码段中，icount.count &#x3D; 4, 表示执行4条指令后触发断点异常（ action&#x3D;0 ）进入异常处理程序，icount.m &#x3D; 1 表示在 M 模式下允许触发。在写入 tdata1 之后，通过 tcontrol 使能触发器。<code>lw t0, 8(sp)</code> 是第一条被计数的指令，<code>mret</code> 是第三条，当回到正常模式再执行一条指令后触发，总共4条指令。</p><h3 id="vdash-触发器模块寄存器"><a href="#vdash-触发器模块寄存器" class="headerlink" title="$\vdash$ 触发器模块寄存器"></a>$\vdash$ 触发器模块寄存器</h3><hr><p>下表中 0x7a1 地址定义为 tdata1, 由于最高4位为触发器类型，针对每种类型寄存器具有不同的定义，因此有 mcontrol&#x2F;mcontrol6&#x2F;icount&#x2F;itrigger&#x2F;etrigger&#x2F;tmexttrigger 等，但实际上就是一个寄存器。</p><table><thead><tr><th>Address</th><th>Name</th><th>Spec. Section</th></tr></thead><tbody><tr><td>0x5a8</td><td>Supervisor Context (scontext)</td><td>Section 5.7.8</td></tr><tr><td>0x6a8</td><td>Hypervisor Context (hcontext)</td><td>Section 5.7.7</td></tr><tr><td>0x7a0</td><td>Trigger Select (tselect)</td><td>Section 5.7.1</td></tr><tr><td>$\color{red}{0x7a1}$</td><td>Trigger Data 1 (tdata1)</td><td>Section 5.7.2</td></tr><tr><td>$\color{red}{0x7a1}$</td><td>Match Control (mcontrol)</td><td>Section 5.7.11</td></tr><tr><td>$\color{red}{0x7a1}$</td><td>Match Control Type 6 (mcontrol6)</td><td>Section 5.7.12</td></tr><tr><td>$\color{red}{0x7a1}$</td><td>Instruction Count (icount)</td><td>Section 5.7.13</td></tr><tr><td>$\color{red}{0x7a1}$</td><td>Interrupt Trigger (itrigger)</td><td>Section 5.7.14</td></tr><tr><td>$\color{red}{0x7a1}$</td><td>Exception Trigger (etrigger)</td><td>Section 5.7.15</td></tr><tr><td>$\color{red}{0x7a1}$</td><td>External Trigger (tmexttrigger)</td><td>Section 5.7.16</td></tr><tr><td>0x7a2</td><td>Trigger Data 2 (tdata2)</td><td>Section 5.7.3</td></tr><tr><td>$\color{green}{0x7a3}$</td><td>Trigger Data 3 (tdata3)</td><td>Section 5.7.4</td></tr><tr><td>$\color{green}{0x7a3}$</td><td>Trigger Extra (RV32) (textra32)</td><td>Section 5.7.17</td></tr><tr><td>$\color{green}{0x7a3}$</td><td>Trigger Extra (RV64) (textra64)</td><td>Section 5.7.18</td></tr><tr><td>0x7a4</td><td>Trigger Info (tinfo)</td><td>Section 5.7.5</td></tr><tr><td>0x7a5</td><td>Trigger Control (tcontrol)</td><td>Section 5.7.6</td></tr><tr><td>0x7a8</td><td>Machine Context (mcontext)</td><td>Section 5.7.9</td></tr><tr><td>0x7aa</td><td>Machine Supervisor Context (mscontext)</td><td>Section 5.7.10</td></tr></tbody></table><h2 id="color-teal-调试传输模块-DTM"><a href="#color-teal-调试传输模块-DTM" class="headerlink" title="$\color{teal}{调试传输模块 DTM}$"></a>$\color{teal}{调试传输模块 DTM}$</h2><hr><p>本章对应 Spec. 第六章 non-ISA Debug Transport Module (DTM)。</p><h3 id="vdash-JTAG-TAP-DTM-寄存器"><a href="#vdash-JTAG-TAP-DTM-寄存器" class="headerlink" title="$\vdash$ JTAG TAP DTM 寄存器"></a>$\vdash$ JTAG TAP DTM 寄存器</h3><hr><table><thead><tr><th>Address</th><th>Name</th><th>Description</th><th>Spec. Section</th></tr></thead><tbody><tr><td>0x01</td><td>idcode</td><td>To identify a specific silicon version</td><td>Section  6.1.3</td></tr><tr><td>0x10</td><td>DTM Control and Status (dtmcs)</td><td>For Debugging</td><td>Section  6.1.4</td></tr><tr><td>0x11</td><td>Debug Module Interface Access ( dmi)</td><td>For Debugging</td><td>Section  6.1.5</td></tr><tr><td>0x1f</td><td>bypass</td><td>JTAG requires this encoding</td><td>Section  6.1.6</td></tr></tbody></table><h3 id="vdash-JTAG-DTM"><a href="#vdash-JTAG-DTM" class="headerlink" title="$\vdash$ JTAG DTM"></a>$\vdash$ JTAG DTM</h3><hr><p>JTAG 指的是 IEEE Std 1149.1-2013。它是一个标准,定义了可以在集成电路中包含的测试逻辑,用于测试集  成电路之间的连接,测试集成电路本身,以及在组件正常操作期间观察或修改电路活动。规范使用 JTAG 来观察或修改电路活动。JTAG 标准定义了一个测试访问端口(TAP)，可以用来读取和写入几个自定义寄存器，这些寄存器可以用来与组件中的调试硬件通信。DTM 在普通的 JTAG 测试访问端口（TAP）上实现，基于 IR Chain 和 DR Chain 来实现对 DTM 寄存器的访问，从而与调试模块进行通信。</p><p>在<a href="#%E8%B0%83%E8%AF%95%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF">调试数据链路</a>一节中展示了 JTAG DTM 的模块框图，主要包含 JTAG TAP 和 DTM 寄存器，JTAG TAP 包含了5个引脚：<strong>TDI</strong>, <strong>TDO</strong>, <strong>TMS</strong>, <strong>TCK</strong>, <strong>TRSTn</strong>. 其中 TMS 用来控制 IR-DR Chain 的状态转移，TDI 作为输入请求，TDO 作为输出响应。</p><p>如下图，在 TMS 的输入控制下，IR Chain 在 Capture-IR 状态会对 TDI 输入的指令编码（地址值）进行采集，在 Shift-IR 状态将指令（地址）移入指令寄存器，在 Updata-IR 状态完成 BYPASS&#x2F;ICODE&#x2F;DMI 等数据链路的切换，然后 <code>TMS = 1</code> 驱动数据链路。DR Chain 对选定的 DTM 寄存器，如 dmi 寄存器，进行读写访问。<br><img src="/DR-IR-Chain.png"></p><p>规范要求最少5位IR，即 上述 DTM 寄存器地址最少5位，如果支持更宽位数需要进行地址扩展。JTAG DTM 复位时 IR 必须为 0x01 IDCODE 指令。BYPASS 和 IDCODE 是 JTAG 定义的常规指令，DTMCS&#x2F;DMI 是 RISC-V 自定义专用指令。上电时 IR 默认选择 IDCODE 指令，DR Chain 处于 IDCODE 链路，TMS 驱动 IR-DR Chain 状态变化。当 DTMCS 指令被 IR 选择时，自定义 dtmcs 寄存器将会被读写，从而对 DTM 模块进行控制和状态观察。当 DMI 指令被选中时，对 dmi 寄存器进行读写，从而发起 DMI 事务，访问 DM 寄存器，进一步完成对 Hart的控制&#x2F;访问。</p><h3 id="vdash-dmi-寄存器"><a href="#vdash-dmi-寄存器" class="headerlink" title="$\vdash$ dmi 寄存器"></a>$\vdash$ dmi 寄存器</h3><hr><table style="border-collapse: collapse;"><tr style="font-size: 10px; vertical-align: bottom;"><td style="border: none !important; text-align: left; padding 0 0;">abits+33</td><td style="border: none !important; text-align: right; padding 0 0;">34</td><td style="border: none !important; text-align: left; padding 0 0;">33</td><td style="border: none !important; text-align: right; padding 0 0;">2</td><td style="border: none !important; text-align: left; padding 0 0;">1</td><td style="border: none !important; text-align: right; padding 0 0;">0</td></tr><tr align='center'><td colspan='2'><b>address</b></td><td colspan='2'><b>data</b></td><td colspan='2'><b>op</b></td></tr><tr align='center' style="vertical-align: top;"><td style="border: none !important;" colspan='2'>abits</td><td style="border: none !important;" colspan='2'>32</td><td style="border: none !important;" colspan='2'>2</td></tr></table><p>当 IR Chain 选择 DMI 指令时，DR Chain 会切换到 DMI 数据链，此时 TDI 输入 <code>abits+34</code> 位数据，如上表，DTM 采集数据后转换成 dmi 寄存器数据。在 Updata-DR 中，DTM 将执行 <strong>op</strong> 中指定的读写操作。在 Capture-DR 中，DTM 将使用 Updata-DR <strong>op</strong> 操作的结果更新 <strong>dmi.data</strong>,  <strong>op</strong> 会记录成功或错误信息，最后通过 TDO 输出到调试器。</p><h3 id="vdash-JTAG-连接器"><a href="#vdash-JTAG-连接器" class="headerlink" title="$\vdash$ JTAG 连接器"></a>$\vdash$ JTAG 连接器</h3><hr><p>规范指出，JTAG 连接器采用 MIPI-10 实现。</p><h2 id="color-teal-总结"><a href="#color-teal-总结" class="headerlink" title="$\color{teal}{总结}$"></a>$\color{teal}{总结}$</h2><hr><p>规范基于 <strong>Native Debug</strong>, 和 <strong>Extenal Debug</strong> 两个方面对调试进行了定义。在外部调试方向，定义了 DM, DTM, Sdext, 而本地调试方向，定义了 Sdtrig. Sdtrig 扩展除了支持本地调试，也支持外部调试器的断点调试。</p><p>规范外部调试中，Sdext 是为了支持调试而对 RISC-V 内核所做的最小限度的修改，包括4个 CSRs 寄存器和定义调试模式。而不涉及 RISC-V ISA 的部分都归入 DM 定义中。</p><p>规范中定义了 Hart 行为控制部分相关的功能和寄存器，主要是复位、暂停、恢复等功能特性。而另一部分是抽象命令，主要对平台上（包含 Hart 内）资源的访问。对 Hart 行为的控制是抽象命令的基础。</p><p>规范定义了 Program Buffer，这让 Hart 实现任意的行为变得非常容易。</p><p>规范在附录部分给出了硬件实现方案和应用实现示例，对于理解规范非常有用。</p><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><hr><p><a href="https://github.com/riscv-software-src/riscv-tests/tree/master/debug">riscv-tests&#x2F;debug</a>提供了对调试作为外部调试器的端到端测试，与 gdb 和 OpenOCD 通信。如果模拟器或硬件通过了所有这些测试，那么可以相当有信心地认为实际的调试接口正常工作。</p><p>从本地调试方向，可以对触发器进行测试。可以对每种触发器的触发规则进行测试；利用触发器实现断点、观察点、单步等功能。</p>]]></content>
      
      
      <categories>
          
          <category> RISC-V </category>
          
          <category> Debug </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RISC-V </tag>
            
            <tag> Debug </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RISC-V fence rw, rw 原理</title>
      <link href="/2025/06/18/RISC-V-fence-rw-rw-%E5%8E%9F%E7%90%86/"/>
      <url>/2025/06/18/RISC-V-fence-rw-rw-%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="指令介绍"><a href="#指令介绍" class="headerlink" title="指令介绍"></a>指令介绍</h1><p>RISC-V 中的 <code>FENCE</code>（Memory Barrier）指令的设计意图是为硬件和软件提供一种显式控制内存访问顺序的机制 ，以应对现代处理器架构中由于乱序执行、缓存优化、多核并行 等特性带来的内存访问重排序问题。其核心目的是在保证性能的同时，确保程序的内存操作顺序符合预期的语义 。</p><p>从硬件的角度来看，FENCE 的实现涉及多个关键模块：指令流水线控制、缓存系统、写缓冲区、Load&#x2F;Store 队列、重排序缓冲区（ROB） 等。<code>FENCE</code> 指令会强制插入一个“边界”，使得：</p><ul><li>所有在 FENCE 之前的 Load&#x2F;Store 指令必须在该指令之前完成；</li><li>所有在 FENCE 之后的 Load&#x2F;Store 指令必须在该指令之后开始执行；</li><li>这种边界通常由**指令调度器（Instruction Scheduler）或 重排序缓冲区（ROB）**管理。</li></ul><p>在乱序执行架构中，所有指令最终都要通过 Reorder Buffer（ROB） 提交（Commit）。FENCE 指令会在 ROB 中占据一个位置，并阻止后续指令提交，直到前面所有的 Load&#x2F;Store 操作都已完成。</p><p>在多核系统中，FENCE 只能保证<strong>本地核心</strong>内的<strong>顺序性</strong> ，<u>不能保证跨核可见性</u>。</p><p>如果需要跨核同步，还需要配合使用：</p><ul><li>FENCE.I（刷新指令缓存）</li><li>SFENCE.VMA（刷新 TLB）</li><li>原子指令（如 AMOSWAP, LR&#x2F;SC）</li></ul><h1 id="FENCE-实现的目标"><a href="#FENCE-实现的目标" class="headerlink" title="FENCE 实现的目标"></a>FENCE 实现的目标</h1><ul><li>防止 Load&#x2F;Store 指令跨过该屏障重排序 ；</li><li>确保内存访问顺序符合程序语义 ；</li><li>在多核系统中维护缓存一致性 ；</li><li>避免因乱序执行导致的数据竞争或同步错误，在共享内存通信中保证数据可见性 。</li></ul><h1 id="FENCE-处理流程（Rocket-Chip为例）"><a href="#FENCE-处理流程（Rocket-Chip为例）" class="headerlink" title="FENCE 处理流程（Rocket Chip为例）"></a>FENCE 处理流程（Rocket Chip为例）</h1><ol><li>FENCE指令解码<br>* 在指令解码阶段，识别fence指令；<br>* 根据<code>pred</code>和<code>succ</code>字段判断是否为<code>RW,RW</code>类型;<br>* 插入 <code>ROB</code>。</li><li>LSQ同步：<strong>阻止某些类型的指令跨过该屏障进行调度</strong><br>* 当<code>fence rw, rw</code>被解码后，处理器会：<ul><li>暂停后续的 Load&#x2F;Store 操作；</li><li>等待当前 Load Queue 中的所有 Load 操作完成；</li><li>等待当前 Store Queue 中的所有 Store 操作被提交到缓存；<ul><li>此后，后续的 Load&#x2F;Store 操作才被允许执行(要等如下的缓存一致性维护后)。</li></ul></li></ul></li><li>保证缓存一致性<br>* 如果系统中存在多个核心，FENCE 可能会触发：<ul><li>强制刷新未完成的 Store Buffer；</li><li>等待所有先前的 Load 操作从内存中返回数据；</li><li>强制所有缓存行状态同步，确保其他核心看到一致的内存状态(通过配合缓存一致性协议)。</li></ul></li></ol><h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1><ul><li>编译器 ：在生成代码时插入 <code>FENCE</code> 指令，防止编译器优化导致的内存访问重排；</li><li>操作系统 ：在实现互斥锁、自旋锁、内存映射等机制时使用 <code>FENCE</code>；</li><li>硬件与软件协同 ：确保内存访问顺序在软硬件层面都得到保证。</li></ul>]]></content>
      
      
      <categories>
          
          <category> RVWMO </category>
          
          <category> INSN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RVWMO </tag>
            
            <tag> FENCE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在docker容器中源码安装riscv-gnu-toolchain</title>
      <link href="/2025/06/03/%E5%9C%A8docker%E5%AE%B9%E5%99%A8%E4%B8%AD%E6%BA%90%E7%A0%81%E5%AE%89%E8%A3%85riscv-gnu-toolchain/"/>
      <url>/2025/06/03/%E5%9C%A8docker%E5%AE%B9%E5%99%A8%E4%B8%AD%E6%BA%90%E7%A0%81%E5%AE%89%E8%A3%85riscv-gnu-toolchain/</url>
      
        <content type="html"><![CDATA[<h1 id="流程简述"><a href="#流程简述" class="headerlink" title="流程简述"></a>流程简述</h1><ol><li>安装docker；</li><li>拉取riscv-gnu-toolchain源码；</li><li>制作镜像；</li><li>发布镜像；</li></ol><h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><h2 id="安装docker"><a href="#安装docker" class="headerlink" title="安装docker"></a>安装docker</h2><ol><li>安装wsl2, ubuntu；</li><li>安装docker: <code>curl https://get.docker.com | sh</code></li></ol><h2 id="生成基础镜像"><a href="#生成基础镜像" class="headerlink" title="生成基础镜像"></a>生成基础镜像</h2><p>dockerfile的每个命令会生成一个层，会暂用存储空间，应尽量少放命令。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Docker image to cross-compile riscv firmware binaries</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">22.04</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">LABEL</span><span class="language-bash"> maintainer=<span class="string">&quot;zhou fei &lt;zhouf@hygon.cn&gt;&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /workspace</span></span><br><span class="line"><span class="comment"># COPY . .</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt update &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    apt install -y \</span></span><br><span class="line"><span class="language-bash">    build-essential \</span></span><br><span class="line"><span class="language-bash">    autoconf \</span></span><br><span class="line"><span class="language-bash">    automake \</span></span><br><span class="line"><span class="language-bash">    autotools-dev \</span></span><br><span class="line"><span class="language-bash">    curl \</span></span><br><span class="line"><span class="language-bash">    python3 \</span></span><br><span class="line"><span class="language-bash">    python3-pip \</span></span><br><span class="line"><span class="language-bash">    libmpc-dev \</span></span><br><span class="line"><span class="language-bash">    libmpfr-dev \</span></span><br><span class="line"><span class="language-bash">    libgmp-dev \</span></span><br><span class="line"><span class="language-bash">    gawk \</span></span><br><span class="line"><span class="language-bash">    bison \</span></span><br><span class="line"><span class="language-bash">    flex \</span></span><br><span class="line"><span class="language-bash">    texinfo \</span></span><br><span class="line"><span class="language-bash">    gperf \</span></span><br><span class="line"><span class="language-bash">    libtool \</span></span><br><span class="line"><span class="language-bash">    patchutils \</span></span><br><span class="line"><span class="language-bash">    bc \</span></span><br><span class="line"><span class="language-bash">    zlib1g-dev \</span></span><br><span class="line"><span class="language-bash">    libexpat-dev \</span></span><br><span class="line"><span class="language-bash">    ninja-build \</span></span><br><span class="line"><span class="language-bash">    git \</span></span><br><span class="line"><span class="language-bash">    cmake \</span></span><br><span class="line"><span class="language-bash">    libglib2.0-dev \</span></span><br><span class="line"><span class="language-bash">    libslirp-dev &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    pip install sphinx sphinx-rtd-theme tomli &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    apt clean &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    <span class="built_in">rm</span> -rf /var/lib/apt/lists/* /tmp/* /var/tmp/*</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;bash&quot;</span>]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>不推荐用dockerfile COPY命令，该命令会新建一个层，即使删除copy的文件&#x2F;目录也会导致这一层空间无法释放，正确的做法是绑定本地目录，合并到run层目录。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t riscv64_build .</span><br></pre></td></tr></table></figure><p>通过上述命令生成一个名叫riscv64_build的镜像。</p><h2 id="准备riscv-gnu-toolchain源码"><a href="#准备riscv-gnu-toolchain源码" class="headerlink" title="准备riscv-gnu-toolchain源码"></a>准备riscv-gnu-toolchain源码</h2><ol><li>拉取源码和子库<code>git clone --recursive xxxx </code>或更新源码<code>git pull --rebase</code>，若之前有修改，可先<code>stash</code>修改；</li><li>更新子库<code>git submodule update --init</code></li></ol><h2 id="生成最终镜像"><a href="#生成最终镜像" class="headerlink" title="生成最终镜像"></a>生成最终镜像</h2><p>接下来通过如下命令和Dockerfile.dev生成最终的镜像：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Docker image to cross-compile riscv firmware binaries</span></span><br><span class="line"><span class="comment"># cp Dockerfile.dev .. &amp;&amp; cd .. &amp;&amp; docker build -f Dockerfile.dev -t riscv64_build_env:latest .</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> riscv64_build:latest</span><br><span class="line"></span><br><span class="line"><span class="keyword">LABEL</span><span class="language-bash"> maintainer=<span class="string">&quot;zhou fei &lt;zhouf@hygon.cn&gt;&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /workspace</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> --mount=<span class="built_in">type</span>=<span class="built_in">bind</span>,<span class="built_in">source</span>=./riscv-gnu-toolchain,target=/workspace,rw \</span></span><br><span class="line"><span class="language-bash">    apt-get update &amp;&amp; apt-get upgrade -y &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    <span class="built_in">rm</span> -rf build &amp;&amp; <span class="built_in">mkdir</span> build &amp;&amp; <span class="built_in">cd</span> build &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    ../configure --prefix=/opt/riscv --with-languages=c,c++ --enable-qemu-system &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    make -s -j2 linux &amp;&amp; <span class="built_in">cd</span> .. &amp;&amp; <span class="built_in">rm</span> -rf build &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    <span class="built_in">cd</span> qemu &amp;&amp; <span class="built_in">rm</span> -rf build &amp;&amp; <span class="built_in">mkdir</span> build &amp;&amp; <span class="built_in">cd</span> build &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    ../configure --enable-plugins --target-list=riscv64-softmmu,riscv64-linux-user  --extra-cflags=<span class="string">&quot;-I../include -I..&quot;</span> &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    make -j2 &amp;&amp; make install &amp;&amp; <span class="built_in">cd</span> .. &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    <span class="built_in">rm</span> -rf build /var/lib/apt/lists/* /tmp/* /var/tmp/*</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;bash&quot;</span>]</span></span><br></pre></td></tr></table></figure><p>将上述Dockerfile.dev拷贝到<code>riscv-gnu-toolchain</code>的父级目录下，并执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -f Dockerfile.dev -t riscv64_build_env:latest .</span><br></pre></td></tr></table></figure><p>通常情况会生成riscv64_build_env:latest镜像。</p><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><ol><li>利用容器中的gcc编译：<code>set -eo pipefail; docker run --privileged --rm -v /home/xxx/wks/riscvtestsuite:/workspace -w /workspace -e PATH=&quot;$PATH:/opt/riscv/bin&quot; -e LD_LIBRARY_PATH=&quot;/usr/local/lib:$LD_LIBRARY_PATH&quot; riscv64_build_env:latest /bin/bash -c &quot; cd xxx/xxx/xxx;git config --global --add safe.directory /workspace; make -j 16 GLOBAL_LOG_LEVEL=0 PLATFORM=0 img-body1 QUIET= &quot;</code></li><li>运行测试：<code>set -eo pipefail; docker run --privileged --rm -v /home/xxx/wks/riscvtestsuite:/workspace -w /workspace -e PATH=&quot;$PATH:/opt/riscv/bin&quot; -e LD_LIBRARY_PATH=&quot;/usr/local/lib:$LD_LIBRARY_PATH&quot; riscv64_build_env:latest /bin/bash -c &quot; cd xxx/xxx/xxx;git config --global --add safe.directory /workspace; qemu-system-riscv64 -smp 8 -cpu max -M virt,aia=aplic-imsic -m 8G -kernel register.img -bios none -serial stdio -display none -semihosting  &quot;</code><br>参考 opensbi makefile 写法。</li></ol>]]></content>
      
      
      <categories>
          
          <category> riscv-gnu-toolchain </category>
          
      </categories>
      
      
        <tags>
            
            <tag> riscv-gnu-toolchain </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>将本地网页翻译成双语PDF</title>
      <link href="/2025/05/15/%E5%B0%86%E6%9C%AC%E5%9C%B0%E7%BD%91%E9%A1%B5%E7%BF%BB%E8%AF%91%E6%88%90%E5%8F%8C%E8%AF%ADPDF/"/>
      <url>/2025/05/15/%E5%B0%86%E6%9C%AC%E5%9C%B0%E7%BD%91%E9%A1%B5%E7%BF%BB%E8%AF%91%E6%88%90%E5%8F%8C%E8%AF%ADPDF/</url>
      
        <content type="html"><![CDATA[<h1 id="更新-20250517"><a href="#更新-20250517" class="headerlink" title="更新 20250517"></a>更新 20250517</h1><hr><p>沉浸式插件已经支持直接对本地HTML进行翻译并导出双语HTML文件（使用<strong>翻译HTML&#x2F;txt文件</strong>），所以以下流程就更加简单了。导出双语版HTML后可以直接使用wkhtmltopdf工具转换成PDF文档。</p><p>虽然不用再托管网页了，但将本地网页托管的方法比较有用。当不需要记录笔记时使用网页的文档会更方便，可以随时翻译，并且可结合 kimi AI 大模型进行问答。</p><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><hr><p>RISC-V相关Spec都是英文的，在学习和查阅时存在语言gap，导致效率和准确性不足。因此探索将因为文档生成双语PDF读物，期望提升效率和准确性，避免重要内容被遗漏。</p><p>本文讲述的方法需要满足以下条件：</p><ul><li>英文读物需要有<strong>网页版本</strong>，可用浏览器打开。（如果英文读物是PDF，也可输出双语版本，但是排版上是一页英文对应一页中文，阅读方面需要用双页滚动查看，不太方便，如果想要更好的排版，需要一定的金钱成本。）</li><li>google浏览器，其他浏览其应该也可以，但没试过；</li><li>沉浸式翻译插件；</li><li>安装live-server命令行工具；</li><li>安装wkhtmltopdf命令行工具;</li></ul><p>主要步骤：</p><ol><li>托管网页。将网页托管到服务器，如果直接使用file的形式打开，通常不能使用沉浸式翻译插件来翻译网页（可以翻译本地PDF）；</li><li>通过翻译插件翻译网页；</li><li>预览双语页面，导出双语页面到html文件；</li><li>wkhtmltopdf命令行工具将html文件转换成pdf文件；</li></ol><p>通过上述方法，可以生成带有侧边栏大纲的PDF文件。</p><h1 id="工具安装"><a href="#工具安装" class="headerlink" title="工具安装"></a>工具安装</h1><h2 id="沉浸式翻译插件安装"><a href="#沉浸式翻译插件安装" class="headerlink" title="沉浸式翻译插件安装"></a>沉浸式翻译插件安装</h2><hr><p>在Bing上搜索”沉浸式翻译”，一般第一个就是官网，进入官网可以看到如下导航，选择自己使用的浏览器类型，安装使用说明安装即可。</p><p><img src="/image.png" alt="alt text"></p><p>安装完成后可以在浏览器右上位置看到插件图标（酒红色那个）。</p><p><img src="/image-1.png" alt="alt text"></p><p>点击插件按钮可以看到如下界面，可根据界面按需使用。值得一提的是，<strong>翻译服务</strong>和<strong>AI专家</strong>可以配置，翻译服务可以是常规的机器翻译，也可以是AI大模型翻译，其中通过SiliconCloud可配置不同的AI翻译模型；AI专家是翻译的类型和对特定网站的特定优化翻译。具体的配置可以通过图片左下角的<strong>设置</strong>进入。</p><p>在导出双语页面时，需要使用图上右上角<strong>生成网页快照</strong>功能。</p><p><img src="/image-3.png" alt="alt text"></p><p>其他重要的功能在上述图片的右下角<strong>更多</strong>菜单中。其中<strong>翻译本地PDF文件</strong>可以将PDF翻译成双语PDF，只是排版在不付费的情况下是一页英文对应一页中文的形式。<strong>立即翻译到页面底部</strong>是一个网页翻译的重要功能，在网页翻译时通常只是翻译窗口可见的部分，不可见部分不会翻译，而翻译是比较花时间的，在翻译服务中可以配置并行翻译的参数。<strong>临时开启译文编辑</strong>可以在网页上对译文进行编辑，不过当网页比较长时，对所有译文进行修正是一个耗时的工作，文档不是正式的文档时，通常还是不需要修改的。</p><p><img src="/image-2.png" alt="alt text"></p><h2 id="live-server安装"><a href="#live-server安装" class="headerlink" title="live-server安装"></a>live-server安装</h2><hr><p>在POWERSHELL中执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">set-ExecutionPolicy RemoteSigned</span><br><span class="line">winget install Schniz.fnm</span><br><span class="line">fnm install 22</span><br><span class="line">npm -v  # Should print &quot;10.9.2&quot;</span><br><span class="line">npm install -g live-server</span><br></pre></td></tr></table></figure><h2 id="wkhtmltopdf安装"><a href="#wkhtmltopdf安装" class="headerlink" title="wkhtmltopdf安装"></a>wkhtmltopdf安装</h2><hr><p>直接在Bing上搜索工具名，通过网页下载离线安装包安装即可。注意，如果是命令行安装可能不可用，安装完后验证版本号<code>wkhtmltox.exe --version</code>,如果输出的**wkhtmltopdf 0.12.6.1 (with patched qt)**则可以使用，注意一定要带qt。</p><h1 id="生成双语PDF流程"><a href="#生成双语PDF流程" class="headerlink" title="生成双语PDF流程"></a>生成双语PDF流程</h1><h2 id="网页托管"><a href="#网页托管" class="headerlink" title="网页托管"></a>网页托管</h2><hr><p>通过命令行进入网页目录，在命令行中执行<code>live-server</code>，稍微等待即可更加命令行提示进入网页。通常是<code>http://127.0.0.1:8080/</code>网站。在页面上选择具体要翻译的页面，点击打开即可。</p><h2 id="翻译页面"><a href="#翻译页面" class="headerlink" title="翻译页面"></a>翻译页面</h2><hr><p>通过插件小图标可以对页面进行翻译，可以尝试不同的<strong>AI专家</strong>输出不同的中文翻译。选择比较满意的即可。</p><p>通过<strong>立即翻译到页面底部</strong>功能对整个网页进行翻译。这里可能需要等待较长时间，具体需要看网页长度，浏览器可能会一直卡住，需要耐心等待，等待，等待。</p><p>当网页不卡时，可以流畅地查看整个网页，此时双语版的网页展现在浏览器上。</p><h2 id="导出到HTML"><a href="#导出到HTML" class="headerlink" title="导出到HTML"></a>导出到HTML</h2><hr><p>在页面上使用<code>Ctrl+S</code>快捷键，注意保存类型一定要选<strong>网页，全部(<em>.htm;</em>.html)</strong>, 因为只有这个选项才能真正导出双语版的静态页面。</p><p><img src="/image-6.png" alt="alt text"></p><p>导出成功后，会得到一个目录，里面有html后缀的文件，打开这些文件，找到双语版本的html那个。</p><h2 id="生成PDF"><a href="#生成PDF" class="headerlink" title="生成PDF"></a>生成PDF</h2><hr><p>在命令行使用<code>wkhtmltopdf toc name.html name.pdf</code>生成PDF。生成的PDF会带有侧边栏目录和中文翻译。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><hr><p>上述方法是将英文网页生成带大纲的双语PDF，对离线本地网页或远程在线网页都适用。关键是如何得到双语网页。插件通常对本地网页（file:&#x2F;&#x2F;&#x2F;）没有翻译能力，所以需要先通过live-server托管网页。</p><p>另一个关键问题是如何得到带大纲的PDF。wkhtmltopdf的toc参数可以生成带目录大纲的PDF。这就要求输入的html是双语版的，要想得到双语版的html，就需要将动态的中文翻译转换成静态的。</p><p><strong>临时开启译文编辑</strong>是一个重要的功能。目前（2025）的翻译使用硅基流动的接口，免费模型支持到<strong>Qwen&#x2F;Qwen2.5-7B-Instruct</strong>，要想使用更优秀的模型需要购买。这个模型翻译的效果有些地方比较难以理解，可以通过临时编辑功能对中文进行重新整理，这在比较正式的版本比较有用。</p>]]></content>
      
      
      <categories>
          
          <category> 翻译 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 翻译 </tag>
            
            <tag> PDF </tag>
            
            <tag> html </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RISC-V time/cycle/instret/hpm</title>
      <link href="/2025/04/24/RISC-V-time-cycle-instret-hpm/"/>
      <url>/2025/04/24/RISC-V-time-cycle-instret-hpm/</url>
      
        <content type="html"><![CDATA[<h1 id="寄存器汇总"><a href="#寄存器汇总" class="headerlink" title="寄存器汇总"></a>寄存器汇总</h1><p><img src="/ucounters.png" alt="alt text"></p><p>U-mode 下只有计数的counter,没有管理counter的寄存器。</p><p><img src="/mcounters.png" alt="alt text"></p><p>M-mode 下除了计数的counter外，还有管理counter的寄存器。除上述寄存器，还有mtime&#x2F;mtimecmp寄存器，这2个是 <strong>mem mapped</strong> 寄存器，由SOC提供，关于这2个寄存器的详细介绍，可以参考<strong>RISC-V Privileged Specification</strong>的<strong>Machine Timer Registers</strong>章节。</p><p>想要在低权限模式使用counters, 需要mcounteren&#x2F;scounteren寄存器授权，也需要mcountinhibit&#x2F;scountinhibit寄存器使能计数器增长。</p><p>另外，Sstc提供了stimecmp寄存器服务于S&#x2F;HS&#x2F;VS模式来提供timer中断。</p><hr><h1 id="Zicntr扩展"><a href="#Zicntr扩展" class="headerlink" title="Zicntr扩展"></a>Zicntr扩展</h1><p>Zicntr扩展定义了cycle, time, instret 共3个只读CSRs，和对应的Read指令。U&#x2F;S&#x2F;M都具有访问权限。counter为64bits。这3个counter是mcycle, mtime, minstret的影子寄存器。</p><hr><h1 id="zihpm扩展"><a href="#zihpm扩展" class="headerlink" title="zihpm扩展"></a>zihpm扩展</h1><p>Zihpm扩展定义了29个counters，hpmcounter3-31。U&#x2F;S&#x2F;M都具有访问权限。counter为64bits。这29个counter是mhpmcounter3~31的影子寄存器。</p><hr><h1 id="Machine-Level-ISA"><a href="#Machine-Level-ISA" class="headerlink" title="Machine-Level ISA"></a>Machine-Level ISA</h1><h2 id="硬件性能监视器-Hardware-Performance-Monitor"><a href="#硬件性能监视器-Hardware-Performance-Monitor" class="headerlink" title="硬件性能监视器 Hardware Performance Monitor"></a>硬件性能监视器 Hardware Performance Monitor</h2><p>Machine-Level ISA 定义了一组64bits的性能监视器，包括<strong>mcycle</strong>, <strong>minstret</strong>, <strong>mhpmcounter3~31</strong>, <strong>mhpmevent3~31</strong>.</p><p>mcycle用于记录处理器<strong>启动</strong>以来经过的<strong>时钟周期数</strong>，同一个core中的harts共享一个mcycle计数器。</p><h2 id="mtime-mtimecmp"><a href="#mtime-mtimecmp" class="headerlink" title="mtime&#x2F;mtimecmp"></a>mtime&#x2F;mtimecmp</h2><p>Machine-Level ISA 定义了<strong>mtime</strong>和<strong>mtimecmp</strong>来作为系统时间。mtime&#x2F;mtimecmp都是memory mapped寄存器，如在sifive中，由clint提供。mtime由所有harts共享，mtimecmp由hart独有。自系统启动后mtime就开始按固定频率递增。</p><h2 id="mcounteren-scounteren"><a href="#mcounteren-scounteren" class="headerlink" title="mcounteren&#x2F;scounteren"></a>mcounteren&#x2F;scounteren</h2><p>Machine-Level ISA 定义了mcounteren寄存器，用于控制<strong>S&#x2F;U</strong>模式下cycle, time, instret, hpmcounter3<del>31的访问权限，这些寄存器是M模式下的计数器的影子寄存器。<br>Machine-Level ISA 定义了scounteren寄存器，用于控制<strong>U</strong>模式下cycle, time, instret, hpmcounter3</del>31的访问权限，这些寄存器是M模式下的计数器的影子寄存器。</p><h2 id="mcountinhibit"><a href="#mcountinhibit" class="headerlink" title="mcountinhibit"></a>mcountinhibit</h2><p>Machine-Level ISA 定义了mcountinhibit寄存器，用于控制S&#x2F;U模式下cycle, instret, hpmcounter3~31的计数器增长。注意，time由于在多核（core）下共享，所以不能被inhibit。cycle由于可能在同一个core中不同的harts共享，所以mcountinhibit.CY是该core内所有harts同时可观测的。</p><hr><h1 id="Smcntrpmf扩展"><a href="#Smcntrpmf扩展" class="headerlink" title="Smcntrpmf扩展"></a>Smcntrpmf扩展</h1><p>Smcntrpmf扩展定义了<strong>mcyclecfg</strong>和<strong>minstretcfg</strong>，分别用来禁用不同特权等级下计数器的增长。比如，在计数时出现中断或异常导致计数不准确。这2个寄存器可以屏蔽这种影响。</p><h2 id="cycle-instret计数器行为"><a href="#cycle-instret计数器行为" class="headerlink" title="cycle&#x2F;instret计数器行为"></a>cycle&#x2F;instret计数器行为</h2><p>模式转换（trap 或 trap returns）会消耗多个clock cycles. 特权模式的更改可能报告为发生在这些cycles中的任何一个cycle中.</p><p>有两种类型的指令可能会影响特权模式更改：导致同步异常到更高特权模式的指令，以及返回较低特权模式的 xRET 指令。前者不被视为 retire，因此不会导致 instret 递增。后者会 retire，并且仅在未禁止(通过minstretcfg)原始权限模式时才应递增 instret 。</p><hr><h1 id="Smcdeleg-Ssccfg扩展"><a href="#Smcdeleg-Ssccfg扩展" class="headerlink" title="Smcdeleg&#x2F;Ssccfg扩展"></a>Smcdeleg&#x2F;Ssccfg扩展</h1><h2 id="Smcdeleg扩展"><a href="#Smcdeleg扩展" class="headerlink" title="Smcdeleg扩展&lt;计数器委托&gt;"></a>Smcdeleg扩展&lt;计数器委托&gt;</h2><p>mcounteren允许M模式下放对计数器的读权限到S&#x2F;U模式，而此扩展将硬件性能计数器（如 hpmcounter、cycle 等）的<strong>写</strong>权限委托给 Supervisor 模式（S-mode），无需 M-mode 直接干预。通过menvcfg.CDE&#x3D;1 启用委托功能。</p><p>这里的hpmcounter, cycle, hpmevent是特权模式下计数器的子集，而非影子寄存器。</p><h2 id="Ssccfg扩展"><a href="#Ssccfg扩展" class="headerlink" title="Ssccfg扩展"></a>Ssccfg扩展</h2><p>为 S-mode 提供<strong>计数器配置与管理的直接接口</strong>，包括启用&#x2F;禁用计数器、设置事件触发条件等。当委托生效时，扩展允许 <strong>S</strong> 模式通过 <strong>sireg*</strong> 寄存器来<strong>读写</strong> cycle, instret, hpmcounter3<del>31, hpmevent3</del>31, cyclecfg, instretcfg 寄存器。</p><p>注，sireg&#x2F;siselect 由Sscsrind&#x2F;Ssaia定义。</p><hr><p>Smcdeleg&#x2F;Ssccfg扩展最大的贡献是将counter的控制权限交给了S模式，于是可以在S模式处理counter的中断和异常。扩展不涉及 time CSR 的相关功能（time永远以固定频率递增的，不能禁止）。</p><p>Smcdeleg&#x2F;Ssccfg扩展还定义了<strong>scountinhibit</strong>, 作为<strong>mcountinhibit</strong>的<strong>Masked别名</strong>。对于委托给S模式的counter, 可通过scountinhibit访问(读写)关联的mcountinhibit的位域，对于未委托给S模式的counter, scountinhibit中对应的位域为只读零。</p><hr><h1 id="Sscofpmf扩展"><a href="#Sscofpmf扩展" class="headerlink" title="Sscofpmf扩展"></a>Sscofpmf扩展</h1><p>Sscntrpmf提供了cycle和instret计算器在不同权限模式下的被禁止计数的能力。而此扩展则针对HPM计数器提供了相同的能力，且提供了溢出中断相关规定。这些位域被定义在mhpmevent寄存器中。OF写0时表示溢出中断被使能，OF写1时表示溢出中断被禁止。当写0时，HPMcounter的计数器溢出，会触发一个中断，同时OF被硬件写1。中断触发后，中断处理程序需要先对<strong>LCOFIP</strong>进行清理再处理溢出。通过向hpmcounter写0来清理计数器。hpmevent中关于不同权限禁止计数器增加的定义和Sscntrpmf中的定义一致。</p><p>扩展还提供了 <strong>scountovf</strong> CSR拉记录具体是哪个HPM溢出。在M模式下，scountovf始终是可读的，在S模式下，如果mcounteren对应的bit为1，sccountovf也是可读的，否则只读为0.</p><hr><h1 id="Sstc扩展"><a href="#Sstc扩展" class="headerlink" title="Sstc扩展"></a>Sstc扩展</h1><p>该扩展向S模式提供了一个CSR <strong>stimecmp</strong>, 用于S模式下的timer中断。该CSR和mtimecmp不同，mtime&#x2F;mtimecmp是memory mapped的。</p><p>当Sstc被实现：</p><blockquote><p>mip.STIP为只读位，反映stimecmp生成的中断，中断是否响应取决于使能和委托。<br>sip.STIP为只读位，反映stimecmp生成的中断，中断是否响应取决于使能和委托。</p></blockquote><p>向stimecmp写入大于time的值可清理中断（STIP位）。</p><p>mcounteren.TM被设置，允许S模式访问stimecmp，否则将引发非法指令异常。</p><p>menvcfg.STCE未设置，则类似于Sstc未被实现。</p>]]></content>
      
      
      <categories>
          
          <category> RISC-V </category>
          
          <category> counter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RISC-V </tag>
            
            <tag> counter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RISC-V Svnapot</title>
      <link href="/2025/04/08/RISC-V-Svnapot/"/>
      <url>/2025/04/08/RISC-V-Svnapot/</url>
      
        <content type="html"><![CDATA[<p><img src="/21-12-31.png" alt="Svnapot"><br>关键点是PPN[0]的最低4bit固定为4’b1000，所以物理地址不是从0开始，而是0x8000，在生成PTEtable时，物理地址以此为起始点。虚拟地址VPN[0]的最低4bit会替换PPN[0]的最低4bit，合并起来就是offset是16 bit，也就是PPN[0]的最低4bit对地址不产生影响，只是用来标识64KB的粒度。</p>]]></content>
      
      
      <categories>
          
          <category> RISC-V </category>
          
          <category> Extension </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RISC-V </tag>
            
            <tag> Extension </tag>
            
            <tag> Svnapot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RISC-V 扩展命名规则总结</title>
      <link href="/2025/04/08/RISC-V-%E6%89%A9%E5%B1%95%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99%E6%80%BB%E7%BB%93/"/>
      <url>/2025/04/08/RISC-V-%E6%89%A9%E5%B1%95%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<ol><li><p>不区分大小写；</p></li><li><p>Base Integer ISA (基础整数指令集)：RV32I, RV32E, RV64I, RV64E, RV128I.  Spec中也用 “base integer prefix” 或 “integer bases” 指代；</p></li><li><p>Standard ISA Extensions（标准指令集扩展） ：单个字母给出的扩展；特殊字母G代表”IMAFDZicsr_Zifencei“；</p></li><li><p>RISC-V ISA strings 是由 Base Integer ISA开头，连接Standard ISA Extensions的字符串；</p></li><li><p>标准指令集扩展之间存在隐式依赖的情况，如D扩展依赖F扩展，F扩展依赖Zicsr扩展；</p></li><li><p>Version Numbers：版本号由major和minor 2部分构成，用”p“连接，”p0”可以省略。major的变化意味着失去后向兼容性，minor的变化必须后向兼容；如，”RV64I1p0M1p0A1p0F1p0D1p0”等效于”RV64I1M1A1F1D1”；</p><ol><li>获取当前指令版本号riscv64-unknown-linux-gnu-gcc -march&#x3D;rv64gcv -dM -E - &lt; &#x2F;dev&#x2F;null|grep riscv</li><li>宏定义中的版本编码 &#x3D; major<em>1000000 + minor</em>1000</li></ol></li><li><p>扩展之间可用”_”连接，以便增加可读性，如 “RV32I2_M2_A2”，注意，如果字母”P”在数字后面，当表示扩展时必须使用下划线，如”rv32i2_p2”, “p” 表示扩展，“rv32i2p2”则表示2.2版本；</p></li><li><p>标准扩展（Standard Extensions）（这里指多字母标准扩展，非特权扩展）也可用字母”Z + 字母扩展名 &lt; + 版本 &gt;” 表示，如”Zifencei“， ”Zifencei2p0“;</p></li><li><p>“Z” 后面的第一个字母通常表示最密切相关的字母扩展类别，IMAFDQCVH.</p><ol><li>“Zfa” 扩展，字母 “f” 表示该扩展与 “F” 标准扩展相关。</li></ol></li><li><p>如果命名了多个“Z”扩展名，则应先按类别排序，然后按类别内的字母顺序排序，例如“Zicsr_Zifencei_Zam”, 即i类在a类前, 都是i类则按字母顺序排；</p></li><li><p>所有多字母扩展名，包括带有 “Z” 前缀的扩展名，必须用下划线与其他多字母扩展名分隔，例如 “RV32IMACZicsr_Zifencei”；</p></li><li><p>”supervisor-level virtual-memory architecture“ 相关的标准扩展（Standard extensions）用”Sv + 字母扩展名 &lt; + 版本 &gt;” 表示，其他S级别的扩展以“Ss”开头；</p></li><li><p>标准主管级扩展（standard supervisor-level extensions）应列在标准非特权扩展之后。如果列出了多个主管级别的扩展，则应按字母顺序对它们进行排序；</p></li><li><p>Standard hypervisor-level architecture 的标准扩展（standard extensions)以”Sh“开头，多个H级别扩展按字母顺序对它们进行排序；</p></li><li><p>Standard machine-level 指令扩展以”Sm”开头，多个M级别扩展按字母顺序排序; M扩展指令应排在较低权限级别的标准扩展之后；</p></li><li><p>非标准扩展以”X”开头，形式和Z扩展类似；</p></li><li><p>非标准扩展名必须列在所有标准扩展名之后，并且与其他多字母扩展名一样，必须用下划线与其他多字母扩展名分隔；</p></li><li><p>如果列出了多个非标准扩展，则应按字母顺序对它们进行排序；</p></li></ol><p>以下表格是Spec中给出的按riscv扩展指令集名称中排序定义的扩展（排在前面的扩展对应顶部的位置），书写扩展名时在上面的扩展更靠前：</p><p><img src="/SISAEN.png"></p>]]></content>
      
      
      <categories>
          
          <category> RISC-V </category>
          
          <category> Spec </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RISC-V </tag>
            
            <tag> Extension </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AMD Zen5 微架构软件优化指南</title>
      <link href="/2025/03/18/AMD-Zen5-%E5%BE%AE%E6%9E%B6%E6%9E%84%E8%BD%AF%E4%BB%B6%E4%BC%98%E5%8C%96%E6%8C%87%E5%8D%97/"/>
      <url>/2025/03/18/AMD-Zen5-%E5%BE%AE%E6%9E%B6%E6%9E%84%E8%BD%AF%E4%BB%B6%E4%BC%98%E5%8C%96%E6%8C%87%E5%8D%97/</url>
      
        <content type="html"><![CDATA[<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><ul><li><p><a href="#1-%E5%BC%95%E8%A8%80">1. 引言</a></p><ul><li><a href="#11-%E7%9B%AE%E6%A0%87%E5%8F%97%E4%BC%97">1.1 目标受众</a></li><li><a href="#12-%E7%9B%B8%E5%85%B3%E6%96%87%E6%A1%A3">1.2 相关文档</a></li><li><a href="#13-%E4%B8%93%E4%B8%9A%E6%9C%AF%E8%AF%AD">1.3 专业术语</a></li></ul></li><li><p><a href="#2-zen5-%E5%A4%84%E7%90%86%E5%99%A8%E5%BE%AE%E6%9E%B6%E6%9E%84">2. Zen5 处理器微架构</a></p><ul><li><a href="#21-%E5%85%B3%E9%94%AE%E5%BE%AE%E6%9E%B6%E6%9E%84%E7%89%B9%E6%80%A7">2.1 关键微架构特性</a></li><li><a href="#22-%E7%BC%93%E5%AD%98%E4%B8%8E%E6%95%B0%E6%8D%AE%E9%80%9A%E8%B7%AF">2.2 缓存与数据通路</a></li><li><a href="#23-%E6%8C%87%E4%BB%A4%E5%88%86%E8%A7%A3%E6%9C%BA%E5%88%B6">2.3 指令分解机制</a></li><li><a href="#24-%E8%B6%85%E6%A0%87%E9%87%8F%E6%9E%B6%E6%9E%84">2.4 超标量架构</a></li><li><a href="#25-%E5%A4%84%E7%90%86%E5%99%A8%E7%BB%93%E6%9E%84">2.5 处理器结构</a></li><li><a href="#26-%E7%BC%93%E5%AD%98%E6%93%8D%E4%BD%9C">2.6 缓存操作</a><ul><li><a href="#261-l1i-cache">2.6.1 L1I Cache</a></li><li><a href="#262-l1d-cache">2.6.2 L1D Cache</a><ul><li><a href="#2621-bank-conflicts">2.6.2.1 Bank Conflicts</a></li><li><a href="#2622-512bit-loadstore-%E6%93%8D%E4%BD%9C">2.6.2.2 512bit load&#x2F;store 操作</a></li><li><a href="#2623-%E5%9F%BA%E4%BA%8E%E7%BA%BF%E6%80%A7%E5%9C%B0%E5%9D%80%E7%9A%84utagway-predictor">2.6.2.3 基于线性地址的utag&#x2F;way-predictor</a></li></ul></li><li><a href="#263-l2-cache">2.6.3 L2 Cache</a></li><li><a href="#264-l3-cache">2.6.4 L3 Cache</a></li></ul></li><li><a href="#27-%E5%86%85%E5%AD%98%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2">2.7 内存地址转换</a><ul><li><a href="#271-%E4%B8%A4%E7%BA%A7tlb%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1">2.7.1 两级TLB结构设计</a></li><li><a href="#272-%E7%A1%AC%E4%BB%B6%E9%A1%B5%E8%A1%A8%E9%81%8D%E5%8E%86%E5%99%A8%E4%B8%8E%E5%8A%A0%E9%80%9F%E6%9C%BA%E5%88%B6">2.7.2 硬件页表遍历器与加速机制</a></li><li><a href="#273-%E8%99%9A%E6%8B%9F%E5%8C%96%E4%B8%8E%E8%83%BD%E6%95%88%E4%BC%98%E5%8C%96">2.7.3 虚拟化与能效优化</a></li><li><a href="#274-%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94%E4%B8%8E%E5%9C%BA%E6%99%AF%E5%BA%94%E7%94%A8">2.7.4 性能对比与场景应用</a></li></ul></li><li><a href="#28-%E5%88%86%E6%94%AF%E4%BC%98%E5%8C%96">2.8 分支优化</a><ul><li><a href="#281-%E5%88%86%E6%94%AF%E9%A2%84%E6%B5%8B%E5%99%A8">2.8.1 分支预测器</a><ul><li><a href="#2811-next-address-logic">2.8.1.1 next-address logic</a></li><li><a href="#2812-branch-target-buffer">2.8.1.2 Branch Target Buffer</a></li><li><a href="#2813-return-address-stack">2.8.1.3 Return Address Stack</a></li><li><a href="#2814-indirect-target-predictor">2.8.1.4 Indirect Target Predictor</a></li><li><a href="#2815-advanced-conditional-branch-direction-predictor">2.8.1.5 Advanced Conditional Branch Direction Predictor</a></li><li><a href="#2816-fetch-window-tracking-structure">2.8.1.6 Fetch Window Tracking Structure</a></li></ul></li><li><a href="#282">2.8.2 跨边界分支 Boundary Crossing Branches</a></li><li><a href="#283">2.8.3 循环对齐 Loop Alignment</a><ul><li><a href="#2831-%E7%BC%96%E7%A0%81%E5%A1%AB%E5%85%85%E4%BB%A5%E5%AE%9E%E7%8E%B0%E5%BE%AA%E7%8E%AF%E5%AF%B9%E9%BD%90">2.8.3.1 编码填充以实现循环对齐</a></li></ul></li></ul></li><li><a href="#29-%E5%8F%96%E6%8C%87%E4%B8%8E%E8%AF%91%E7%A0%81">2.9 取指与译码</a><ul><li><a href="#291-op-cache">2.9.1 Op Cache</a></li><li><a href="#292">2.9.2 依赖项消除的惯用方法Idioms for Dependency removal</a></li><li><a href="#293">2.9.3 分支融合</a></li><li><a href="#294-mov--alu-fusion">2.9.4 MOV + ALU Fusion</a></li><li><a href="#295-zero-cycle-move">2.9.5 Zero Cycle Move</a></li><li><a href="#296">2.9.6 栈指针跟踪以消除依赖</a></li><li><a href="#297">2.9.7 指令分发</a></li><li><a href="#298">2.9.8 使用 PAUSE 指令优化自旋循环</a></li><li><a href="#299">2.9.9 其他解码注意事项</a></li></ul></li><li><a href="#210">2.10 整数执行单元</a><ul><li><a href="#2101-schedulers">2.10.1 Schedulers</a></li><li><a href="#2102">2.10.2 执行单元</a></li><li><a href="#2103">2.10.3 退役控制单元</a></li></ul></li><li><a href="#211">2.11 浮点单元</a><ul><li><a href="#2111">2.11.1 浮点执行资源</a></li><li><a href="#2112">2.11.2 代码优化建议</a></li><li><a href="#2113-x87-%E4%BB%A3%E7%A0%81%E7%9A%84%E6%B5%AE%E7%82%B9%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96">2.11.3 x87 代码的浮点性能优化</a></li><li><a href="#2114">2.11.4 非规格化数</a></li><li><a href="#2115-xmm-%E5%AF%84%E5%AD%98%E5%99%A8%E5%90%88%E5%B9%B6%E4%BC%98%E5%8C%96">2.11.5 XMM 寄存器合并优化</a></li><li><a href="#2116-%E6%B7%B7%E5%90%88%E4%BD%BF%E7%94%A8-avx-%E5%92%8C-sse-%E6%8C%87%E4%BB%A4%E7%9A%84%E6%80%A7%E8%83%BD%E6%83%A9%E7%BD%9A">2.11.6 混合使用 AVX 和 SSE 指令的性能惩罚</a></li><li><a href="#2117-%E4%BD%95%E6%97%B6%E4%BD%BF%E7%94%A8-fma-%E8%80%8C%E9%9D%9E-fmulfadd">2.11.7 何时使用 FMA 而非 FMUL&#x2F;FADD</a></li></ul></li><li><a href="#212">2.12 加载-存储单元</a><ul><li><a href="#2121">2.12.1 数据预取</a></li></ul></li><li><a href="#213">2.13 写入数据优化</a><ul><li><a href="#2131-%E8%BD%AF%E4%BB%B6%E9%A2%84%E5%8F%96%E6%95%B0%E6%8D%AE%E6%88%96%E6%8C%87%E4%BB%A4">2.13.1 软件预取数据或指令</a></li><li><a href="#2132">2.13.2 写合并操作</a></li><li><a href="#2133">2.13.3 将写缓冲区数据发送到系统</a></li><li><a href="#2134">2.13.4 字符串存储优化</a></li></ul></li><li><a href="#214">2.14 同步多线程</a></li></ul></li></ul><hr><h1 id="1-引言"><a href="#1-引言" class="headerlink" title="1. 引言"></a>1. 引言</h1><h2 id="1-1-目标受众"><a href="#1-1-目标受众" class="headerlink" title="1.1 目标受众"></a>1.1 目标受众</h2><ul><li><strong>编译器&#x2F;汇编器设计者</strong></li><li><strong>高性能代码开发者</strong>（C&#x2F;C++&#x2F;汇编语言）</li><li>要求熟悉 AMD64 指令集与架构（寄存器&#x2F;编程模式）</li></ul><h2 id="1-2-相关文档"><a href="#1-2-相关文档" class="headerlink" title="1.2 相关文档"></a>1.2 相关文档</h2><table><thead><tr><th>文档标题</th><th>编号</th></tr></thead><tbody><tr><td>AMD64 架构程序员手册（应用编程）</td><td>24592</td></tr><tr><td>AMD64 架构程序员手册（系统编程）</td><td>24593</td></tr><tr><td>Zen5 处理器编程参考（PPR）</td><td>55901</td></tr></tbody></table><h2 id="1-3-专业术语"><a href="#1-3-专业术语" class="headerlink" title="1.3 专业术语"></a>1.3 专业术语</h2><table><thead><tr><th>术语</th><th>定义</th></tr></thead><tbody><tr><td>CPU Complex</td><td>共享 L3 缓存的 CPU 核心组</td></tr><tr><td>Dispatching</td><td>将宏操作（macro-ops）从前端传输到乱序后端</td></tr><tr><td>Issuing</td><td>从调度器选择微操作（micro-ops）派发到执行管道</td></tr></tbody></table><hr><h1 id="2-Zen5-处理器微架构"><a href="#2-Zen5-处理器微架构" class="headerlink" title="2. Zen5 处理器微架构"></a>2. Zen5 处理器微架构</h1><h2 id="2-1-关键微架构特性"><a href="#2-1-关键微架构特性" class="headerlink" title="2.1 关键微架构特性"></a>2.1 关键微架构特性</h2><ul><li><strong>指令集支持</strong>：<ul><li><strong>AVX-512 全功能扩展</strong>（F&#x2F;BW&#x2F;VL&#x2F;CD&#x2F;VNNI&#x2F;BF16 等 12 个子集）</li><li><strong>安全扩展</strong>：SEV-SNP（RMPUPDATE&#x2F;PVALIDATE）</li><li><strong>虚拟化加速</strong>：INVLPGB&#x2F;TLBSYNC</li></ul></li><li><strong>缓存层次</strong>：<ul><li>L1 指令缓存：32KB&#x2F;8-way</li><li>L1 数据缓存：48KB&#x2F;12-way（支持 512 位存储）</li><li>L2 缓存：1MB&#x2F;16-way（14 周期延迟）</li><li>L3 缓存：最高 96MB（46 周期延迟）</li></ul></li></ul><hr><h2 id="2-2-缓存与数据通路"><a href="#2-2-缓存与数据通路" class="headerlink" title="2.2 缓存与数据通路"></a>2.2 缓存与数据通路</h2><table border="1">  <thead align="center">  <tr>    <td colspan='17' > Fetch Width </td>  </tr>  </thead>  <tbody align="center">  <tr>    <td rowspan='2' align='left' > OC Fetch </td>    <td colspan='8' > 128 </td>    <td colspan='4'> </td>  </tr>  <tr>    <td colspan='4'> </td>    <td colspan='8' > 128 </td>  </tr>  <tr>    <td align='left'> Cacheline </td>    <td colspan='4' > 64 </td>    <td colspan='4' > 64 </td>    <td colspan='4' > 64 </td>  </tr>  <tr>    <td align='left'> IC Fetch </td>    <td colspan='2' > 32 </td>    <td colspan='2' > 32 </td>    <td colspan='2' > 32 </td>    <td colspan='2' > 32 </td>    <td colspan='2' > 32 </td>    <td colspan='2' > 32 </td>  </tr>  <tr>    <td align='left'> Decode </td>    <td > 16 </td>    <td > 16 </td>    <td > 16 </td>    <td > 16 </td>    <td > 16 </td>    <td > 16 </td>    <td > 16 </td>    <td > 16 </td>    <td > 16 </td>    <td > 16 </td>    <td > 16 </td>    <td > 16 </td>  </tr>  </tbody></table><table><thead><tr><th>参数</th><th>宽度（字节）</th><th>说明</th></tr></thead><tbody><tr><td>OC Fetch</td><td>128</td><td>Op Cache单次抓取指令块大小，支持高吞吐指令预取</td></tr><tr><td>Cacheline</td><td>64</td><td>所有缓存层级的行大小（L1&#x2F;L2&#x2F;L3），决定内存对齐优化粒度</td></tr><tr><td>IC Fetch</td><td>32</td><td>L1指令缓存单周期抓取32字节指令块，支持双解码器并行处理</td></tr><tr><td>Decode</td><td>16</td><td>解码器单周期处理16字节指令，需结合宏操作拆分策略优化指令密度</td></tr></tbody></table><table><thead><tr><th>参数</th><th>值</th></tr></thead><tbody><tr><td>缓存行大小 Cacheline</td><td>64 字节</td></tr><tr><td>数据通路宽度 Data Pipe</td><td>64 字节</td></tr><tr><td>存储提交宽度 Store Commit</td><td>64 字节</td></tr></tbody></table><p><strong>数据对齐优化</strong>：</p><ul><li>64 字节对齐访问避免跨缓存行惩罚</li><li>256 位向量建议 32 字节对齐（性能提升 20%）</li></ul><hr><h2 id="2-3-指令分解机制"><a href="#2-3-指令分解机制" class="headerlink" title="2.3 指令分解机制"></a>2.3 指令分解机制</h2><p><strong>1. 指令实现方式</strong></p><ul><li><strong>宏操作（Macro-ops）</strong>：处理器管理的主要工作单元。</li><li><strong>微操作（Micro-ops）</strong>：在处理器执行单元中执行的原始操作。</li><li><strong>AMD64指令集支持</strong>：通过宏操作和微操作实现，遵循高性能原则，包括固定长度编码、规整化指令字段和大寄存器集。</li><li><strong>微架构优势</strong>：提升处理器内核性能，并为未来设计提供直接的可扩展性。</li></ul><p><strong>2. 指令分类</strong></p><ul><li><strong>快速单路径（Fast Path Single）</strong>：一个宏操作。</li><li><strong>快速双路径（Fast Path Double）</strong>：两个宏操作。</li><li><strong>微码（Microcode）</strong>：多于两个宏操作。</li><li><strong>宏操作容量</strong>：通常一个宏操作最多可包含两个微操作。</li></ul><p><strong>3. 指令映射</strong></p><ul><li><strong>指令到宏操作的映射</strong>：指令被映射到宏操作。</li><li><strong>宏操作到微操作的映射</strong>：宏操作被映射到一个或多个微操作。</li><li><strong>示例表格</strong>：展示了指令如何映射到宏操作，以及宏操作如何映射到微操作。</li></ul><table><thead><tr><th>指令示例</th><th>Macro-ops 宏操作</th><th>Micro-ops 微操作</th><th>类型</th></tr></thead><tbody><tr><td><code>MOV reg, [mem]</code></td><td>1</td><td>1 : load</td><td>Fastpath single</td></tr><tr><td><code>ADD [mem], reg</code></td><td>1</td><td>2 : load&#x2F;store, add</td><td>Fastpath double</td></tr><tr><td><code>REP MOVS [mem], [mem]</code></td><td>M</td><td>many</td><td>Microcode</td></tr></tbody></table><hr><h2 id="2-4-超标量架构"><a href="#2-4-超标量架构" class="headerlink" title="2.4 超标量架构"></a>2.4 超标量架构</h2><p>Zen5处理器是一款支持乱序执行的双线程超标量AMD64处理器。其采用解耦执行单元的结构来处理fetch&#x2F;branch-predict, decode, schedule&#x2F;execute, 和 retirement pilelines.</p><ul><li><strong>独立的整数调度器队列</strong>，分组设计，服务于6个ALU算术逻辑单元流水线</li><li><strong>独立的地址生成队列</strong>，分组设计，服务于4个AGU地址生成单元流水线</li><li><strong>两套解耦的浮点调度器</strong>，每套调度器控制2个浮点流水线</li><li><strong>一套专用的浮点调度器</strong>，负责浮点store data，或者浮点到整数数据转换流水线</li></ul><p>这些调度器可协同工作，最高可同时向6个ALU流水线、4个AGU地址生成流水线和6个FPU浮点处理流水线分发16个微操作。</p><hr><h2 id="2-5-处理器结构"><a href="#2-5-处理器结构" class="headerlink" title="2.5 处理器结构"></a>2.5 处理器结构</h2><p><img src="/image_1.png" alt="处理器结构"></p><p><strong>L1I缓存</strong>：32 KB，8路组相联，64B&#x2F;周期（分2组32字节块喂给2个解码器管线&lt;双线程&gt;）</p><p><strong>L1D缓存</strong>：48 KB，12路组相联，4读&#x2F;2写端口，64字节填充与替换策略</p><p><strong>分支预测器</strong>：2分支&#x2F;周期</p><p><strong>解码器</strong>：单线程4指令&#x2F;周期，双线程8指令&#x2F;周期</p><p><strong>微码缓存</strong>：可缓存6K条指令，每个周期12条指令，单个线程6条&#x2F;周期，存储被解码的指令信息</p><p><strong>微操作队列UOPQ</strong>: 每个周期调度（Dispatch）8条宏操作</p><p><strong>整数单元</strong></p><ul><li>一个整数重命名单元，一个周期可处理8条指令</li><li>2个独立的调度器，指令调度器一个周期最多 <strong>issue</strong> 6条整数指令; 地址生成调度器一个周期处理4条地址生成指令</li><li>通用寄存器位宽：64bit</li><li>6个ALU, 4个AGU</li></ul><p><strong>浮点单元</strong></p><ul><li>一个重命名单元，一个周期可处理6条指令</li><li>调度器：3组</li><li>向量寄存器：512bit</li><li>浮点运算单元：FMUL, FMA, FADD</li><li>存储和转换单元：Std, IntD</li></ul><hr><h2 id="2-6-缓存操作"><a href="#2-6-缓存操作" class="headerlink" title="2.6 缓存操作"></a>2.6 缓存操作</h2><p>Zen5微架构在三个层次使用5个缓存来加速指令执行和数据处理：<strong>专用L1I Cache, 专用的L1D Cache, 专用的L1 Op Cache, 每个Core（指令和数据统一）L2 Cache，高达96MB L3 Cache</strong></p><hr><h3 id="2-6-1-L1I-Cache"><a href="#2-6-1-L1I-Cache" class="headerlink" title="2.6.1 L1I Cache:"></a><strong>2.6.1 L1I Cache</strong>:</h3><ul><li>32KB，8路组相连，Cacheline 64 bytes（内存总线上512b&#x2F;cycle）</li><li>每周期64 bytes，即2个32字节对齐的块，提供给2个解码器管线&lt;双线程&gt;</li><li>主要功能：L1I Cache Miss时，从L2缓存提取缓存行-&gt;向解码器提供指令字节-&gt;预取指令</li></ul><p>当指令在L1指令缓存中未命中时，请求会从L2缓存中提取；如果L2缓存中也不存在，则从L3缓存（如果有）中提取；如果所有级别缓存均未命中，则从系统内存中提取。</p><p>当发生未命中时，L1指令缓存会为包含未命中地址的自然对齐的64字节缓存行生成填充请求。这些缓存行从分支预测单元生成的地址处预取。对于之前从未见过的缓存行，分支预测器通常预测为顺序访问，从而起到行预取器的作用，避免下游缓存未命中造成的停顿。</p><p>由于代码通常表现出空间局部性，预取是一种有效避免缓存未命中停顿的技术。缓存行替换基于最近最少使用（LRU）算法。L1指令缓存使用奇偶校验来防止错误。</p><hr><h3 id="2-6-2-L1D-Cache"><a href="#2-6-2-L1D-Cache" class="headerlink" title="2.6.2 L1D Cache:"></a><strong>2.6.2 L1D Cache</strong>:</h3><ul><li>48 KB, 12路组相联</li><li>工作模式，回写式，支持高吞吐量内存操作</li><li>最多4个load&#x2F;周期，其中最多2个512&#x2F;256&#x2F;128位 load操作</li><li>最多2个store&#x2F;周期, 大小8-256B，最多一个512位 store操作</li><li>纠错：ECC</li><li>硬件预取器将数据预取到L1D Cache，避免Miss</li><li>延迟：整数load,4-5周期；FPU load, 7-8周期</li><li>对齐：64B，否则至少惩罚1个周期，吞吐量降低50%</li><li>跨4 KB边界的未对齐操作在某些情况下会遭受额外的显著处罚<ul><li>AXI协议按4KB地址空间进行划分，跨4KB会被分成2次突发传输</li><li>Page分页按4KB粒度一个条目，跨页会导致MMU2次页表查询</li><li>未对齐访问可能引发异常</li><li>对于SIMD指令或向量化操作，跨4KB边界的未对齐访问可能破坏向量化条件，导致回退为标量处理</li></ul></li></ul><hr><h4 id="2-6-2-1-Bank-Conflicts"><a href="#2-6-2-1-Bank-Conflicts" class="headerlink" title="2.6.2.1 Bank Conflicts:"></a><strong>2.6.2.1 Bank Conflicts</strong>:</h4><p>L1数据缓存（L1 DC）采用分Bank结构提供多个访问端口。读端口由4个加载流水线（load pipe）和受害者缓存（victim read）共享，写操作则使用独立的写端口。地址的第5-3位（bits 5:3）以及访问大小与DC的Way（由线性地址的utag&#x2F;way预测器决定）共同决定访问所需的Bank。当多个操作请求同一Bank或端口时，会触发Bank冲突或端口冲突，导致需重新执行冲突的加载操作，表现为更高的加载延迟。</p><p>若怀疑存在Bank冲突，可通过以下方法缓解：</p><ul><li><strong>使用对齐内存访问</strong>：未对齐访问可能占用更多Bank或端口</li><li><strong>合并小粒度操作</strong>：将连续的字节级加载&#x2F;存储合并为双字（doubleword）或四字（quadword）操作</li><li><strong>优化存储操作</strong>：未对齐或小于双字大小的存储对Bank&#x2F;端口利用率最低</li><li><strong>循环展开与指令编排</strong>：对连续地址的流式访问循环进行展开，每组循环中合并最多4个标量加载（或2个向量&#x2F;浮点加载），以降低Bank冲突。但受乱序执行影响，指令编排不保证实际执行顺序</li></ul><hr><h4 id="2-6-2-2-512bit-load-store-操作："><a href="#2-6-2-2-512bit-load-store-操作：" class="headerlink" title="2.6.2.2 512bit load&#x2F;store 操作："></a><strong>2.6.2.2 512bit load&#x2F;store 操作</strong>：</h4><p><strong>1. 512位加载操作的执行逻辑</strong></p><p>Zen5的L1数据缓存（L1 DC）采用分Bank设计，支持每个周期最多两个512位加载操作。为实现512位（64字节）加载，硬件将两个256位加载流水线（Load Pipe）<strong>配对使用</strong>，以单周期完成一次完整操作</p><ul><li><strong>限制条件</strong>：若当前周期执行512位加载，则<strong>整数加载无法使用配对的流水线</strong>，因为两个256位流水线已被完全占用。这一设计通过动态分配流水线资源，优先保障大位宽操作的吞吐效率</li></ul><p><strong>2. 512位存储操作的执行逻辑</strong></p><p>512位存储操作被分解为两个独立<strong>微</strong>操作：</p><ul><li><strong>地址生成微操作（Store Address uOP）</strong>：计算存储地址并提交到存储队列。</li><li><strong>数据提交微操作（Store Data uOP）</strong>：将512位数据写入缓存行（需占用浮点单元的数据通路）</li><li><strong>资源占用</strong>：每个存储操作需占用<strong>两个派发槽（Dispatch Slots）和两个存储队列条目（Store Queue Entries）</strong>，以分别处理地址与数据</li></ul><p><strong>3. 硬件优化与约束</strong>：</p><p>Zen5的L1数据缓存支持每个周期最多两个存储操作，其中<strong>仅允许一个512位存储</strong>。这一限制源于存储队列的带宽与容量设计：</p><ul><li><strong>存储队列结构</strong>：每个条目需同时保存地址与数据元数据，512位存储因数据体积较大需拆分到两个条目</li><li><strong>浮点单元协同</strong>：512位存储的数据部分依赖浮点执行单元（FPU）的512位数据通路，而Zen5的FPU经过升级可直接处理完整512位数据包，避免了Zen4中双256位拼接的开销</li></ul><p><strong>4. 架构设计意义与性能权衡</strong></p><p><strong>4.1 AVX-512指令集优化</strong></p><p>Zen5通过引入<strong>真正的512位FPU单元</strong>，显著提升了AVX-512指令的执行效率。与Zen4使用双256位拼接的“伪512位”方案相比，Zen5的完整位宽支持降低了指令拆分带来的延迟，并减少了功耗</p><ul><li><strong>数据吞吐提升</strong>：在AI推理与科学计算中，512位操作的单周期完成能力可提高向量化代码的吞吐量，例如矩阵乘法（FMA指令）的峰值性能提升约30%</li></ul><p><strong>4.2 资源冲突管理</strong></p><p>Zen5通过<strong>动态流水线分配策略</strong>平衡大位宽操作与常规整数操作的需求：</p><ul><li><strong>优先级机制</strong>：512位加载&#x2F;存储优先占用流水线资源，确保向量化密集型任务的效率，而整数操作通过乱序执行引擎（OoO）调度填补空闲周期</li><li><strong>队列深度优化</strong>：存储队列条目数量的增加（相比Zen4）缓解了拆分微操作导致的资源争用问题，减少流水线停顿概率</li></ul><hr><h4 id="2-6-2-3-基于线性地址的utag-way-predictor"><a href="#2-6-2-3-基于线性地址的utag-way-predictor" class="headerlink" title="2.6.2.3 基于线性地址的utag&#x2F;way-predictor"></a><strong>2.6.2.3 基于线性地址的utag&#x2F;way-predictor</strong></h4><p>L1数据缓存的标签中存储了一个<strong>基于线性地址的微标签（UTAG）</strong>，该标签用于标记缓存行最初访问时使用的线性地址。</p><ul><li><strong>加载操作</strong>利用UTAG，在物理地址通过TLB转换完成之前，直接根据线性地址预测应访问的缓存路（Way）。UTAG是线性地址的哈希值。</li><li>这种基于线性地址的路预测机制允许在读取缓存数据前<strong>精准预测目标缓存行所在的路</strong>，从而只需访问单一路而非全部12路，显著降低功耗并减少Bank冲突。</li></ul><p><strong>1. UTAG误判的可能情况</strong>：</p><ul><li><strong>误命中</strong>（预测命中但实际未命中）或<strong>误未命中</strong>（预测未命中但实际命中）。此时会触发向L2缓存的填充请求，并在L2响应后更新UTAG。</li><li><strong>线性别名冲突</strong>：不同线性地址映射到同一物理地址时，可能导致性能损失。例如，对同一物理地址但不同线性别名的加载操作会触发L1缓存未命中，需向L2请求数据，延迟通常等同于L2命中时间。</li><li><strong>哈希冲突</strong>：不同线性地址（未映射到同一物理地址）因哈希碰撞导致UTAG冲突。此时，L1缓存索引（线性地址[11:6]）下仅允许存在一个匹配哈希的缓存行，其他冲突行将被标记为无效。</li></ul><p><strong>2. UTAG的核心设计思想</strong></p><p>UTAG是Zen5 L1数据缓存的关键创新，其核心逻辑在于提前利用线性地址哈希预测缓存路，从而规避传统物理地址转换（TLB查询）的延迟。通过将缓存路选择与物理地址解耦，UTAG在以下方面实现优化：</p><ul><li><strong>功耗降低</strong>：无需激活所有12路缓存，仅读取预测路的数据</li><li><strong>Bank冲突缓解</strong>：减少多路并行访问引发的Bank资源争用，提升吞吐量</li></ul><hr><h3 id="2-6-3-L2-Cache"><a href="#2-6-3-L2-Cache" class="headerlink" title="2.6.3 L2 Cache"></a><strong>2.6.3 L2 Cache</strong></h3><p>AMD Zen5微架构为每个核心实现了一个<strong>统一的16路组相联回写式L2缓存</strong>。该片上L2缓存采用<strong>包含性策略</strong>（Inclusive），即包含核心内所有L1缓存的内容。L2缓存容量为1 MB，其加载到使用的延迟可变且<strong>不低于14个周期</strong>。L2到L1的数据通路宽度为64字节。</p><p><strong>1. 包含性策略（Inclusive Policy）</strong><br><strong>1.1 定义与核心特性</strong><br>包含性策略是多级缓存架构中的一种设计原则，指<strong>外层缓存（如L3）包含所有内层缓存（如L1&#x2F;L2）的有效缓存行</strong>。例如，若L1缓存中存在某数据，则该数据的副本也必须存在于L2或L3缓存中 。</p><ul><li>其核心特性包括：<ul><li><strong>数据冗余</strong>：内层缓存的数据必须在外层缓存中存在备份。</li><li><strong>一致性简化</strong>：外层缓存作为全局数据状态的“目录”，可快速过滤一致性请求（如snoop操作），减少核间通信开销。</li><li><strong>空间效率牺牲</strong>：因数据重复存储，外层缓存的实际可用容量降低。</li></ul></li></ul><p><strong>1.2 工作原理</strong><br>以L1和L2缓存为例，包含性策略的执行流程如下：</p><ul><li><p>1.2.1 <strong>读</strong>请求处理：</p><ul><li>若数据在L1命中，直接返回。</li><li>若L1未命中但L2命中，将数据从L2加载到L1，并更新L1标签。</li><li>若L2未命中，从内存加载数据并同时写入L1和L2。</li></ul></li><li><p>1.2.2 <strong>写</strong>请求处理：</p><ul><li>修改L1数据时，需同步更新L2中的对应缓存行以维持包含性。</li></ul></li><li><p>1.2.3 <strong>缓存行淘汰</strong></p><ul><li>当L2淘汰某缓存行时，需发送“反向无效化”（Back Invalidation）信号，强制L1中对应的缓存行失效。</li></ul></li></ul><hr><h3 id="2-6-4-L3-Cache"><a href="#2-6-4-L3-Cache" class="headerlink" title="2.6.4 L3 Cache"></a><strong>2.6.4 L3 Cache</strong></h3><p>AMD Zen5微架构实现了最高96 MB的L3缓存（具体容量取决于SoC配置），该缓存为<strong>16路组相联结构</strong>，<u> 由CPU复合体（Core Complex,简写CCX）内的所有核心共享 </u>。L3缓存采用回写策略，其内容由L2缓存的淘汰数据填充。当<u>发生L3命中</u>时：</p><ul><li><strong>若命中来自存储操作</strong>，或该缓存行<strong>仅被单个核心读取过</strong>，则该行会被标记为无效并从L3中移除；</li><li><strong>若命中来自代码预取</strong>，或该行<strong>被多个核心读取过</strong>，则保留在L3中。 L3缓存为每个L2维护<strong>影子标签（Shadow Tags）</strong>。当某核心的本地L2和L3均未命中时，会查询影子标签：若发现数据存在于CCX内的其他L2缓存中，则触发<strong>缓存间直接传输</strong>。 L3缓存的平均加载到使用延迟为46个周期。</li><li>通过非时间性缓存填充指令（PREFETCHNTA）可减少一次性数据的缓存污染：使用PREFETCHNTA加载到L2的数据会被标记为快速淘汰候选；当这些数据从L2淘汰时，不会插入L3缓存。</li></ul><hr><h2 id="2-7-内存地址转换"><a href="#2-7-内存地址转换" class="headerlink" title="2.7 内存地址转换"></a>2.7 内存地址转换</h2><p>AMD Zen5微架构在内存地址转换机制上进行了多项创新，通过<strong>两级TLB结构、硬件页表遍历器优化及页面粉碎技术</strong>，显著提升了虚拟地址到物理地址的转换效率。以下从TLB层级设计、硬件加速机制及虚拟化支持三个维度展开分析：</p><h3 id="2-7-1-两级TLB结构设计"><a href="#2-7-1-两级TLB结构设计" class="headerlink" title="2.7.1 两级TLB结构设计"></a><strong>2.7.1 两级TLB结构设计</strong></h3><ul><li><strong>L1 TLB：全相联高灵活性</strong><ul><li><strong>L1指令TLB（ITLB）</strong>：64项(entries)全相联结构，支持4KB、2MB、1GB页面。全相联设计确保任意虚拟页可映射到任意TLB项，减少冲突概率，尤其适合指令流的空间局部性特征。</li><li><strong>L1数据TLB（DTLB）</strong>：96项(entries)全相联结构，额外支持16KB页面，并引入<strong>合并映射优化</strong>。当4个连续的4KB虚拟页对齐且物理地址连续时，可合并为单个16KB条目存储，提升TLB有效容量（如合并后等效384项）。</li><li><strong>模式限制</strong>：合并优化仅在**长模式（64位）**下启用，兼容现代操作系统与大型应用需求。</li></ul></li><li><strong>L2 TLB：组相联大容量</strong><ul><li><strong>L2 ITLB</strong>：2048项8路组相联，仅缓存4KB与2MB页，1GB页由L1 ITLB独占管理。组相联设计在容量与访问延迟间取得平衡，适合处理多线程高并发的指令流。</li><li><strong>L2 DTLB</strong>：4096项16路组相联（支持4KB&#x2F;16KB&#x2F;2MB页）+ 1024项4路组相联（专用于1GB页）。分层设计优化大页场景（如数据库、虚拟化），减少TLB未命中率。</li></ul></li></ul><hr><h3 id="2-7-2-硬件页表遍历器与加速机制"><a href="#2-7-2-硬件页表遍历器与加速机制" class="headerlink" title="2.7.2 硬件页表遍历器与加速机制"></a><strong>2.7.2 硬件页表遍历器与加速机制</strong></h3><ul><li><strong>硬件页表遍历器（Table Walker）</strong><ul><li><strong>并行处理能力</strong>：Zen5配备<strong>6个硬件遍历器</strong>，可同时处理指令侧与数据侧的TLB未命中请求，支持<strong>推测性页表预取</strong>，减少流水线停顿。</li><li><strong>缓存层级优化</strong>：<ul><li><strong>Page Walker Cache（PWC）</strong>：缓存页目录指针项（PDPEs）与页目录项（PDEs），跳过页表层级访问（如从PDPE直接获取物理页，减少3级访问）。</li><li><strong>Page Directory Cache（PDC）</strong>：64项缓存PML4E&#x2F;PML5E，加速顶级页表查询，尤其针对多级虚拟化（如嵌套分页）场景。</li></ul></li></ul></li><li><strong>页面粉碎（Page Smashing）技术</strong><ul><li><strong>动态页大小适配</strong>：当遇到<strong>客户机大页</strong>（<strong>如1GB</strong>）但宿主机仅支持小页时，Zen5将大页“粉碎”为小页（如拆分为2MB页）存储于TLB，兼容混合页表环境。</li><li><strong>刷新机制</strong>：执行INVLPG等指令时，L1 TLB会刷新同一1GB客户机线性地址对应的所有粉碎条目，L2 TLB则按上下文（如进程ID）批量刷新，确保一致性。</li></ul></li></ul><hr><h3 id="2-7-3-虚拟化与能效优化"><a href="#2-7-3-虚拟化与能效优化" class="headerlink" title="2.7.3 虚拟化与能效优化"></a><strong>2.7.3 虚拟化与能效优化</strong></h3><ul><li><strong>虚拟化支持</strong><ul><li><strong>嵌套分页加速</strong>：通过PDC与PWC缓存宿主机与客户机页表项，减少二级地址转换（SLAT）开销，提升虚拟机性能。</li><li><strong>EPT&#x2F;NPT优化</strong>：硬件遍历器直接处理扩展页表（EPT）与嵌套页表（NPT），避免软件模拟延迟，适用于云计算高密度虚拟化场景。</li></ul></li><li><strong>能效与面积平衡</strong><ul><li><strong>SRAM单元压缩</strong>：Zen5采用台积电N4X工艺，L3缓存面积较Zen4缩小34.6%（24→15.7 mm²），通过高密度SRAM与TSV（硅通孔）优化，维持高带宽同时降低功耗。</li><li><strong>动态功耗管理</strong>：TLB未命中时，硬件遍历器根据负载动态调整电压频率，结合Zen5的SMU（系统管理单元）实现能效最优。</li></ul></li></ul><hr><h3 id="2-7-4-性能对比与场景应用"><a href="#2-7-4-性能对比与场景应用" class="headerlink" title="2.7.4 性能对比与场景应用"></a><strong>2.7.4 性能对比与场景应用</strong></h3><ul><li><strong>性能优势</strong><ul><li><strong>延迟对比</strong>：L1 DTLB命中仅需1-2周期，L2 DTLB命中约5-7周期，显著低于传统页表遍历（14+周期）。</li><li><strong>吞吐量提升</strong>：6个硬件遍历器支持每周期处理多个未命中请求，向量化负载（如AI推理）的TLB未命中率降低40% 。</li></ul></li><li><strong>典型应用场景</strong><ul><li><strong>高性能计算</strong>：1GB大页支持减少TLB条目占用，优化大规模矩阵运算（如HPC）的内存访问。</li><li><strong>实时系统</strong>：合并映射与推测预取减少确定性延迟波动，满足高频交易、工业控制等实时性需求。</li><li><strong>云计算</strong>：页面粉碎与嵌套分页加速提升虚拟机密度，配合Zen5的3D V-Cache实现数据中心能效比优化。</li></ul></li></ul><hr><h2 id="2-8-分支优化"><a href="#2-8-分支优化" class="headerlink" title="2.8 分支优化"></a>2.8 分支优化</h2><p><strong>分支对指令吞吐量的影响</strong></p><ul><li>分支的概念 ：</li></ul><p>分支是程序控制流的一部分，通常用于实现条件语句（如 if-else）、循环（如 for、while）或函数调用等逻辑。分支会导致程序在运行时选择不同的执行路径。</p><ul><li><strong>分支带来的问题</strong> ：<ul><li><strong>流水线停滞（Pipeline Stall）</strong> ：<br>在现代处理器中，指令通常是通过流水线（pipeline）并行执行的。然而，当遇到分支指令时，处理器需要知道分支的方向（即是否跳转到目标地址），才能继续执行后续指令。如果分支的结果依赖于前面尚未完成的指令（例如比较操作或计算结果），则处理器必须等待这些指令完成，从而导致流水线停滞，降低指令吞吐量。</li><li><strong>性能瓶颈</strong> ：<br>流水线停滞会减少处理器的有效吞吐量，尤其是在分支密集型代码中，这种延迟会显著影响性能。</li></ul></li></ul><p><strong>分支预测的作用</strong></p><ul><li>分支预测的概念 ：</li></ul><p>分支预测是一种硬件技术，用于猜测分支指令的结果（即是否跳转）以及目标地址，从而使处理器能够在分支结果确定之前继续执行后续指令。如果预测正确，则可以避免流水线停滞；如果预测错误，则需要丢弃错误的指令并重新执行正确的路径。zen5上预测错误会带来<strong>12-18 cycles</strong>的延迟，通常情况是15cycles.</p><hr><h3 id="2-8-1-分支预测器"><a href="#2-8-1-分支预测器" class="headerlink" title="2.8.1 分支预测器"></a><strong>2.8.1 分支预测器</strong></h3><p>为了预测和加速分支，zen5采用了如下策略：</p><ul><li>next-address logic</li><li>branch target buffer</li><li>return address stack (RAS)</li><li>indirect target predictor</li><li>advanced conditional branch direction predictor</li><li>fetch window tracking structure</li></ul><hr><h4 id="2-8-1-1-next-address-logic"><a href="#2-8-1-1-next-address-logic" class="headerlink" title="2.8.1.1 next-address logic"></a><strong>2.8.1.1 next-address logic</strong></h4><p><strong>1. 指令获取地址的生成</strong></p><ul><li>Next-Address Logic 的作用 ：<ul><li><strong>Next-Address Logic 是处理器中用于确定下一条指令获取地址的硬件逻辑</strong>。</li><li>它的主要任务是为指令提取（instruction fetch）生成正确的地址。</li></ul></li><li><strong>无分支时的行为</strong> ：<ul><li>当当前获取块（fetch block）中未检测到分支时，Next-Address Logic 会计算下一个顺序（sequential）对齐的 64 字节指令块的起始地址。</li><li>这种计算是基于自然对齐的 64 字节缓存行（cacheline），并且每周期都会进行，以支持操作缓存（Op Cache）的带宽需求。</li><li>Fetch Block 是处理器每次从缓存中提取的一段固定大小的指令集合，通常与缓存行（Cache Line）的大小对齐。Zen5 为32Bytes, 每周期2个block.</li></ul></li><li>优化目标 ：<ul><li>在没有分支的情况下，按顺序提取指令可以最大化指令获取的效率，并充分利用缓存和流水线资源。(分支替换成其他指令以实现顺序执行)。</li></ul></li></ul><p><strong>2. 分支对指令获取的影响</strong></p><ul><li>分支导致的性能损失 ：<ul><li>如果分支的目标地址位于当前 64 字节缓存行的末尾，会导致一个缩短的获取块（shortened fetch block）。</li><li>缩短的获取块意味着该周期内提取的指令数量减少，从而导致指令获取带宽的损失。</li></ul></li><li>优化建议<ul><li>优化代码布局 ：<ul><li>开发者可以通过优化代码布局（如减少分支指令的数量或将分支集中在一起）来提高 Fetch Block 的利用率。</li><li>例如，将热点代码（frequently executed code）放置在连续的内存区域中，可以减少跨缓存行提取指令的频率。</li></ul></li><li>硬件设计 ：<ul><li>处理器设计者通过优化 Fetch Block 的大小和分支预测逻辑，来平衡指令获取效率和硬件复杂性。</li></ul></li></ul></li></ul><p><strong>3. 分支预测与非顺序地址生成</strong></p><ul><li><strong>分支识别后的行为</strong> ：<ul><li>当分支被识别时，Next-Address Logic 会被分支目标预测（branch target prediction）和分支方向预测（branch direction prediction）硬件重定向。</li><li>此时，Next-Address Logic 将生成一个非顺序的指令获取地址，而不是继续顺序提取下一个 64 字节块。</li><li>分支目标预测硬件负责预测分支的目标地址，确保处理器能够快速跳转到正确的指令流。</li><li>分支方向预测则负责判断分支是否会被执行（即是否跳转）。</li></ul></li></ul><hr><h4 id="2-8-1-2-Branch-Target-Buffer"><a href="#2-8-1-2-Branch-Target-Buffer" class="headerlink" title="2.8.1.2 Branch Target Buffer"></a><strong>2.8.1.2 Branch Target Buffer</strong></h4><p>分支目标缓冲区（BTB）具有两级结构（L1 BTB, L2 BTB），通过<strong>前一个fetch block得到的地址</strong>作为索引，在BTB中找到匹配的分支条目，从而得到目标跳转地址。每个条目存储了与分支指令及其目标地址相关的关键信息。这些信息用于加速分支预测和指令获取过程。</p><p><strong>1. BTB条目包含的信息：</strong></p><ul><li><strong>分支指令的地址</strong><ul><li>分支指令本身在内存中的地址（即分支指令的程序计数器值，PC）。</li><li>用于标识哪个分支指令对应此 BTB 条目。</li><li>当处理器遇到某个分支指令时，会通过其地址查找对应的 BTB 条目。</li></ul></li><li><strong>分支目标地址</strong><ul><li>如果分支被预测为“跳转”（taken），则分支目标地址是跳转后指令的起始地址。</li><li>用于快速定位分支跳转的目标地址，从而避免流水线停滞。</li></ul></li><li><strong>分支方向预测信息</strong><ul><li>表示分支是否会被执行（taken 或 not-taken）。</li><li>通常使用一个简单的状态机（如 2-bit 饱和计数器）来记录分支的历史行为。</li><li>状态机的状态可以反映分支的动态行为，例如：<ul><li>强预测为“跳转”（strongly taken）</li><li>弱预测为“跳转”（weakly taken）</li><li>强预测为“不跳转”（strongly not-taken）</li><li>弱预测为“不跳转”（weakly not-taken）</li></ul></li></ul></li><li><strong>分支类型</strong><ul><li>条件分支 ：根据某些条件决定是否跳转。</li><li>直接分支 ：目标地址在指令编码中明确指定。</li><li>间接分支 ：目标地址在运行时确定（例如函数指针调用或返回指令）。</li><li>调用（CALL）和返回（RET） ：特殊的分支指令，涉及栈操作。</li><li>循环分支：用于实现循环结构，通常出现在 for 或 while 循环中。</li><li>表驱动分支：使用跳转表（jump table）实现多路分支（类似于 switch-case）。</li><li>长跳转（Far Jump）：跨越较大的地址范围进行跳转，通常涉及段寄存器或跨模块跳转。</li></ul></li><li><strong>分支历史信息</strong><ul><li>某些高级 BTB 实现可能会存储分支的历史行为信息，例如最近几次分支是否被跳转。</li><li>用于提高分支方向预测的准确性。例如，全局历史寄存器（Global History Register, GHR）可能会与 BTB 结合使用，以捕获跨多个分支的行为模式。</li></ul></li></ul><p><strong>2. BTB工作流程</strong></p><p><strong>2.1 检测分支指令</strong></p><ul><li>当处理器从指令缓存中提取指令时，会检查当前 Fetch Block 是否包含分支指令。</li><li>如果检测到分支指令，则会尝试在 BTB 中查找对应的条目。</li></ul><p><strong>2.2 查找 BTB 条目</strong></p><ul><li>使用分支指令的程序计数器（PC）作为索引，在 BTB 中查找对应的条目。</li><li>如果找到匹配的条目，则读取以下信息：<ul><li>分支目标地址。</li><li>分支方向预测（taken 或 not-taken）。</li></ul></li></ul><p><strong>2.3 根据预测信息调整指令流</strong></p><ul><li>如果分支被预测为“跳转”（taken），则处理器会立即跳转到分支目标地址，并开始从该地址提取后续指令。</li><li>如果分支被预测为“不跳转”（not-taken），则处理器继续<strong>顺序</strong>提取下一条指令。</li></ul><p><strong>2.4 更新 BTB</strong></p><ul><li>如果分支指令的结果最终被确定（例如通过执行单元解析分支条件），处理器会更新 BTB 中的相应条目：<ul><li>更新分支目标地址（如果目标地址发生变化）。</li><li>更新分支方向预测信息（例如调整 2-bit 饱和计数器的状态）。</li></ul></li></ul><p><strong>3. BTB 的设计优化</strong></p><p><strong>3.1 BTB 的两级结构</strong></p><ul><li>L1 BTB ：<ul><li>容量为 16K 条目，主要用于<strong>快速预测常见分支类型</strong>（如直接分支、条件分支等）。</li><li>对于大多数分支类型，L1 BTB 可以实现<strong>零延迟</strong>预测（zero prediction bubbles），但对于返回指令和多目标间接分支，会有<strong>两周期的延迟</strong>（two-cycle bubble）。</li></ul></li><li>L2 BTB ：<ul><li><strong>容量为 8K 条目，用于处理 L1 BTB 未命中的情况</strong>。</li><li>如果预测在 L1 BTB 中未命中但在 L2 BTB 中命中，则会产生<strong>八周期的延迟</strong>（eight prediction bubbles）。这表明 L2 BTB 的访问速度较慢，但其更大的容量可以覆盖更多分支场景。</li></ul></li></ul><p><strong>3.2 BTB 条目的设计</strong></p><ul><li>存储能力 ：<ul><li>每个 BTB 条目最多可以存储<strong>两</strong>个分支，前提是这两个分支满足<strong>特定的配对条件</strong>。<ul><li>一个条件分支后跟随另一个分支，且这两个分支的最后一个字节位于同一个 64 字节对齐的缓存行中。</li><li>一个直接分支（不包括调用指令 CALL）后跟随一个在 64 字节对齐缓存行内结束的分支，该缓存行包含第一个分支的目标。</li></ul></li><li>如果分支目标地址与其获取地址在大量位上存在差异，则可能限制 BTB 条目仅能存储一个分支。这反映了硬件资源的限制。</li></ul></li></ul><p><strong>3.3 分支预测的性能影响</strong></p><ul><li><strong>预测气泡（Prediction Bubbles）</strong> ：<ul><li><strong>预测气泡是指由于分支预测失败或延迟导致的流水线停滞</strong>。不同的分支类型和 BTB 级别会导致不同的预测气泡：<ul><li>L1 BTB 提供零延迟预测（对于大多数分支类型）。</li><li>返回指令和多目标间接分支会产生两周期的延迟。</li><li>L2 BTB 命中会产生八周期的延迟。</li></ul></li></ul></li></ul><p><strong>3.4 优化建议</strong> ：</p><ul><li>尽可能减少代码中的分支数量，尤其是那些难以预测的分支（如多目标间接分支）。</li><li>在某些情况下，可以使用条件移动指令（conditional mov instructions）替代分支指令，从而避免分支预测的开销。</li><li>保持关键分支的工作集尽可能小，可以提高 BTB 的命中率，从而减少预测延迟。</li><li>BTB 的容量有限，因此如果分支过多或分布过于分散，可能会导致频繁的未命中，进而影响性能。</li></ul><hr><h4 id="2-8-1-3-Return-Address-Stack"><a href="#2-8-1-3-Return-Address-Stack" class="headerlink" title="2.8.1.3 Return Address Stack"></a><strong>2.8.1.3 Return Address Stack</strong></h4><p>处理器为每个线程实现了一个包含 52 个条目的返回地址栈（Return Address Stack, RAS），用于预测近调用（near call）的返回地址。在获取调用指令时，下一条指令的地址会被压入返回地址栈中。通常情况下，返回地址可以通过从返回地址栈顶部弹出的地址正确预测。然而，在推测执行过程中有时会出现错误预测，这可能导致返回地址栈被错误地压入或弹出。处理器实现了机制，能够在大多数情况下正确恢复返回地址栈。如果返回地址栈无法恢复，则会被置为无效并重置到一个一致的状态。<strong>以下部分将讨论用于优化子程序调用和返回的常见编码实践</strong>。</p><p><strong>1. CALL 0h</strong></p><p>当 CALL 指令与零偏移量（displacement of zero）一起使用时，它会被识别并特殊处理；尽管 CALL 0h 的语义是调用当前指令地址本身（即跳转到下一条指令），但处理器不会将返回地址压入返回地址栈（RAS）。这种设计确保了即使没有对应的 RET 指令，返回地址栈（RAS）仍然保持一致。作为 CALL 0h 的替代方法，64 位软件可以使用带有 RIP 相对寻址的 LEA 指令将 RIP 加载到寄存器中，如下例所示：</p><blockquote><p>lea rax, [rip + 0]</p></blockquote><p>不管是硬件特殊处理还是使用LEA替换，目的都是防止RAS产生返回地址栈，从而导致性能的损失和RAS的混乱。</p><p><strong>2. REP RET</strong></p><p>对于之前的处理器家族（例如 Family 10h 和 12h），曾推荐使用三字节的返回立即数（return-immediate，RET 指令）作为一种优化手段，以提高性能，相较于单字节的近返回（near-return）。然而，对于 AMD Zen5 微架构，这种推荐已不再适用。现在可以使用单字节的近返回指令（操作码 C3h），而不会对性能产生负面影响。这将使得代码大小比三字节方法更小。(这一条是硬件上改进，对软件优化没有参考价值)。</p><p><strong>3. Function Inlining</strong></p><p>对于 L1 BTB（一级分支目标缓冲区）预测，返回指令（RET）会导致两个周期的气泡延迟（two-cycle bubble）。因此，在热点循环中调用的函数如果调用者较少或函数本身较小，则应尽量进行内联（inlining），以提高性能。</p><hr><h4 id="2-8-1-4-Indirect-Target-Predictor"><a href="#2-8-1-4-Indirect-Target-Predictor" class="headerlink" title="2.8.1.4 Indirect Target Predictor"></a><strong>2.8.1.4 Indirect Target Predictor</strong></h4><p>处理器实现了一个包含 3072 个条目的<strong>间接目标数组</strong>（Indirect Target Array，记录历史目标地址信息） ，<strong>用于预测某些非返回（non-RET）间接分支的目标地址</strong>。如果某个分支曾经有过多个不同的目标地址，间接目标预测器会根据全局历史（global history）在这些目标地址中进行选择。而对于始终具有相同目标地址的间接分支，则使用该分支在 BTB（分支目标缓冲区）条目中存储的静态目标地址进行预测。因此，<strong>代码应尽量减少每个间接分支的不同目标数量以提高预测命中率</strong>。</p><ul><li><strong>优化建议</strong><ul><li><strong>减少间接分支的数量</strong> ：尽量避免频繁使用函数指针、虚函数或跳转表等可能导致间接分支的编程模式。</li><li><strong>合并目标地址</strong> ：如果可能，将多个相似的分支目标合并为一个目标地址，以减少目标地址的变化。</li><li><strong>优化热路径（hot path）</strong> ：对于热点代码路径中的间接分支，确保目标地址尽可能固定。</li><li><strong>使用条件分支或其他方法替代跳转表</strong>，以减少间接分支的复杂性。</li></ul></li></ul><hr><h4 id="2-8-1-5-Advanced-Conditional-Branch-Direction-Predictor"><a href="#2-8-1-5-Advanced-Conditional-Branch-Direction-Predictor" class="headerlink" title="2.8.1.5 Advanced Conditional Branch Direction Predictor"></a><strong>2.8.1.5 Advanced Conditional Branch <em>Direction</em> Predictor</strong></h4><p>条件分支预测器用于预测**条件近分支（conditional near branches）**的方向。<strong>只有那些先前被发现具有“跳转”（taken）和“不跳转”（not-taken）行为的分支才会使用条件分支预测器</strong>。条件分支预测器采用全局历史机制（<strong>global history scheme</strong>），记录之前执行过的分支行为。对于从未跳转的分支，全局历史不会更新。因此，倾向于“不跳转”的动态分支更受青睐。依赖于深层历史或与全局历史相关性较低的分支行为更容易被错误预测。</p><p><strong>尚未被发现为“跳转”的条件分支不会在 BTB（分支目标缓冲区）中标记</strong>。这些分支会被隐式预测为“不跳转”。一旦某个条件分支首次被发现为“跳转”，它将被标记为“始终跳转”（always-taken）。如果后续发现该分支出现“不跳转”行为，则其状态会从“始终跳转”转变为“动态”（dynamic），此时它将有资格使用动态条件分支预测器进行预测。</p><ul><li><p>隐式预测与显式预测</p><ul><li><strong>隐式预测（Implicit Prediction）</strong> ：<ul><li>对于尚未被发现为“跳转”的分支，处理器会默认预测其为“不跳转”, 不会在BTB中标记该分支。</li><li>这种隐式预测减少了对硬件资源的需求，同时适用于大多数情况下偏向“不跳转”的分支。</li></ul></li><li><strong>显式预测（Explicit Prediction）</strong> ：<ul><li>一旦某个分支首次被发现为“跳转”，它将被标记为“始终跳转”。</li><li>如果随后发现该分支也有“不跳转”的行为，则其状态会转变为“动态”，并使用条件分支预测器进行更复杂的预测。</li></ul></li></ul></li><li><p><strong>优化建议</strong> ：</p><ul><li><strong>减少分支数量</strong> ：尽量避免不必要的条件分支，尤其是在热点代码路径中。</li><li><strong>倾向于“不跳转”的分支（即偏置分支）更高效</strong>，因为它们不会增加全局历史的复杂性，也不会占用条件分支预测器的资源。以利用隐式预测的优势。</li><li><strong>合并分支</strong> ：将多个小分支合并为一个较大的分支，以减少分支预测器的负担。</li><li><strong>避免长距离相关性</strong> ：如果分支行为依赖于较早的历史，考虑重新组织代码以减少这种依赖。</li></ul></li><li><p>编译器支持 ：</p><ul><li>现代编译器通常会自动优化分支逻辑，例如通过重新排列代码来提高分支预测的准确性。</li><li>开发者可以通过编译器标志（如 -O2 或 -O3）启用高级优化。</li></ul></li><li><p><strong>性能分析工具识别频繁被错误预测的分支</strong> ：</p><blockquote><p>perf record -e branch-misses .&#x2F;your_program  # 记录程序运行时分支预测错误次数<br>perf report # 查看结果<br>perf annotate #查看导致分支预测错误的汇编代码<br>perf top -e branch-misses #实时查看系统的性能瓶颈<br># 导出报告<br>perf record -o perf.data .&#x2F;your_program<br>perf report -i perf.data</p></blockquote></li></ul><hr><h4 id="2-8-1-6-Fetch-Window-Tracking-Structure"><a href="#2-8-1-6-Fetch-Window-Tracking-Structure" class="headerlink" title="2.8.1.6 Fetch Window Tracking Structure"></a><strong>2.8.1.6 Fetch Window Tracking Structure</strong></h4><p>*<em>指令获取窗口（Fetch Windows）*<em>通过一个 128 entry的 FIFO 队列（在 SMT 模式下为 64 项）<strong>从指令获取阶段跟踪到指令退役阶段</strong>。每个队列条目可以存储最多一个完整 64 字节缓存行的分支预测信息。如果单个 BTB 条目不足以支持对整个缓存行末尾的预测，则获取窗口跟踪结构会为该特定缓存行使用额外的条目。如果在某个缓存行中未检测到分支，则获取窗口跟踪结构将仅使用一个条目来跟踪整个缓存行。如果获取窗口跟踪结构被填满，指令获取将暂停，直到指令从退役控制单元退役，或者分支错误预测清除了部分条目。无论是</em>错误预测*的分支还是</em>退役*的分支，都会使用此结构中的信息按需更新预测结构。</p><ul><li>优化建议 ：<ul><li>减少分支密集型代码的复杂性，防止获取窗口跟踪结构被快速填满。</li><li>在 SMT 模式下，获取窗口跟踪结构的条目数减半，因此更容易被填满。应尽量减少线程间的分支冲突。优化线程间的资源分配。</li><li>合并分支逻辑，减少获取窗口跟踪结构的条目占用。</li></ul></li></ul><hr><p><a id="282"></a></p><h3 id="2-8-2-跨边界分支（Boundary-Crossing-Branches）"><a href="#2-8-2-跨边界分支（Boundary-Crossing-Branches）" class="headerlink" title="2.8.2 跨边界分支（Boundary Crossing Branches）"></a><strong>2.8.2 跨边界分支（Boundary Crossing Branches）</strong></h3><p>目标地址跨越 16 MB 对齐边界的分支无法与其他分支共享 BTB（分支目标缓冲区）条目。那么频繁出现这种情况会降低 BTB 的有效容量和带宽。</p><p><strong>16 MB 对齐边界</strong> ：</p><ul><li>处理器中的某些硬件结构（如 BTB）对分支目标地址的存储有特定限制。</li><li>如果分支的目标地址跨越了 16 MB 对齐边界（即目标地址的高阶位发生变化），则该分支被视为“跨边界分支”。</li></ul><p><strong>实际场景中的问题</strong> ：</p><ul><li><strong>大型代码库</strong> ：<br>在大型程序或动态链接库中，函数地址可能分布在不同的 16 MB 区域，导致跨边界分支的发生频率增加。</li><li><strong>间接分支</strong> ：<br>间接分支（如函数指针调用、虚函数调用）的目标地址通常是动态确定的，更容易跨越 16 MB 边界。</li></ul><p><strong>优化建议</strong> :</p><ul><li><strong>减少跨边界分支的发生</strong> ：<ul><li><strong>优化代码布局</strong> ：<ul><li>将热点函数和相关代码尽量放置在相同的 16 MB 区域内，避免目标地址跨越边界。</li><li>使用链接器脚本或编译器选项控制函数和代码段的布局。</li></ul></li><li><strong>合并间接分支</strong> ：<ul><li>减少间接分支的数量，或者将目标地址集中在较小的地址范围内。</li></ul></li></ul></li><li>硬件支持 ：<ul><li>现代处理器可能会通过更复杂的 BTB 设计（如多级 BTB 或更大的条目容量）来缓解跨边界分支的影响。</li></ul></li></ul><hr><p><a id="283"></a></p><h3 id="2-8-3-循环对齐（Loop-Alignment）"><a href="#2-8-3-循环对齐（Loop-Alignment）" class="headerlink" title="2.8.3 循环对齐（Loop Alignment）"></a><strong>2.8.3 循环对齐（Loop Alignment）</strong></h3><p>对于处理器来说，循环对齐通常不是一个显著的问题。然而，对于<strong>热点循环（hot loops）</strong>，了解一些权衡可以帮助进一步优化性能。</p><p><strong>1. 64 字节缓存行对齐</strong></p><ul><li>处理器每周期可以读取一个对齐的 64 字节获取块（fetch block）。因此，建议：<ul><li>将循环的起点对齐到 64 字节缓存行的起始位置。</li><li>或者将循环的终点对齐到 64 字节缓存行的末尾。</li></ul></li><li>性能差异 ：<ul><li>将循环的终点对齐到缓存行的末尾稍微更优，因为这可以减少跨缓存行提取指令的可能性。</li></ul></li></ul><p><strong>2. 分支放置与 BTB 条目的使用</strong></p><ul><li>分支预测器的能力 ：<ul><li>分支预测器可以通过单个 BTB 条目处理从缓存行入口点开始的前两个分支。</li><li>为了获得最佳性能，应尽量确保在同一缓存行中，分支目标之后的预测分支数量不超过两个。</li></ul></li><li>BTB 条目的限制 ：<ul><li><strong>每个 BTB 条目最多可以存储两个分支的信息</strong>。</li><li>如果需要预测第三个分支，则需要额外的 BTB 条目，并增加预测延迟。</li></ul></li></ul><p><strong>3. 分支密度与执行频率</strong><br>这里的优化不应与“每个缓存行的分支数量”混淆。</p><ul><li>即使每个缓存行包含三到四个分支，仍然是最优的，前提是：<ul><li>第二个分支是无条件分支（unconditional branch）。</li><li>或者第一个或第二个分支被频繁跳转，导致第三和第四个分支很少被执行。</li></ul></li></ul><hr><h4 id="2-8-3-1-编码填充以实现循环对齐"><a href="#2-8-3-1-编码填充以实现循环对齐" class="headerlink" title="2.8.3.1 编码填充以实现循环对齐"></a><strong>2.8.3.1 编码填充以实现循环对齐</strong></h4><p>对齐循环通常是通过在循环前添加 NOP 指令来实现的。<br><strong>1. NOP 指令的成本</strong><br>虽然 NOP 指令不消耗执行单元资源，但它们仍然需要从解码器（Decoder）转发，并由退役控制单元（Retire Control Unit, RCU）跟踪。因此，建议使用<strong>较少且较长</strong>的 NOP 指令 ，而不是许多短 NOP 指令。<br><strong>2. NOP 指令的编码</strong><br>NOP 指令的编码支持长度为 1 到 15 的编码方式。对于长度超过 8 的 NOP 指令，可以通过在指令开头添加一个或多个操作数大小覆盖前缀（66h）来实现。</p><hr><h2 id="2-9-取指与译码"><a href="#2-9-取指与译码" class="headerlink" title="2.9 取指与译码"></a>2.9 取指与译码</h2><p>处理器从指令缓存中<strong>以 32 字节对齐的块（Fetch block）形式</strong>获取指令，每个块大小为 32 字节。每周期最多可以独立获取两个这样的块，以供给解码单元的<strong>两条解码流水线（decode pipes）</strong>。来自不同基本块的指令字节可以被获取并乱序发送到两条解码流水线，从而实现指令提前预取（instruction fetch-ahead），这可以隐藏因 TLB 未命中、指令缓存（I-Cache）未命中和指令解码带来的延迟。</p><p><strong>1. IBQ 结构</strong></p><ul><li>每条解码流水线都有一个称为 IBQ（Instruction Byte Queue）的 20 条目结构，它充当<strong>指令获取&#x2F;分支预测单元与解码单元之间的解耦</strong>队列。<strong>IBQ 条目保存了 16 字节对齐的指令字节流的获取窗口（fetch windows）</strong>。</li></ul><p><strong>2. 解码流水线的工作方式</strong></p><ul><li>每条解码流水线扫描两个 IBQ 条目，并每周期最多输出 4 条指令。</li><li>在单线程模式下，最大吞吐量为每周期 4 条指令。</li><li>在 SMT（同步多线程）模式下，解码流水线 0 专用于线程 0，解码流水线 1 专用于线程 1，支持每周期最多 8 条指令的最大吞吐量。</li></ul><p><strong>3. 指令解码窗口</strong></p><ul><li>指令解码窗口大小为 32 字节，并且对齐到 16 字节边界。</li><li>优化建议 ：将分支目标地址对齐到 16 字节边界可以获得最大的指令解码吞吐量。</li></ul><p><strong>4. 长指令的限制</strong></p><ul><li>在每组四个解码槽位中，只有第一个解码槽位能够解码长度超过 10 字节的指令。</li><li>优化建议 ：避免在一组四个连续指令中出现多条长度超过 10 字节的指令。</li></ul><hr><h3 id="2-9-1-Op-Cache"><a href="#2-9-1-Op-Cache" class="headerlink" title="2.9.1 Op Cache"></a><strong>2.9.1 Op Cache</strong></h3><p>操作缓存（Op Cache，简称 OC）是已解码指令的缓存。当指令从 Op Cache 中获取时，传统的指令获取和解码过程会被绕过。这带来了以下性能优势：</p><ul><li><strong>降低流水线延迟</strong> ：<br>Op Cache 的流水线比传统的获取和解码流水线更短。</li><li><strong>提高带宽</strong> ：<br>Op Cache 的最大吞吐量为每周期 12 条指令，而传统获取和解码流水线的最大吞吐量为每线程每周期 4 条指令。</li><li><strong>节省功耗</strong> ：<br>由于无需重新解码指令，Op Cache 的使用降低了功耗。</li></ul><p><strong>1. Op Cache 的组织结构</strong></p><ul><li>缓存设计 ：<ul><li>Op Cache 是一个具有 64 组（sets）和 16 路（ways）的关联缓存。在每个组-路交叉点上，有一个条目，每个条目最多可以存储 6 条指令或融合指令（fused instructions）。</li><li>与 Zen3 和 Zen4 的区别 ：<br>Zen3 和 Zen4 的 Op Cache 存储的是宏操作（macro-ops），而新的设计直接存储指令或融合指令，从而提高了有效存储密度。</li></ul></li><li>容量限制 ：<br>Op Cache 的最大容量为 6K 条指令或融合指令。实际容量可能因效率考虑而略低。</li><li>优化建议 ：<br>当只有一个线程运行在物理核心上时，避免热点代码区域接近此大小。当两个线程共享一个物理核心时，避免热点代码区域接近 3K 条指令的大小。</li><li>物理标记（Physically Tagged） ：<br>Op Cache 使用物理地址标记，允许两个线程在获取共享代码时共享 Op Cache 条目。</li></ul><p><strong>2. Op Cache 的填充机制</strong></p><ul><li><strong>未命中处理</strong> ：<ul><li>当指令获取在 Op Cache 中未命中时，指令会从指令缓存（IC）中读取并解码，然后被构建到 Op Cache 中。</li><li>多条指令会被一起构建到一个 Op Cache 条目中，最多可以将 6 条连续指令或融合指令缓存到一个条目中。</li></ul></li></ul><p><strong>3. Op Cache 条目的限制</strong></p><p>Op Cache 条目有以下限制：</p><ul><li><strong>指令数量限制</strong> ：<ul><li>每个条目最多包含 6 条指令或融合指令。</li></ul></li><li><strong>立即数或位移操作数存储槽位限制</strong> ：<ul><li>每个条目最多支持 6 个 32 位立即数或位移操作数存储槽位。这些槽位可以被任何指令使用。</li><li>如果所有 6 个槽位已被占用，则后续包含立即数或位移操作数的指令无法被加入该条目。</li><li>存储规则 ：<ul><li>64 位操作数占用 2 个槽位。</li><li>8&#x2F;16&#x2F;32 位操作数各占用 1 个槽位。</li></ul></li></ul></li><li><strong>AVX-512 指令限制</strong> ：<br>每个条目最多支持 6 条带有 EVEX 前缀的 AVX-512 指令。</li><li><strong>微码指令限制</strong> ：<ul><li>当存在微码指令时，传统的宏操作限制不再适用。</li><li>微码指令和非微码指令的总数限制为 4 条。</li></ul></li><li>缓存行限制 ：<ul><li>一个 Op Cache 条目只能包含来自最多两个相邻 64 字节缓存行的指令。</li></ul></li></ul><p><strong>4. Op Cache 的模式切换</strong></p><ul><li>模式定义 ：<br>处理器可以在两种模式之间切换：**指令缓存模式（IC 模式）**和 <strong>Op Cache 模式（OC 模式）</strong>。</li><li>切换条件 ：<ul><li><strong>从指令缓存模式切换到 Op Cache 模式只能在分支跳转（taken branches）时发生</strong>。</li><li><strong>处理器会保持在 Op Cache 模式，直到检测到 Op Cache 未命中</strong>。</li></ul></li><li>性能影响 ：<br>频繁的模式切换可能会对性能产生负面影响。</li><li>优化建议 ：<br>将热点代码区域的大小限制在 Op Cache 的容量范围内，以尽量减少模式切换。在展开循环时，需特别注意这一点。</li></ul><p><strong>5. 内存模型要求</strong></p><ul><li><strong>平坦内存模型</strong> ：<ul><li><strong>使用 Op Cache 需要采用平坦内存模型（Flat Memory Model）</strong>。</li><li>要求 ：<ul><li>64 位模式</li><li>或32 位模式，且 CS.Base &#x3D; 0h 且 CS.Limit &#x3D; FFFFFFFFh。</li></ul></li></ul></li></ul><hr><p><a id="292"></a></p><h3 id="2-9-2-依赖项消除的惯用方法Idioms-for-Dependency-removal"><a href="#2-9-2-依赖项消除的惯用方法Idioms-for-Dependency-removal" class="headerlink" title="2.9.2 依赖项消除的惯用方法Idioms for Dependency removal"></a><strong>2.9.2 依赖项消除的惯用方法Idioms for Dependency removal</strong></h3><p><strong>核心机制 ：</strong><br>零化惯用法和置一惯用法通过特殊的指令模式清空或初始化寄存器(处理器会识别这些指令并特殊处理)，同时打破输入依赖关系。这些操作通常被处理器优化为 0 周期操作，显著提升性能。</p><p><strong>零化惯用法</strong><br>一些指令可以用于清空寄存器并打破依赖关系，而无需加载立即数零。这些方法被称为零化惯用法（Zeroing Idioms）。</p><ul><li><p><strong>GPR 零化惯用法</strong></p><blockquote><p>XOR reg, reg (clears reg and the flags, 0-cycle operation)<br>SUB reg, reg (clears reg and the flags, 0-cycle operation)<br>CMP reg, reg (sets Z flag and clears other flags, 0-cycle operation)<br>SBB reg, reg (copies the zero extended value of the carry flag into reg without a dependency on the previous value of reg, 1-cycle operation) …</p></blockquote></li><li><p><strong>SIMD 零化惯用法</strong> (all clear destination register as a 0-cycle operation):</p><blockquote><p>VXORP(S&#x2F;D) zmm&#x2F;ymm&#x2F;xmm,zmm&#x2F;ymm&#x2F;xmm,zmm&#x2F;ymm,xmm …</p></blockquote></li></ul><p><strong>置一惯用法</strong><br>一些指令可以将寄存器设置为全 1，并打破输入依赖关系。这些方法被称为置一惯用法（Ones Idioms）。</p><blockquote><p>PCMPEQ(B&#x2F;W&#x2F;D&#x2F;Q) xmm, xmm …</p></blockquote><p><strong>Q: 为什么使用 XOR 而不是 MOV？</strong><br>使用 MOV reg, 0 需要加载立即数，可能会增加代码大小和解码开销。<br>XOR reg, reg 更短（仅 2 字节），并且被处理器优化为 0 周期操作。</p><p><strong>优化建议 ：</strong></p><ul><li>在代码中优先使用零化惯用法（如 XOR reg, reg 或 VXORPS）来清空寄存器。</li><li>对于 SIMD 操作，避免显式加载立即数，而是使用零化惯用法。</li><li>在需要初始化寄存器为全 1 时，使用置一惯用法（如 PCMPEQD）。</li></ul><hr><p><a id="293"></a></p><h3 id="2-9-3-分支融合-Branch-Fusion"><a href="#2-9-3-分支融合-Branch-Fusion" class="headerlink" title="2.9.3 分支融合 Branch Fusion"></a><strong>2.9.3 分支融合 Branch Fusion</strong></h3><p>处理器的解码单元能够将条件分支指令与某些标志位写入指令融合为一条融合指令 。融合指令仅占用 Op Cache 条目中的一个槽位，并<strong>减少了一条宏操作（macro-op）在处理器流水线中的流动</strong>，从而提高了分发（dispatch）、发射（issue）和退役（retire）的<strong>带宽</strong>。</p><p><strong>分支融合的条件</strong><br>为了实现分支融合，需要满足以下条件：</p><ul><li><strong>顺序要求</strong> ：<br>条件分支指令必须紧跟在标志位写入指令之后。</li><li><strong>支持的标志位写入指令</strong> ：<br>以下指令支持与其对应的条件分支指令进行融合：<blockquote><p>CMP<br>  TEST<br>  SUB<br>  ADD<br>  INC<br>  DEC<br>  OR<br>  AND<br>  XOR</p></blockquote></li><li><strong>指令形式</strong> ：<br>支持的指令形式包括：<ul><li>寄存器-寄存器（reg&#x2F;reg）</li><li>寄存器-立即数（reg&#x2F;imm）</li><li>寄存器-内存（reg&#x2F;mem）</li></ul></li><li><strong>立即数和位移限制</strong> ：<br>当指令包含立即数和位移时，需满足以下条件之一：<ul><li>4 字节位移和 2 字节立即数。</li><li>2 字节位移和 4 字节立即数。</li></ul></li></ul><p><strong>优化建议 ：</strong></p><ul><li>在编写代码时，尽量将条件分支指令紧接在标志位写入指令之后，以便触发分支融合。</li><li>使用支持融合的指令形式（如 CMP、TEST 等），并注意立即数和位移的大小限制。</li></ul><hr><h3 id="2-9-4-MOV-ALU-Fusion"><a href="#2-9-4-MOV-ALU-Fusion" class="headerlink" title="2.9.4 MOV + ALU Fusion"></a><strong>2.9.4 MOV + ALU Fusion</strong></h3><p>MOV + ALU Fusion 是一种优化技术，它允许将 MOV 指令与 ALU 指令进行融合，以减少指令数量和延迟。这种优化技术在某些情况下可以提高程序性能。</p><hr><h3 id="2-9-5-Zero-Cycle-Move"><a href="#2-9-5-Zero-Cycle-Move" class="headerlink" title="2.9.5 Zero Cycle Move"></a><strong>2.9.5 Zero Cycle Move</strong></h3><p>处理器可以以零周期延迟执行某些 register-to-register mov操作，从而减少指令数量和延迟。</p><hr><p><a id="296"></a></p><h3 id="2-9-6-栈指针跟踪以消除依赖（Stack-Pointer-Tracking-for-Dependency-Removal）"><a href="#2-9-6-栈指针跟踪以消除依赖（Stack-Pointer-Tracking-for-Dependency-Removal）" class="headerlink" title="2.9.6 栈指针跟踪以消除依赖（Stack Pointer Tracking for Dependency Removal）"></a><strong>2.9.6 栈指针跟踪以消除依赖（Stack Pointer Tracking for Dependency Removal）</strong></h3><p>整数重命名单元（Integer Rename Unit）提供了一种机制，用于优化某些对栈指针（stack pointer）的隐式操作以及对栈指针的引用。这里的栈指针指的是 rSP 寄存器（即 64 位模式下的栈指针寄存器）。<u>当栈指针被跟踪时，支持的指令不再依赖于先前对栈指针进行隐式更新的指令。这消除了这些指令之间的执行依赖关系，从而提高了性能</u>。</p><p><strong>1. 支持栈指针跟踪的指令</strong><br>以下隐式更新栈指针的指令支持栈指针跟踪：</p><ul><li>PUSH reg&#x2F;mem&#x2F;imm （不包括 PUSH rSP）</li><li>POP reg&#x2F;mem （不包括 POP rSP）</li><li>CALL near rel （近相对调用）</li><li>CALL near abs reg （近绝对寄存器调用）</li><li>RET near （近返回）</li><li>RET near imm （带立即数的近返回）</li></ul><p><strong>2. 可利用栈指针跟踪的指令</strong><br>以下引用栈指针的指令可以利用栈指针跟踪功能：</p><ul><li><p><strong>内存引用</strong> ：<br>使用 rSP 作为基址或索引寄存器的加载和存储操作。</p><blockquote><p>MOV EAX, [RSP+8]  ; 加载指令<br>  MOV [RSP+8], EAX  ; 存储指令</p></blockquote></li><li><p><strong>MOV 指令</strong> ：<br>将栈指针的值移动到其他寄存器。</p><blockquote><p>MOV RAX, RSP</p></blockquote></li><li><p><strong>ADD&#x2F;SUB 指令</strong> ：</p><ul><li>对栈指针执行加法或减法操作，并且立即数为 12 位（对于 32 位指令，高 19 位是符号扩展）。</li><li>支持的指令包括：<ul><li>ADD (81 &#x2F;0, 83 &#x2F;0) ：将立即数加到 RSP。</li><li>SUB (81 &#x2F;5, 83 &#x2F;5) ：从 RSP 中减去立即数。<blockquote><p>ADD RSP, 16       ; 增加栈指针<br>  SUB RSP, 8        ; 减少栈指针</p></blockquote></li></ul></li></ul></li><li><p><strong>LEA 指令</strong> ：</p><blockquote><p>LEA RAX, [RSP+8]  ; 计算地址</p></blockquote></li></ul><p><strong>3. 优化建议 ：</strong></p><ul><li>在编写代码时，尽量使用支持栈指针跟踪的指令。</li><li>避免使用可能导致栈指针跟踪重置的操作（如 PUSH rSP 或复杂寻址模式）。</li><li>注意 ADD 和 SUB 的立即数大小限制，确保符合 12 位的要求。</li></ul><hr><p><a id="297"></a></p><h3 id="2-9-7-指令分发-Dispatch"><a href="#2-9-7-指令分发-Dispatch" class="headerlink" title="2.9.7 指令分发 Dispatch"></a><strong>2.9.7 指令分发 Dispatch</strong></h3><p><u>分发带宽是指处理器每周期能够将多少条宏操作从解码阶段传递到执行引擎的能力</u>。分发带宽直接影响处理器的**指令级并行性（ILP）**和整体吞吐量。如果分发带宽不足，可能导致流水线停滞，降低性能。</p><p><u>处理器每周期最多可以将 8 条宏操作（macro-ops） 分发到执行引擎中</u>。然而，对于某些指令组合，由于内部限制，处理器可能无法达到 8 条宏操作的分发上限。为了最大化分发带宽，软件可以通过在任意连续的 8 条宏操作窗口中平衡操作类型来优化分发效率。如果一个窗口中的操作类型混合得当，并且这些操作可以在执行引擎中并发执行，那么它们也可能被同时分发。</p><p><strong>1. 分发优化规则</strong><br>为了优化分发带宽，需遵循以下规则：</p><ul><li><strong>最多 2 条已跳转分支（Taken branches）</strong> ：<br>在一个分发组中，最多允许 2 条已被预测为跳转的分支指令。这是因为分支指令需要额外的资源来处理控制流转移。</li><li><strong>最多 8 个立即数或位移（Immediates or displacements）</strong> ：<br>在一个分发组中，最多允许 8 个立即数或位移操作。立即数和位移操作会占用解码器和分发单元的资源，因此需要限制其数量。</li><li><strong>第 8 条操作不能是加载或存储（Load&#x2F;Store）</strong> ：<br>在一个分发组中，第 8 条操作不能是内存加载（Load）或存储（Store）指令。这是因为加载和存储操作通常涉及复杂的地址计算和内存访问，可能会限制分发效率。</li></ul><p><strong>2. 优化建议 ：</strong></p><ul><li>在任意连续的 8 条宏操作窗口中，<strong>尽量混合不同类型的操作，避免在一个窗口中集中过多相似类型的操作</strong>（如多个分支指令或多个加载操作），以充分利用执行引擎的并发能力。应注意满足：<ul><li>最多 2 条已跳转分支。</li><li>最多 8 个立即数或位移。</li><li>第 8 条操作不能是加载或存储。</li></ul></li><li>汇编&#x2F;编译器优化：<ul><li><strong>代码布局</strong> ：<br>注意操作类型的分布，避免连续多条加载或存储操作，而是将其与其他类型的操作交替排列。</li><li><strong>指令融合</strong> ：<br>利用处理器的指令融合功能（如分支融合），减少宏操作的数量，从而提高分发效率。</li><li><strong>循环展开</strong> ：<br>在循环展开时，确保每个展开的迭代块中包含多种类型的操作，以平衡分发窗口中的操作类型。</li></ul></li></ul><hr><p><a id="298"></a></p><h3 id="2-9-8-使用-PAUSE-指令优化自旋循环（Span-Loop）"><a href="#2-9-8-使用-PAUSE-指令优化自旋循环（Span-Loop）" class="headerlink" title="2.9.8 使用 PAUSE 指令优化自旋循环（Span Loop）"></a><strong>2.9.8 使用 PAUSE 指令优化自旋循环（Span Loop）</strong></h3><p>软件可以使用 <code>\color{red}{PAUSE}</code> 指令来减少在自旋循环中等待获取竞争锁时的功耗和其他资源占用。<code>\color{red}{PAUSE}</code> 指令的具体效果取决于处理器的实现，但在 AMD Zen5 微架构中，<strong>PAUSE 指令会导致执行线程暂停宏操作（macro-ops）的分发</strong>，持续大约 64 个周期。</p><p><strong>自旋循环 Span Loop</strong></p><ul><li>自旋循环（Spin Loop）是一种忙等待（Busy-Waiting）机制，通常用于多线程编程中，当一个线程未能获取竞争锁（Contended Lock）时，它会不断检查锁的状态，直到锁被释放。</li><li>在没有优化的情况下，自旋循环会持续占用处理器资源（如指令分发带宽、执行单元等），导致高功耗和低效率。此外，在超线程（SMT）环境中，自旋循环可能会对共享资源（如执行单元和缓存）造成压力，影响其他线程的性能。</li></ul><hr><p><a id="299"></a></p><h3 id="2-9-9-其他解码注意事项（Other-Decode-Considerations）"><a href="#2-9-9-其他解码注意事项（Other-Decode-Considerations）" class="headerlink" title="2.9.9 其他解码注意事项（Other Decode Considerations）"></a><strong>2.9.9 其他解码注意事项（Other Decode Considerations）</strong></h3><p>略</p><hr><p><a id="210"></a></p><h2 id="2-10-整数执行单元（Integer-Execution-Unit）"><a href="#2-10-整数执行单元（Integer-Execution-Unit）" class="headerlink" title="2.10 整数执行单元（Integer Execution Unit）"></a>2.10 整数执行单元（Integer Execution Unit）</h2><p><img src="/image-2.png" alt="alt text"></p><h3 id="2-10-1-Schedulers"><a href="#2-10-1-Schedulers" class="headerlink" title="2.10.1 Schedulers"></a><strong>2.10.1 Schedulers</strong></h3><p>调度器每周期最多可以接收（前端dispatch到后端） 8 条宏操作（macro-ops），并跟踪其中包含的微操作（micro-ops）的操作数可用性和依赖关系执行需求。</p><p><strong>调度器吞吐量</strong></p><ul><li>ALU 调度器 ：每周期最多可以发出 6 条微操作。</li><li>AGU 调度器 ：每周期最多可以发出 4 条微操作。</li></ul><p><strong>性能瓶颈</strong></p><ul><li>高负载场景 :<ul><li>在计算密集型任务（如科学计算、加密算法）中，ALU 调度器可能成为瓶颈。</li><li>在内存密集型任务（如数据库查询、图像处理）中，AGU 调度器可能成为瓶颈。</li></ul></li></ul><p><strong>优化建议</strong></p><ul><li><strong>平衡操作类型</strong> ：<br>在编写代码时，尽量混合整数运算和内存操作，以充分利用 ALU 和 AGU 的并发能力。</li><li><strong>减少依赖链</strong> ：<br>避免创建长依赖链（如连续的累加操作），以减少调度器的压力。</li><li><strong>使用宽指令集</strong> ：<br>利用 SIMD 指令（如 AVX）来并行处理多个数据元素，从而提高整体效率。</li></ul><hr><p><a id="2102"></a></p><h3 id="2-10-2-执行单元（Execution-Units）"><a href="#2-10-2-执行单元（Execution-Units）" class="headerlink" title="2.10.2 执行单元（Execution Units）"></a><strong>2.10.2 执行单元（Execution Units）</strong></h3><p>处理器包含 6 个通用整数执行流水线。</p><ul><li>ALU0&#x2F;ALU1&#x2F;ALU2 ：<ul><li>支持通用整数运算。</li><li>额外支持乘法（Multiply）和 CRC 操作。整数乘法单元延迟为3个周期。</li></ul></li><li>ALU3&#x2F;ALU4&#x2F;ALU5 ：<ul><li>支持通用整数运算。</li><li>支持 PDEP&#x2F;PEXT、移位（Shift）、分支（Branch）操作。</li><li>ALU3 额外支持除法（Divide）操作。整数除法单元延迟为8个周期，商需要一个周期。</li></ul></li></ul><p>处理器还包含 4 个地址生成单元（AGUs），用于所有加载（Load）和存储（Store）地址的生成。所有 ALU 流水线都可以<strong>发出(issue)<strong>存储数据操作，每周期最多可以将两个</strong>整数存储操作</strong>写入<strong>存储队列</strong>(store queue)。</p><p><strong>优化建议</strong></p><ul><li>平衡简单和复杂操作的比例，避免在关键路径上集中高延迟操作。</li><li>利用 PDEP&#x2F;PEXT 和 LEA 等高效指令优化代码。</li><li>对于乘法和除法操作，了解其性能特性并采取替代方案（如 SIMD 或近似算法）。</li></ul><hr><p><a id="2103"></a></p><h3 id="2-10-3-退役控制单元（Retire-Control-Unit-RCU）"><a href="#2-10-3-退役控制单元（Retire-Control-Unit-RCU）" class="headerlink" title="2.10.3 退役控制单元（Retire Control Unit, RCU）"></a><strong>2.10.3 退役控制单元（Retire Control Unit, RCU）</strong></h3><p>退役控制单元（RCU）负责跟踪所有未完成操作（包括整数、加载&#x2F;存储和浮点运算）的完成状态，并作为异常处理和恢复的最终仲裁者。该单元<strong>每周期最多可以接收 8 条宏操作（macro-ops）</strong>，并在非 SMT 模式下<strong>跟踪最多 448 条在途宏操作</strong>，或者在 SMT 模式下每个线程最多跟踪 224 条宏操作。</p><p>在某些情况下，一个<strong>退役队列条目</strong>可以跟踪来自相邻指令的两条宏操作，这会增加退役队列的有效容量。</p><p>一条宏操作只有在其对应的所有微操作（micro-ops）完成执行后才有资格被退役单元提交。对于大多数快速路径双宏操作（fastpath double macro-ops），还需要两条宏操作都完成执行后才能提交。</p><p><u>退役单元每周期可以按顺序提交最多 8 个退役队列条目，这些条目可能代表超过 8 条宏操作</u>。</p><p>退役单元还<u>管理整数寄存器的映射和重命名</u>。<u>整数物理寄存器文件（PRF）</u>包含 240 个寄存器，其中每个线程最多有 40 个寄存器映射到架构状态或微架构临时状态。剩余的寄存器可用于乱序重命名。</p><p>整数物理寄存器文件不存储标志位信息。标志位信息保存在一个独立的<u>标志物理寄存器文件</u>中，该文件提供了 192 个可用寄存器，用于<u>对写标志位的指令进行乱序重命名</u>。</p><p><strong>退役队列</strong>的优化</p><ul><li><strong>双宏操作</strong>支持<br><strong>在某些情况下</strong>，一个退役队列条目可以同时跟踪两条相邻指令的宏操作。这种设计增加了退役队列的有效容量，从而减少了因队列满而导致的性能瓶颈。</li><li>提交规则<br>一条宏操作只有在其所有对应的微操作完成执行后才能被提交。对于快速路径双宏操作（如融合指令），要求两条宏操作都完成执行后才能提交。</li><li>提交吞吐量<br>每周期最多可以提交 8 个退役队列条目。这些条目可能代表超过 8 条宏操作。</li></ul><p><strong>优化建议</strong></p><ul><li>退役队列的限制 ：<ul><li>如果程序中存在大量长延迟操作（如除法、内存访问等），可能会导致退役队列被快速填满，从而降低性能。</li><li>优化建议 ：<ul><li><strong>减少长延迟操作的数量，尽量使用低延迟替代方案（如 SIMD 或近似算法）</strong>。</li><li><strong>避免过多的分支预测错误，因为错误预测会导致流水线清空，增加 RCU 的负担</strong>。</li></ul></li></ul></li><li>寄存器分配 ：<ul><li>整数寄存器和标志寄存器的分配是有限的，因此需要合理使用这些资源。</li><li>优化建议 ：<ul><li><strong>避免频繁写入标志位的指令（如 CMP、TEST），以减少标志寄存器的压力</strong>。</li><li>使用寄存器分配优化工具（如编译器选项 -O2 或 -O3）来减少寄存器冲突。</li></ul></li></ul></li></ul><hr><p><a id="211"></a></p><h2 id="2-11-浮点单元-（Floating-Point-Unit）"><a href="#2-11-浮点单元-（Floating-Point-Unit）" class="headerlink" title="2.11 浮点单元 （Floating-Point Unit）"></a>2.11 浮点单元 （Floating-Point Unit）</h2><p><img src="/image-3.png" alt="alt text"></p><p>处理器原生支持以下浮点数据类型：</p><ul><li>基本浮点数据类型 ：<ul><li>32 位单精度（Single Precision）</li><li>64 位双精度（Double Precision）</li><li>80 位扩展精度（Extended Precision）</li></ul></li><li>向量浮点数据类型 ：<ul><li>128 位、256 位和 512 位的整数、单精度、双精度以及 bfloat16 精度的向量浮点数据类型。</li></ul></li></ul><p>浮点加载和存储路径宽度为 512 位 。</p><p><strong>1. 浮点单元的架构</strong></p><ul><li>协处理器模型 ：<ul><li>浮点单元采用协处理器模型处理所有使用 X87、MMX™、XMM、YMM、ZMM 或浮点控制&#x2F;状态寄存器的操作。</li><li>它拥有独立的调度器（Scheduler）、寄存器文件（Register File）和重命名器（Renamer），不与整数单元共享这些资源。</li></ul></li><li>吞吐量与调度能力 ：<ul><li>每周期可以处理 8 条浮点宏操作 的<strong>分发(dispatch)<strong>和 6 条浮点宏操作 的</strong>重命名</strong>。</li><li>当浮点调度器已满或每周期分发超过 6 条浮点宏操作时，溢出的宏操作会被分配到容量为 96 条目的<strong>非调度队列（Non-Scheduling Queue, NSQ）</strong> 中。此举有助于加速加载和存储地址的计算，并支持每周期 8 条宏操作的分发带宽。</li></ul></li><li>浮点调度器容量 ：<ul><li>浮点调度器具有 3（个scheduler） × 38 条目 的宏操作容量。</li><li>每周期可以为每个执行管道<strong>发出(issue) 1 条微操作</strong> 。</li></ul></li><li>退役队列共享 ：<ul><li>浮点单元与整数单元共享<strong>退役队列（Retire Queue）</strong>，其容量在非 SMT 模式下为 448 条宏操作 ，在 SMT 模式下每个线程为 224 条宏操作 。</li></ul></li></ul><p><strong>2. 执行管道与接口</strong></p><ul><li>执行管道 ：<br>浮点单元包含 4 条执行管道（Pipe 0 至 Pipe 3） ，<strong>每条管道每周期可以执行一个操作</strong>。</li><li>加载与存储 ：<ul><li>浮点单元每周期可以从<strong>加载&#x2F;存储单元</strong>接收最多 两条 512 位<strong>加载</strong>操作。</li><li>浮点<strong>存储操作</strong>由两条管道支持，但吞吐量限制为每周期 1 次存储 。</li></ul></li><li>快速移动支持 ：<ul><li>有专用总线用于在<strong>浮点寄存器</strong>和<strong>整数寄存器</strong>之间快速移动数据。</li><li><strong>存储数据和浮点到通用寄存器</strong>的传输由两条专用管道（Pipe 4 和 Pipe 5）支持。</li></ul></li></ul><p><strong>3. 执行管道与源总线的竞争</strong></p><p>管道 0、1、2 和 3 支持需要三个操作数的操作。对于这些管道：</p><ul><li><strong>管道 0 和 2 的第三个操作数会与通常分配给管道 4 的源总线（source bus）发生竞争</strong>。</li><li><strong>管道 1 和 3 的第三个操作数会与通常分配给管道 5 的源总线发生竞争</strong>。</li></ul><p><strong>当发生这种竞争时，仲裁失败的操作会被暂停（stall）</strong>。</p><p>如果第三个操作数的数据或管道 4&#x2F;5 的数据能够从同一周期的结果中<strong>通过旁路（bypass）提供，则不会发生竞争</strong>。由于源数据由上一个周期的结果产生，不经过总线，所以不会发生竞争。</p><p><strong>4. 优化建议</strong></p><ul><li>减少对第三个操作数的需求，尤其是避免在同一周期内发出多个需要第三个操作数的指令。</li><li>利用旁路机制，确保数据能够快速传递，避免竞争。</li><li>在 AVX-512 中，优先使用零掩码代替合并掩码以减少源总线的使用，从而减少竞争。</li></ul><hr><p><a id="2111"></a></p><h3 id="2-11-1-浮点执行资源-Floating-Point-Execution-Resources"><a href="#2-11-1-浮点执行资源-Floating-Point-Execution-Resources" class="headerlink" title="2.11.1 浮点执行资源 Floating Point Execution Resources"></a><strong>2.11.1 浮点执行资源 Floating Point Execution Resources</strong></h3><table border='1'>  <thead align='center'>    <tr>      <td rowspan='2'> Unit </td>      <td colspan='6'> Pipe </td>      <td rowspan='2'> Dowain </td>      <td rowspan='2' align='left'> Ops Supported </td>    </tr>    <tr>      <td> 0 </td>      <td> 1 </td>      <td> 2 </td>      <td> 3 </td>      <td> 4 </td>      <td> 5 </td>    </tr>  </thead>  <tbody align='center'>    <tr>      <td> FMUL </td>      <td> * </td>      <td> * </td>      <td>  </td>      <td>  </td>      <td>  </td>      <td>  </td>      <td> F </td>      <td align='left'> (v)FMUL*, (v)FMA*, Floating Point Compares, Blendv(DQ) </td>    </tr>    <tr>      <td> FADD </td>      <td>  </td>      <td>  </td>      <td> * </td>      <td> * </td>      <td>  </td>      <td>  </td>      <td> F </td>      <td align='left'> (v)FADD* Signature </td>    </tr>    <tr>      <td> FCVT </td>      <td>  </td>      <td>  </td>      <td> * </td>      <td> * </td>      <td>  </td>      <td>  </td>      <td> F </td>      <td align='left'> All convert operations except pack/unpack </td>    </tr>    <tr>      <td> FDIV </td>      <td>  </td>      <td> * </td>      <td>  </td>      <td>  </td>      <td>  </td>      <td>  </td>      <td> F </td>      <td align='left'> All Divide and Square Root except Reciprocal Approximation </td>    </tr>    <tr>    <td> FMISC </td>      <td> * </td>      <td> * </td>      <td> * </td>      <td> * </td>      <td>  </td>      <td>  </td>      <td> F </td>      <td align='left'> Moves and Logical operations on Floating Point Data Types </td>    </tr>    <tr>      <td> STORE </td>      <td>  </td>      <td>  </td>      <td> * </td>      <td> * </td>      <td> * </td>      <td> * </td>      <td> S </td>      <td align='left'> Stores and Move to General Register (EX) Operations </td>    </tr>    <tr>      <td> VADD </td>      <td> * </td>      <td> * </td>      <td> * </td>      <td> * </td>      <td>  </td>      <td>  </td>      <td> I </td>      <td align='left'> Integer Adds, Subtracts, and Compares </td>    </tr>    <tr>      <td> VMUL </td>      <td> * </td>      <td> * </td>      <td>  </td>      <td> * </td>      <td>  </td>      <td>  </td>      <td> I </td>      <td align='left'> Integer Multiplies, SAD </td>    </tr>    <tr>      <td> VSHUF </td>      <td>  </td>      <td>  </td>      <td> * </td>      <td> * </td>      <td>  </td>      <td>  </td>      <td> I </td>      <td align='left'> Data Shuffles, Packs, Unpacks, Permute, Blendvb </td>    </tr>    <tr>      <td> VSHIFT </td>      <td>  </td>      <td>  </td>      <td> * </td>      <td> * </td>      <td>  </td>      <td>  </td>      <td> I </td>      <td align='left'> Bit Shift Left/Right operations </td>    </tr>    <tr>      <td> VMISC </td>      <td> * </td>      <td> * </td>      <td> * </td>      <td> * </td>      <td>  </td>      <td>  </td>      <td> I </td>      <td align='left'> Moves and Logical operations on Packed Integer Data Types </td>    </tr>    <tr>      <td> AES </td>      <td> * </td>      <td> * </td>      <td>  </td>      <td>  </td>      <td>  </td>      <td>  </td>      <td> I </td>      <td align='left'> *AES* </td>    </tr>    <tr>      <td> CLM </td>      <td> * </td>      <td> * </td>      <td>  </td>      <td>  </td>      <td>  </td>      <td>  </td>      <td>  </td>      <td align='left'> *CLM* </td>    </tr>  </tbody></table><hr><p><a id="2112"></a></p><h3 id="2-11-2-代码优化建议（Code-Recommendations）"><a href="#2-11-2-代码优化建议（Code-Recommendations）" class="headerlink" title="2.11.2 代码优化建议（Code Recommendations）"></a><strong>2.11.2 代码优化建议（Code Recommendations）</strong></h3><p><strong>1. 充分利用 SIMD 指令集</strong></p><ul><li>使用 SSE、AVX 等 SIMD 指令集的向量化特性，以显著提高吞吐量。</li><li>AMD Zen5 支持 SSE、SSE2、SSE3、SSSE3、SSE4.1、SSE4.2、SSE4a、F16C、FMA、AVX、AVX2 和 AVX-512 。</li><li>优先使用 512 位（ZMM 寄存器）操作 ，因为 Zen5 的数据路径宽度为 512 位，全宽操作能最大化性能并降低功耗 。</li></ul><p><strong>2. 使用全宽度加载和存储指令</strong></p><p>使用全宽度加载&#x2F;存储指令（例如 vmovapd），而非分块操作（如 movapd 或 movlpd&#x2F;movhpd）。分块操作会增加指令数量和延迟，而全宽度操作只需一条指令即可完成。</p><p><strong>3. 使用零化惯用法&#x2F;置一惯用法清理&#x2F;设置寄存器</strong></p><p><strong>4. 设置 MXCSR.DAZ 和 MXCSR.FTZ</strong></p><p>如果可能，将 MXCSR 控制寄存器的 DAZ（Denorm As Zero）和 FTZ（Flush To Zero）标志置为 1。这可以避免因非规格化数（denormal numbers）导致的乘法、除法、平方根等操作的延迟。</p><p><strong>5. 避免条件分支</strong><br> 避免在数值计算中使用分支（如 if-else），改用条件移动或向量比较指令。</p><p><strong>6. 寄存器间移动无延迟</strong><br>XMM&#x2F;YMM&#x2F;ZMM 寄存器之间的移动（如 VMOVAPS）没有延迟，可放心使用。</p><p><strong>7. 保持数据类型一致性</strong></p><p>对同一数据的操作应使用一致的数据类型（例如，若使用 VMULPS 计算单精度浮点结果，后续操作也应使用单精度指令如 VANDPS 或 VMAXPS）。<br>这可以避免因数据类型转换导致的额外开销。</p><p><strong>8. 避免不必要的 GATHER 指令</strong><br>当索引已知时，避免使用 GATHER 指令，改用向量加载（vector loads）结合 shuffle 指令。GATHER 指令的延迟较高，而向量加载和 shuffle 可以提高内存带宽利用率。</p><hr><h3 id="2-11-3-x87-代码的浮点性能优化"><a href="#2-11-3-x87-代码的浮点性能优化" class="headerlink" title="2.11.3 x87 代码的浮点性能优化"></a><strong>2.11.3 x87 代码的浮点性能优化</strong></h3><p>以下是针对 x87 浮点代码的优化建议：</p><ul><li><strong>使用 FXCH 代替 push&#x2F;pop</strong><ul><li>尽可能使用 FXCH 指令交换 x87 浮点寄存器的值，而非通过 push&#x2F;pop 操作。FXCH 的交换速度更快，能够减少延迟 。</li></ul></li><li><strong>避免在 FCOM 和 FSTSW 之间插入指令</strong><ul><li>在浮点比较操作中，避免在 FCOM（比较浮点值）和 FSTSW（将状态字保存到 AX 寄存器）之间插入其他指令。这可以确保比较结果的正确性和性能 。</li></ul></li></ul><hr><p><a id="2114"></a></p><h3 id="2-11-4-非规格化数（Denormals）"><a href="#2-11-4-非规格化数（Denormals）" class="headerlink" title="2.11.4 非规格化数（Denormals）"></a><strong>2.11.4 非规格化数（Denormals）</strong></h3><p>非规格化浮点值（也称为次正规数，subnormals）可以通过以下两种方式产生：</p><ul><li><strong>显式指定</strong> ：在源代码中明确使用非规格化值。</li><li><strong>计算生成</strong> ：对正常浮点值进行计算时可能生成非规格化结果。</li></ul><p>在某些操作（如乘法 MUL、除法 DIV、平方根 SQRT）中，遇到非规格化值会引入轻微性能损失。对于 SSE&#x2F;AVX 指令，非规格化数的性能损失取决于 MXCSR 寄存器的配置以及在存在非规格化值时执行的指令序列。</p><p>如果不需要非规格化数的精度，建议软件设置 MXCSR.DAZ （将非规格化数视为零）和 MXCSR.FTZ （将非规格化数刷新为零）。设置这些标志位后，处理器在处理或生成非规格化值时，结果将不符合 IEEE-754 标准（损失精确性），但能避免性能损失 。</p><p>x87 浮点控制字（FCW）没有与 MXCSR.DAZ 或 MXCSR.FTZ 等效的功能，因此在使用 x87 指令时，无法避免因非规格化数导致的性能惩罚 。</p><h3 id="2-11-5-XMM-寄存器合并优化"><a href="#2-11-5-XMM-寄存器合并优化" class="headerlink" title="2.11.5 XMM 寄存器合并优化"></a><strong>2.11.5 XMM 寄存器合并优化</strong></h3><p>处理器实现了 XMM 寄存器合并优化 。其核心机制如下：</p><ul><li><p><strong>高位清零跟踪</strong> ：</p><ul><li>处理器会跟踪那些高位（例如 128 位寄存器的高 96 位）已被清零的 XMM 寄存器。这一信息可以跨多个操作和目标寄存器传递，直到有非零数据被写入这些高位 。<strong>如果后续指令未修改这些高位，则无需重新合并寄存器的高位部分，从而减少延迟</strong>。</li></ul></li><li><p>合并优化的触发条件 ：</p><ul><li>如果某条指令（如 SQRTSS）的目标寄存器高位未被修改（例如 SQRTSS 仅操作低 32 位），且后续指令未向高位写入非零数据，则该指令可以绕过常规的结果合并步骤，直接执行而无需等待前序指令完成 。</li></ul></li><li><p>受益指令列表 ：<br>以下指令可以利用此优化（因其仅修改寄存器的低位部分）：</p><ul><li>标量转换指令 ：<code>CVTPI2PS</code>, <code>CVTSI2SS</code>, <code>CVTSD2SS</code>, <code>CVTSS2SD</code>, <code>CVTSI2SD</code></li><li>标量移动指令 ：<code>MOVSS xmm1, xmm2</code>, <code>MOVSD xmm1, xmm2</code>, <code>MOVLPS xmm1, [mem]</code>, <code>MOVLPD xmm1, [mem]</code></li><li>标量浮点运算指令 ：<code>RCPSS</code>, <code>ROUNDSS</code>, <code>ROUNDSD</code>, <code>RSQRTSS</code>, <code>SQRTSD</code>, <code>SQRTSS</code></li></ul></li></ul><hr><h3 id="2-11-6-混合使用-AVX-和-SSE-指令的性能惩罚"><a href="#2-11-6-混合使用-AVX-和-SSE-指令的性能惩罚" class="headerlink" title="2.11.6 混合使用 AVX 和 SSE 指令的性能惩罚"></a><strong>2.11.6 混合使用 AVX 和 SSE 指令的性能惩罚</strong></h3><p>当 ZMM 寄存器的上部 384 位包含非零数据时，<strong>混合使用 SSE 和 AVX 指令会导致性能损失</strong>。此时，SSE 操作会被提升为 256 位或 512 位操作以合并数据到结果中。这会导致那些不依赖结果操作数的指令<strong>产生额外的依赖关系</strong>。</p><h3 id="2-11-7-何时使用-FMA-而非-FMUL-FADD"><a href="#2-11-7-何时使用-FMA-而非-FMUL-FADD" class="headerlink" title="2.11.7 何时使用 FMA 而非 FMUL&#x2F;FADD"></a><strong>2.11.7 何时使用 FMA 而非 FMUL&#x2F;FADD</strong></h3><p>在某些情况下，软件需要在 FMA（融合乘加） 和单独的 FMUL（乘法）&#x2F;FADD（加法） 操作之间选择。以下是具体指导原则：</p><ul><li><p><strong>不建议使用 FMA 的情况</strong> ：</p><ul><li><strong>关键依赖链通过 FMA 的加数输入</strong><blockquote><p>vfmadd231ss xmm0, xmm1, xmm2  &#x2F;&#x2F; xmm0 &#x3D; xmm0 + (xmm1 * xmm2)， xmm0存在依赖链</p></blockquote></li></ul></li><li><p><strong>建议使用 FMA 的情况</strong> ：</p><ul><li><strong>关键依赖链通过 FMUL 到 FADD 的路径</strong><blockquote><p>vmulss xmm1, xmm2, xmm3      &#x2F;&#x2F; xmm1 &#x3D; xmm2 * xmm3<br>  vaddss xmm0, xmm0, xmm1      &#x2F;&#x2F; xmm0 &#x3D; xmm0 + xmm1<br>  vfmadd231ss xmm0, xmm2, xmm3 &#x2F;&#x2F; xmm0 &#x3D; xmm0 + (xmm2 * xmm3), 优化后</p></blockquote></li><li>操作数不在关键依赖链中</li></ul></li></ul><hr><p><a id="212"></a></p><h2 id="2-12-加载-存储单元（Load-Store-Unit-LS）"><a href="#2-12-加载-存储单元（Load-Store-Unit-LS）" class="headerlink" title="2.12 加载-存储单元（Load-Store Unit, LS）"></a>2.12 加载-存储单元（Load-Store Unit, LS）</h2><p><img src="/image-4.png" alt="alt text"></p><p>加载-存储单元（LS 单元）负责处理数据访问。LS 单元包含 4 条高度独立的流水线 ，每周期最多可执行 4 条内存操作 。具体限制如下：</p><ul><li>加载操作 ：<br>每周期最多支持 2 条 128&#x2F;256&#x2F;512 位加载操作 。</li><li>存储操作 ：<br>每周期最多支持 2 条存储操作 ，但如果存储操作是 512 位，则每周期仅限 1 条 。</li></ul><p><strong>1. LS 单元的关键组件</strong></p><ul><li><strong>加载队列（LDQ）</strong> ：<ul><li>接收分发(dispatch)的加载操作，并跟踪未完成的加载。</li><li>最多可跟踪 64 条未完成的加载操作 ，且对已完成的加载数量没有硬性限制 。</li></ul></li><li><strong>存储队列（STQ）</strong> ：<ul><li>包含 104 个条目 ，用于保存从分发到数据写入数据缓存（Data Cache）的存储操作 。</li></ul></li></ul><p><strong>2. 动态重排序与内存一致性</strong></p><ul><li><strong>动态重排序</strong> ：<ul><li>LS 单元支持<strong>加载绕过旧加载</strong> 和 <strong>加载绕过无冲突的旧存储</strong> 。</li><li>这种机制提高了内存操作的并行性，同时确保遵循 AMD64 架构的内存顺序规则 。</li></ul></li><li><strong>Store-to-Load Forwarding (STLF)</strong> ：<ul><li>当存储操作的数据已就绪且完全包含在加载操作的地址范围内时，<strong>LS 单元可以直接将存储数据转发给加载操作</strong>（无需等待数据写入缓存）。</li><li>加载操作无需特定对齐，只要其地址完全包含在存储操作的地址范围内即可 。</li></ul></li></ul><p><strong>3. 地址冲突与优化建议</strong></p><ul><li>地址匹配规则 ：<ul><li>处理器使用<strong>线性地址的 低 12 位（11:0）</strong> 判断是否满足 STLF 条件。</li><li>如果多个存储操作具有相同的低 12 位地址（但高位地址不同），且同时存在未完成的加载操作需要 STLF，可能导致性能损失。</li></ul></li><li>优化建议 ：<ul><li><strong>避免地址冲突</strong> ：避免同时有多个存储操作的低 12 位地址相同但高位不同的情况。</li><li><strong>紧密分组操作</strong> ：将加载操作紧接在相关存储操作之后，以最大化 STLF 的效率。</li></ul></li></ul><p><strong>4. LS 单元的缓存未命中跟踪能力 Outstanding Cache Misses</strong></p><p>LS 单元最多可以跟踪 124 个未完成的缓存未命中 ，确保高并发内存操作时不会因缓存未命中导致流水线停滞 。</p><p><strong>5. AGU 与 LS 流水线的寻址模式优化</strong></p><ul><li><strong>简单寻址模式（Simple Addressing Modes）</strong> ：<br>以下寻址模式被视为简单模式，具有较低的加载延迟：<ul><li>基址+位移 （Base+Displacement）</li><li>基址+索引 （Base+Index）</li><li>无缩放的索引+位移 （Unscaled Index+Displacement）</li><li>纯位移模式 （Displacement-Only）</li><li>延迟表现 ：<ul><li>整数加载（Integer Load）：<strong>4</strong> 周期 （Load-to-Use）</li><li>浮点加载（FP Load）：<strong>7</strong> 周期 （Load-to-Use）</li></ul></li></ul></li><li><strong>复杂寻址模式（Complex Addressing Modes）</strong> ：<br>以下模式需要额外的地址计算周期：<ul><li>基址+索引+位移 （Base+Index+Displacement）</li><li>任何使用缩放索引 （如 *2, *4, *8）的寻址模式</li><li>延迟表现 ：<ul><li>整数加载：<strong>5</strong> 周期 （比简单模式多 1 周期）</li><li>浮点加载：<strong>8</strong> 周期 （比简单模式多 1 周期）</li></ul></li><li>编译器建议 ：<br>在延迟敏感的代码中，编译器应避免使用复杂寻址模式 。</li></ul></li></ul><hr><p><a id="2121"></a></p><h3 id="2-12-1-数据预取（Prefetching-of-Data）"><a href="#2-12-1-数据预取（Prefetching-of-Data）" class="headerlink" title="2.12.1 数据预取（Prefetching of Data）"></a><strong>2.12.1 数据预取（Prefetching of Data）</strong></h3><p>AMD Zen5 微架构为其 L1 数据缓存和 L2 缓存实现了数据预取逻辑（Prefetch Logic）。一般来说：</p><ul><li><strong>L1 数据预取器 ：将数据预取到 L1 数据缓存和 L2 缓存中</strong>。</li><li><strong>L2 数据预取器 ：仅将数据预取到 L2 缓存中</strong> 。</li></ul><p><strong>预取器类型</strong><br>以下是 Zen5 的预取器分类及其功能：</p><ul><li><strong>L1 Stream 预取器</strong>：<br>根据内存访问模式的历史记录，按升序或降序预取连续的缓存行（cacheline）。<br>示例：顺序遍历数组时触发预取。</li><li><strong>L1 Stride 预取器</strong> ：<br>根据单条指令的内存访问历史记录，预取固定步长（stride）的缓存行。<br>支持识别“跳跃模式”（如二维数组访问），只要跳跃距离固定且间隔规律。</li><li><strong>L1 Region 预取器</strong> ：<br>当某条指令的数据访问后，后续访问呈现局部区域内的稳定模式时触发预取。<br>示例：在紧凑的循环中访问相邻内存区域。</li><li><strong>L2 Stream 预取器</strong> ：<br>类似 L1 Stream，但作用于 L2 缓存，预取顺序缓存行。</li><li><strong>L2 Up&#x2F;Down 预取器</strong> ：<br>根据内存访问历史，决定预取下一条或前一条缓存行。<br>适用于双向遍历（如链表或双向数据流）。</li></ul><hr><p><a id="213"></a></p><h2 id="2-13-写入数据优化（Optimizing-Writing-Data）"><a href="#2-13-写入数据优化（Optimizing-Writing-Data）" class="headerlink" title="2.13 写入数据优化（Optimizing Writing Data）"></a>2.13 写入数据优化（Optimizing Writing Data）</h2><p>写合并（Write-Combining） 是一种将多个内存写入操作合并到同一写缓冲区地址范围内的技术。AMD Zen5 处理器支持 <strong>内存类型范围寄存器（MTRR）</strong> 和 <strong>页属性表（PAT）</strong> 扩展，允许软件将<strong>内存区域</strong>定义为以下类型之一：</p><ul><li>Write-Back (WB) ：常规缓存模式。</li><li>Write-Protected (WP) ：写保护模式。</li><li>Write-Through (WT) ：写直达模式。</li><li>Uncacheable (UC) ：不可缓存模式。</li><li>Write-Combining (WC) ：写合并模式 。</li></ul><p>当内存区域被定义为 WC 模式 时，处理器会将多个写入操作（针对该范围内的地址）合并到一个合并缓冲区（merge buffer）中。合并多个写入操作为单次操作可以减少处理器总线利用率和流水线停滞（stalls）。此外，写合并缓冲区 也用于流式存储指令（如 MOVNTQ 和 MOVNTI）。</p><p>通过 MTRR 或 PAT 将频繁写入的内存区域（如帧缓冲区、临时数据缓冲区）<strong>设置为 WC 模式，以减少总线压力</strong>。</p><hr><h3 id="2-13-1-软件预取数据或指令"><a href="#2-13-1-软件预取数据或指令" class="headerlink" title="2.13.1 软件预取数据或指令"></a><strong>2.13.1 软件预取数据或指令</strong></h3><p>AMD Zen5 微架构通过改进的软件预取控制，允许 PREFETCH 指令将数据或指令显式预取到缓存层次结构的特定层级。新增的两种局部性引用类型 IT0 和 IT1 专门用于<strong>指令预取（Instruction Prefetch）</strong>，进一步优化代码执行效率 。</p><ul><li><strong>IT0</strong> ：预取到 L1 指令缓存（I-Cache）。</li><li><strong>IT1</strong> ：预取到 L2 缓存，适用于需要长期保留的指令。</li></ul><p>具体指令见Spec.</p><hr><p><a id="2132"></a></p><h3 id="2-13-2-写合并操作（Write-Combining-Operations）"><a href="#2-13-2-写合并操作（Write-Combining-Operations）" class="headerlink" title="2.13.2 写合并操作（Write-Combining Operations）"></a><strong>2.13.2 写合并操作（Write-Combining Operations）</strong></h3><p>为了提高系统性能，AMD Zen5 处理器引入了 写合并缓冲区（Write Combining Buffer, WCB） ，其核心机制如下：</p><p><strong>WCB 的组成 ：</strong><br>WCB 包含多个 64 字节对齐的写缓冲区 ，每个缓冲区对应一个缓存行（cache line）。</p><p><strong>合并规则 ：</strong></p><ul><li>WC 内存类型 ：<ul><li>WC 模式的写操作可以按任意顺序合并，直到填满 64 字节缓冲区。支持的数据类型包括字节、字、双字、四字、XMM&#x2F;YMM&#x2F;ZMM 字（如 MOVNTI 指令）。</li><li>其他内存类型（UC&#x2F;WP&#x2F;WT&#x2F;WB） ：<br>除非被流式存储指令（如 MOVNTQ、MOVNTI）覆盖，否则这些模式的写操作无法合并。流式指令的合并行为与 WC 内存模式一致。</li></ul></li></ul><p><strong>部分填充的缓冲区问题 ：</strong></p><ul><li>如果写操作未对齐到 64 字节边界，可能<strong>导致缓冲区部分填充，长时间未关闭（flush），从而降低后续写操作的带宽</strong>。</li><li>优化建议 ：<br>将写合并操作<strong>对齐到 64 字节缓存行边界，避免部分填充</strong>。如果必须从非对齐地址开始写入，可以在代码中插入 写合并完成事件 （如 SFENCE 或 MFENCE）以强制刷新缓冲区 。</li></ul><p><strong>合并中断条件 ：</strong><br>合并会在以下情况中断（如引用  中的 Table 9）：</p><ul><li>遇到 <code>SFENCE</code>、<code>MFENCE</code> 或 <code>CLFLUSH</code> 指令。</li><li>缓冲区被填满（64 字节）。</li><li>发生上下文切换或异常。</li></ul><hr><p><a id="2133"></a></p><h3 id="2-13-3-将写缓冲区数据发送到系统（Sending-Write-Buffer-Data-to-the-System）"><a href="#2-13-3-将写缓冲区数据发送到系统（Sending-Write-Buffer-Data-to-the-System）" class="headerlink" title="2.13.3 将写缓冲区数据发送到系统（Sending Write-Buffer Data to the System）"></a><strong>2.13.3 将写缓冲区数据发送到系统（Sending Write-Buffer Data to the System）</strong></h3><p>AMD Zen5 处理器通过写合并（Write Combining）实现最大吞吐量的条件如下：</p><ul><li><strong>数据有效性</strong> ：<br>当所有 四字（quadword, 8 字节） 或 双字（doubleword, 4 字节） 写入操作的数据有效时，处理器可以将多个 16 字节写入<strong>合并</strong>为一个 64 字节的高效内存写入 ，从而<u>最大化带宽利用率</u>。</li><li><strong>多缓存行支持</strong> ：<br>处理器可以从 12 个不同的 64 字节缓存行 中收集写入数据。在 SMT（同步多线程）模式下，单个线程最多可以处理 11 个缓存行 的写合并流。</li><li><strong>吞吐量优化</strong> ：<br>当同时进行的<strong>写合并流（write-combining streams）数量较少</strong>时，吞吐量最佳。</li></ul><hr><p><a id="2134"></a></p><h3 id="2-13-4-字符串存储优化（String-Store-Optimizations）"><a href="#2-13-4-字符串存储优化（String-Store-Optimizations）" class="headerlink" title="2.13.4 字符串存储优化（String Store Optimizations）"></a><strong>2.13.4 字符串存储优化（String Store Optimizations）</strong></h3><p>AMD Zen5 架构针对 rep movs 和 rep stos 等字符串指令（string instructions）的存储操作进行了多项优化，以提升性能。</p><p><strong>1. 大字符串的流式存储优化</strong></p><ul><li>触发条件 ：<br>当字符串大小 大于或等于处理器的 L3 缓存容量 时，Zen5 会使用 流式存储（streaming-store） 操作 。</li><li>流式存储的特点 ：<ul><li>非缓存写入 ：数据绕过缓存层次结构（L1&#x2F;L2&#x2F;L3），直接通过 <strong>写合并缓冲区（WCB）</strong> 聚合后写入内存。</li><li>避免缓存污染 ：防止字符串数据替换掉缓存中其他有用的数据，提升整体性能。</li></ul></li></ul><p><strong>2. 小字符串的 RFO 优化</strong></p><ul><li>优化触发条件 ：<br>当字符串指令 <strong>完全覆盖目标缓存行</strong> 时，Zen5 会消除 读取所有权（Read For Ownership, RFO） 操作，即使缓存行未被预取 。</li><li>RFO 的代价 ：<br>RFO 需要先从内存中读取缓存行到缓存，再修改并写回。Zen5 的优化允许直接分配缓存行（无需读取），从而减少延迟。</li><li>阈值限制 ：<br>优化的触发阈值取决于具体实现，但字符串无需严格对齐到缓存行大小（如 64 字节）。如果缓存行未被完全覆盖（如部分写入），仍需执行 RFO。</li></ul><p><strong>3. 内存可见性与一致性</strong></p><ul><li>乱序可见性 ：<br>字符串指令产生的存储操作可能对其他处理器乱序可见，但 Zen5 保证以下顺序：<ul><li>**前序存储 （older stores）**在字符串存储之前完成可见性。</li><li>**后续存储 （younger stores）**在字符串存储完成后才可见 。</li></ul></li></ul><p><strong>4. 核心机制 ：</strong></p><ul><li><strong>大字符串使用流式存储绕过缓存，减少污染</strong> 。</li><li><strong>小字符串通过消除 RFO 加速完全覆盖写入</strong> 。</li></ul><hr><p><a id="214"></a></p><h2 id="2-14-同步多线程（Simultaneous-Multi-Threading-SMT）"><a href="#2-14-同步多线程（Simultaneous-Multi-Threading-SMT）" class="headerlink" title="2.14 同步多线程（Simultaneous Multi-Threading, SMT）"></a>2.14 同步多线程（Simultaneous Multi-Threading, SMT）</h2><p>为了提高指令吞吐量，处理器实现了 同步多线程（SMT） 。单线程应用程序通常无法完全占用处理器的所有资源，SMT 允许处理器利用未使用的资源并发执行第二个线程。</p><p><strong>SMT 的核心机制</strong></p><ul><li>资源分配类型 ：<br>在双线程模式下，处理器资源（如队列条目、缓存、流水线、执行单元）可通过以下三种模式管理：<ul><li><strong>竞争共享（Competitively Shared）</strong> ：<br>资源按需动态分配，单个线程可能占用所有资源条目。<br>示例 ：L3 缓存默认采用此模式 。</li><li><strong>水印限制（Watermarked）</strong> ：<br>资源按需分配，但在双线程模式下，每个线程的资源使用量受限于预设的水印阈值。</li><li><strong>静态分区（Statically Partitioned）</strong> ：<br>资源在进入双线程模式时被静态划分，每个线程仅能使用其分配的分区资源 。</li></ul></li><li>资源分配策略的配置 ：<ul><li>L3 缓存 ：默认为竞争共享模式，但可通过 AMD64 技术平台服务质量扩展（QoS Extensions） 调整策略 。</li><li>其他资源 ：如调度队列、执行单元等，可能采用水印或静态分区模式。</li></ul></li></ul><table border="1"><caption> Resource Sharing</caption><thead>  <tr>    <th>Resource</th>    <th>Competitively Shared</th>    <th>Watermarked</th>    <th>Static Partitioned</th>  </tr></thead><tbody>  <tr>    <td>L1 Instruction Cache</td>    <td>Yes</td>    <td></td>    <td></td>  </tr>  <tr>    <td>ITLB</td>    <td>Yes</td>    <td></td>    <td></td>  </tr>  <tr>    <td>Op Cache</td>    <td>Yes</td>    <td></td>    <td></td>  </tr>  <tr>    <td>Dispatch Interface</td>    <td>Yes</td>    <td></td>    <td></td>  </tr>  <tr>    <td>DTLB</td>    <td>Yes</td>    <td></td>    <td></td>  </tr>  <tr>    <td>L2 Cache</td>    <td>Yes</td>    <td></td>    <td></td>  </tr>  <tr>    <td>L3 Cache</td>    <td>Yes</td>    <td></td>    <td></td>  </tr>  <tr>    <td>Integer Scheduler</td>    <td></td>    <td>Yes</td>    <td></td>  </tr>  <tr>    <td>Integer Register File</td>    <td></td>    <td>Yes</td>    <td></td>  </tr>  <tr>    <td>Load Queue</td>    <td></td>    <td>Yes</td>    <td></td>  </tr>  <tr>    <td>Floating Point Physical Register</td>    <td></td>    <td>Yes</td>    <td></td>  </tr>  <tr>    <td>Floating Point Scheduler</td>    <td></td>    <td>Yes</td>    <td></td>  </tr>  <tr>    <td>Memory Request Buffers</td>    <td></td>    <td>Yes</td>    <td></td>  </tr>  <tr>    <td>Op Queue</td>    <td></td>    <td></td>    <td>Yes</td>  </tr>  <tr>    <td>Store Queue</td>    <td></td>    <td></td>    <td>Yes</td>  </tr>  <tr>    <td>Write Combining Buffer</td>    <td></td>    <td>Yes</td>    <td></td>  </tr>  <tr>    <td>Retire Queue</td>    <td></td>    <td></td>    <td>Yes</td>  </tr></tbody></table><hr>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> x86 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> x86 </tag>
            
            <tag> 微架构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>opensbi启动分析</title>
      <link href="/2024/06/11/opensbi%E5%90%AF%E5%8A%A8%E5%88%86%E6%9E%90/"/>
      <url>/2024/06/11/opensbi%E5%90%AF%E5%8A%A8%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">opensbi: https://github.com/riscv-software-src/opensbi.git d962db280725b03a0340e05a07e4c85c93f35bc5 (当前最新，tag 1.4之后)</span><br><span class="line">参考文档：</span><br><span class="line">https://tinylab.org/sbi-firmware-analyze-1</span><br><span class="line">https://tinylab.org/sbi-firmware-analyze-2</span><br><span class="line">https://tinylab.org/opensbi-firmware-and-sbi-hsm/</span><br></pre></td></tr></table></figure><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>上述参考链接有很详细的分析，但是到tag 1.4之后启动文件有一定变动，另外这里只做一些补充。</p><h1 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make clean run LLVM=1 PLATFORM=generic PLATFORM_RISCV_XLEN=64</span><br></pre></td></tr></table></figure><p>参考opensbi的readme和makefile文件，编译器需要支持PIE参数，不然会报错。目前clang&#x2F;riscv64-unknown-elf-gcc都支持，理论上不会报错。如果报错，请任何执行<code>make xxx</code>时替换成<code>make LLVM=1 xxx</code>或者<code>make CROSS_COMPILE=riscv64-unknown-elf-  xxx</code>,注意，在clean时也需要这样（Mac）,总之注意规避PIE导致的报错。  </p><p>编译时<code>FDT_TEXT_START=0x8000_0000</code>宏定义需要指定。如果值为0是可以运行的，但是为其他值是不可以运行的，另外gdb都是不能正常调试的（除0x8000_0000）.  </p><p>另外，运行时请参考qemu_virt.md，里面有运行方法。在mac上，gdb连接远端时，localhost要替换成127.0.0.1，不然连接会出现问题。Mac下的gdb为riscv64-elf-gdb， 其他gdb目前还有问题。  </p><p>编译参数可修改makefile打印，关键的参数可以通过<code>platform/generic/objects.mk</code>和<code>firmware/objects.mk</code>查看，这些宏定义将会传递给makefile编译。  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-g -Wall  -ffreestanding -nostdlib -fno-stack-protector -fno-strict-aliasing -save-temps=obj -O2 -fno-omit-frame-pointer -fno-optimize-sibling-calls -mno-save-restore -mstrict-align -mabi=lp64 -march=rv64imafdc -mcmodel=medany -mno-relax --target=riscv64-unknown-elf -Wno-unused-command-line-argument -I/Users/zhoufei/Public/work/opensbi/platform/generic/include -I/Users/zhoufei/Public/work/opensbi/include -DOPENSBI_VERSION_GIT=&quot;v1.4-111-gd962db2&quot; -include /Users/zhoufei/Public/work/opensbi/build/platform/generic/kconfig/autoconf.h -I/Users/zhoufei/Public/work/opensbi/lib/utils/libfdt/   -DFW_TEXT_START=0x80000000 -DFW_PAYLOAD_PATH=&quot;/Users/zhoufei/Public/work/opensbi/build/platform/generic/firmware/payloads/test.bin&quot; -DFW_PAYLOAD_OFFSET=0x200000 -DFW_PAYLOAD_FDT_OFFSET=0x2200000  -fPIE -pie </span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>FW_TEXT_START: opensbi编译的固件存放位置。</li><li>FW_PAYLOAD_OFFSET：opensbi固件的三种方式之一——payload方式，payload放在<code>FW_TEXT_START + FW_PAYLOAD_OFFSET</code>处。</li><li>FW_PAYLOAD_FDT_OFFSET: 设备树存放位置<code>FW_TEXT_START + FW_PAYLOAD_FDT_OFFSET</code>,当payload没有指定dtb时，opensbi会拷贝自己的设备树到这个位置。</li></ul><h1 id="地址空间"><a href="#地址空间" class="headerlink" title="地址空间"></a>地址空间</h1><p><img src="/./2024-06-11-opensbi%E5%90%AF%E5%8A%A8%E5%88%86%E6%9E%90/map.png"></p><h1 id="启动调试"><a href="#启动调试" class="headerlink" title="启动调试"></a>启动调试</h1><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">qemu-system-riscv64 -M virt -smp 4 -m 256M -nographic -bios /Users/zhoufei/Public/work/opensbi/build/platform/generic/firmware/fw_payload.bin -gdb tcp::1234 -S</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新开终端</span></span><br><span class="line">riscv64-elf-gdb --tui build/platform/generic/firmware/fw_payload.elf -ex <span class="string">&#x27;layout regs&#x27;</span> -ex <span class="string">&#x27;set output-radix 16&#x27;</span> \</span><br><span class="line">        -ex <span class="string">&#x27;target remote 127.0.0.1:1234&#x27;</span> \</span><br><span class="line">        -ex <span class="string">&#x27;b _start&#x27;</span> \</span><br><span class="line">        -ex <span class="string">&#x27;c&#x27;</span></span><br></pre></td></tr></table></figure><p>当启动调试时，断点在_start处,此时通用寄存器如下，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">t0=<span class="number">0x80000000</span>,</span><br><span class="line">a0=hartid,</span><br><span class="line">a1=<span class="number">0x8fe00000</span>, <span class="comment">// qemu传递的设备树地址，当编译opensbi时指定了FW_FDT_PATH,则a1地址会替换成新地址</span></span><br><span class="line">a2=<span class="number">0x1028</span>, <span class="comment">// 保存fw_dynamic_info地址，在payload方式固件中没使用</span></span><br><span class="line">pc=<span class="number">0x80000000</span>, <span class="comment">//qemu传递的启动地址（上述修改启动地址无效可能和这个地方有关）</span></span><br><span class="line"><span class="comment">// 其他寄存器为0</span></span><br></pre></td></tr></table></figure><p>参考qemu源码<code>hw/riscv/boot.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* reset vector */</span></span><br><span class="line"><span class="type">uint32_t</span> reset_vec[<span class="number">10</span>] = &#123;</span><br><span class="line">    <span class="number">0x00000297</span>,                  <span class="comment">/* 1:  auipc  t0, %pcrel_hi(fw_dyn) */</span></span><br><span class="line">    <span class="number">0x02828613</span>,                  <span class="comment">/*     addi   a2, t0, %pcrel_lo(1b) */</span></span><br><span class="line">    <span class="number">0xf1402573</span>,                  <span class="comment">/*     csrr   a0, mhartid  */</span></span><br><span class="line">    <span class="number">0x0202b583</span>,                  <span class="comment">/*     ld     a1, 32(t0) */</span></span><br><span class="line">    <span class="number">0x0182b283</span>,                  <span class="comment">/*     ld     t0, 24(t0) */</span></span><br><span class="line">    <span class="number">0x00028067</span>,                  <span class="comment">/*     jr     t0 */</span></span><br><span class="line">    start_addr,                  <span class="comment">/* start: .dword */</span></span><br><span class="line">    start_addr_hi32,</span><br><span class="line">    fdt_load_addr,               <span class="comment">/* fdt_laddr: .dword */</span></span><br><span class="line">    <span class="number">0x00000000</span>,</span><br><span class="line">                                 <span class="comment">/* fw_dyn: */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="/./2024-06-11-opensbi%E5%90%AF%E5%8A%A8%E5%88%86%E6%9E%90/rom.png"><br>通过工具[<a href="https://luplab.gitlab.io/rvcodecjs]%E5%8F%AF%E4%BB%A5%E5%BE%97%E5%88%B0start_addr%E4%B9%8B%E5%89%8D%E7%9A%84%E5%8F%8D%E6%B1%87%E7%BC%96">https://luplab.gitlab.io/rvcodecjs]可以得到start_addr之前的反汇编</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">auipc t0, 0          // 注意reset_vec本身是在0x1000处，所以指令运行后t0=0x1000</span><br><span class="line">addi  a2, t0, 0x28  // 表示fw_dynamic_info在0x1028地址</span><br><span class="line">csrr  a0, mhartid   // 获取mhartid</span><br><span class="line">ld    a1, 0x20(t0)  // 0x1020,获取设备树地址8B，0x8fe0_0000</span><br><span class="line">ld    t0, 0x18(t0)  // 0x1018,获取fw开始地址8B，0x8000_0000</span><br><span class="line">jr    t0// 跳转到fw开始</span><br></pre></td></tr></table></figure><p>从gdb dump数据并结合fw_dynamic_info结构体可得：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// long类型在RV64下为8字节</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fw_dynamic_info</span> &#123;</span></span><br><span class="line"><span class="comment">/** Info magic, 在fw_dynamic.h中定义 */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> magic = <span class="number">0x4942534f</span> = <span class="string">&#x27;OSBI&#x27;</span>;</span><br><span class="line"><span class="comment">/** Info version */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> version = <span class="number">2</span>;</span><br><span class="line"><span class="comment">/** Next booting stage address */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> next_addr = <span class="number">0</span>;</span><br><span class="line"><span class="comment">/** Next booting stage mode */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> next_mode = <span class="number">1</span>;   <span class="comment">// s-mode</span></span><br><span class="line"><span class="comment">/** Options for OpenSBI library */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> options = <span class="number">0</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> boot_hart; <span class="comment">// 图片上没有hart数据</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>多线程调试时可以使用 set scheduler-locking on调试当前线程。</p><h2 id="fw-base-S"><a href="#fw-base-S" class="headerlink" title="fw_base.S"></a>fw_base.S</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br><span class="line">723</span><br><span class="line">724</span><br><span class="line">725</span><br><span class="line">726</span><br><span class="line">727</span><br><span class="line">728</span><br><span class="line">729</span><br><span class="line">730</span><br><span class="line">731</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * SPDX-License-Identifier: BSD-2-Clause</span><br><span class="line"> *</span><br><span class="line"> * Copyright (c) 2019 Western Digital Corporation or its affiliates.</span><br><span class="line"> *</span><br><span class="line"> * Authors:</span><br><span class="line"> *   Anup Patel &lt;anup.patel@wdc.com&gt;</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">#include &lt;sbi/riscv_asm.h&gt;</span><br><span class="line">#include &lt;sbi/riscv_encoding.h&gt;</span><br><span class="line">#include &lt;sbi/riscv_elf.h&gt;</span><br><span class="line">#include &lt;sbi/sbi_platform.h&gt;</span><br><span class="line">#include &lt;sbi/sbi_scratch.h&gt;</span><br><span class="line">#include &lt;sbi/sbi_trap.h&gt;</span><br><span class="line"></span><br><span class="line">#define BOOT_STATUS_LOTTERY_DONE1</span><br><span class="line">#define BOOT_STATUS_BOOT_HART_DONE2</span><br><span class="line"></span><br><span class="line">.macroMOV_3R __d0, __s0, __d1, __s1, __d2, __s2</span><br><span class="line">add\__d0, \__s0, zero</span><br><span class="line">add\__d1, \__s1, zero</span><br><span class="line">add\__d2, \__s2, zero</span><br><span class="line">.endm</span><br><span class="line"></span><br><span class="line">.macroMOV_5R __d0, __s0, __d1, __s1, __d2, __s2, __d3, __s3, __d4, __s4</span><br><span class="line">add\__d0, \__s0, zero</span><br><span class="line">add\__d1, \__s1, zero</span><br><span class="line">add\__d2, \__s2, zero</span><br><span class="line">add\__d3, \__s3, zero</span><br><span class="line">add\__d4, \__s4, zero</span><br><span class="line">.endm</span><br><span class="line"></span><br><span class="line">.section .entry, &quot;ax&quot;, %progbits</span><br><span class="line">.align 3</span><br><span class="line">.globl _start</span><br><span class="line">.globl _start_warm</span><br><span class="line">_start: // _start标签会被所有hart执行，注意每个hart都有独立的一套寄存器</span><br><span class="line">/* Find preferred boot HART id */</span><br><span class="line">MOV_3Rs0, a0, s1, a1, s2, a2</span><br><span class="line">callfw_boot_hart //fw_boot_hart会指定主hart，默认情况不特殊指定。</span><br><span class="line">adda6, a0, zero</span><br><span class="line">MOV_3Ra0, s0, a1, s1, a2, s2</span><br><span class="line">lia7, -1</span><br><span class="line">beqa6, a7, _try_lottery // 当主hart未指定时，所有hart跳入lottery</span><br><span class="line">/* Jump to relocation wait loop if we are not boot hart */</span><br><span class="line">bnea0, a6, _wait_for_boot_hart</span><br><span class="line">_try_lottery: // 该标签决策出主hart</span><br><span class="line">/* Jump to relocation wait loop if we don&#x27;t get relocation lottery */</span><br><span class="line">llaa6, _boot_status</span><br><span class="line">lia7, BOOT_STATUS_LOTTERY_DONE</span><br><span class="line">amoswap.w a6, a7, (a6)  // 原子操作，直接修改内存，将内存原值保存到a6,内存值加1</span><br><span class="line">bneza6, _wait_for_boot_hart // 由于原子操作会导致a6变化，只有a6为0时才继续向下执行，即多个hart第一个执行上述原子操作的hart才被选为主hart，其他hart调到wait处。</span><br><span class="line"></span><br><span class="line">    // 以下为主hart执行，当加载地址和链接地址不同时，将.rela.dyn段进行重定位。</span><br><span class="line">/* relocate the global table content */</span><br><span class="line">lit0, FW_TEXT_START/* link start */</span><br><span class="line">llat1, _fw_start/* load start */</span><br><span class="line">subt2, t1, t0/* load offset */</span><br><span class="line">llat0, __rel_dyn_start</span><br><span class="line">llat1, __rel_dyn_end</span><br><span class="line">beqt0, t1, _relocate_done</span><br><span class="line">2:</span><br><span class="line">REG_Lt5, REGBYTES(t0)/* t5 &lt;-- relocation info:type */</span><br><span class="line">lit3, R_RISCV_RELATIVE/* reloc type R_RISCV_RELATIVE */</span><br><span class="line">bnet5, t3, 3f</span><br><span class="line">REG_Lt3, 0(t0)</span><br><span class="line">REG_Lt5, (REGBYTES * 2)(t0)/* t5 &lt;-- addend */</span><br><span class="line">addt5, t5, t2</span><br><span class="line">addt3, t3, t2</span><br><span class="line">REG_St5, 0(t3)/* store runtime address to the GOT entry */</span><br><span class="line"></span><br><span class="line">3:</span><br><span class="line">addit0, t0, (REGBYTES * 3)</span><br><span class="line">bltt0, t1, 2b</span><br><span class="line">_relocate_done:</span><br><span class="line">/* At this point we are running from link address */</span><br><span class="line"></span><br><span class="line">/* Reset all registers except ra, a0, a1, a2, a3 and a4 for boot HART */</span><br><span class="line">lira, 0</span><br><span class="line">call_reset_regs</span><br><span class="line"></span><br><span class="line">/* Zero-out BSS */</span><br><span class="line">llas4, _bss_start</span><br><span class="line">llas5, _bss_end</span><br><span class="line">_bss_zero:</span><br><span class="line">REG_Szero, (s4)</span><br><span class="line">adds4, s4, __SIZEOF_POINTER__</span><br><span class="line">blts4, s5, _bss_zero</span><br><span class="line"></span><br><span class="line">/* Setup temporary trap handler */</span><br><span class="line">llas4, _start_hang</span><br><span class="line">csrwCSR_MTVEC, s4</span><br><span class="line"></span><br><span class="line">/* Setup temporary stack */</span><br><span class="line">llas4, _fw_end</span><br><span class="line">lis5, (SBI_SCRATCH_SIZE * 2)</span><br><span class="line">addsp, s4, s5</span><br><span class="line"></span><br><span class="line">/* Allow main firmware to save info */</span><br><span class="line">MOV_5Rs0, a0, s1, a1, s2, a2, s3, a3, s4, a4</span><br><span class="line">callfw_save_info</span><br><span class="line">MOV_5Ra0, s0, a1, s1, a2, s2, a3, s3, a4, s4</span><br><span class="line"></span><br><span class="line">#ifdef FW_FDT_PATH // 当定义了设备树，之前的a1=0x8fe00000将会替换成新值</span><br><span class="line">/* Override previous arg1 */</span><br><span class="line">llaa1, fw_fdt_bin</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * Initialize platform</span><br><span class="line"> * Note: The a0 to a4 registers passed to the</span><br><span class="line"> * firmware are parameters to this function.</span><br><span class="line"> */</span><br><span class="line">MOV_5Rs0, a0, s1, a1, s2, a2, s3, a3, s4, a4</span><br><span class="line">callfw_platform_init //读取设备树，更新platform结构体，主要包括平台名，hart数</span><br><span class="line">addt0, a0, zero</span><br><span class="line">MOV_5Ra0, s0, a1, s1, a2, s2, a3, s3, a4, s4</span><br><span class="line">adda1, t0, zero</span><br><span class="line"></span><br><span class="line">/* Preload HART details</span><br><span class="line"> * s7 -&gt; HART Count</span><br><span class="line"> * s8 -&gt; HART Stack Size</span><br><span class="line"> * s9 -&gt; Heap Size</span><br><span class="line"> * s10 -&gt; Heap Offset</span><br><span class="line"> */</span><br><span class="line">llaa4, platform // platform为平台的所有信息的结构体，厂商定义，virt使用platform/generic/platform.c</span><br><span class="line">#if __riscv_xlen &gt; 32</span><br><span class="line">lwus7, SBI_PLATFORM_HART_COUNT_OFFSET(a4)</span><br><span class="line">lwus8, SBI_PLATFORM_HART_STACK_SIZE_OFFSET(a4)</span><br><span class="line">lwus9, SBI_PLATFORM_HEAP_SIZE_OFFSET(a4)</span><br><span class="line">#else</span><br><span class="line">lws7, SBI_PLATFORM_HART_COUNT_OFFSET(a4)</span><br><span class="line">lws8, SBI_PLATFORM_HART_STACK_SIZE_OFFSET(a4)</span><br><span class="line">lws9, SBI_PLATFORM_HEAP_SIZE_OFFSET(a4)</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">/* Setup scratch space for all the HARTs*/</span><br><span class="line">llatp, _fw_end</span><br><span class="line">mula5, s7, s8</span><br><span class="line">addtp, tp, a5</span><br><span class="line">/* Setup heap base address */</span><br><span class="line">llas10, _fw_start</span><br><span class="line">subs10, tp, s10</span><br><span class="line">addtp, tp, s9</span><br><span class="line">/* Keep a copy of tp */</span><br><span class="line">addt3, tp, zero</span><br><span class="line">/* Counter */</span><br><span class="line">lit2, 1</span><br><span class="line">/* hartid 0 is mandated by ISA */</span><br><span class="line">lit1, 0</span><br><span class="line">_scratch_init: // 更新scratch，|stackN|scratchN|stackN-1|scratchN-1|...</span><br><span class="line">/*         // sbi_scratch.h有其结构体定义</span><br><span class="line"> * The following registers hold values that are computed before</span><br><span class="line"> * entering this block, and should remain unchanged.</span><br><span class="line"> *</span><br><span class="line"> * t3 -&gt; the firmware end address</span><br><span class="line"> * s7 -&gt; HART count</span><br><span class="line"> * s8 -&gt; HART stack size</span><br><span class="line"> * s9 -&gt; Heap Size</span><br><span class="line"> * s10 -&gt; Heap Offset</span><br><span class="line"> */</span><br><span class="line">addtp, t3, zero</span><br><span class="line">subtp, tp, s9</span><br><span class="line">mula5, s8, t1</span><br><span class="line">subtp, tp, a5</span><br><span class="line">lia5, SBI_SCRATCH_SIZE</span><br><span class="line">subtp, tp, a5</span><br><span class="line"></span><br><span class="line">/* Initialize scratch space */</span><br><span class="line">/* Store fw_start and fw_size in scratch space */</span><br><span class="line">llaa4, _fw_start</span><br><span class="line">suba5, t3, a4</span><br><span class="line">REG_Sa4, SBI_SCRATCH_FW_START_OFFSET(tp)</span><br><span class="line">REG_Sa5, SBI_SCRATCH_FW_SIZE_OFFSET(tp)</span><br><span class="line"></span><br><span class="line">/* Store R/W section&#x27;s offset in scratch space */</span><br><span class="line">llaa5, _fw_rw_start</span><br><span class="line">suba5, a5, a4</span><br><span class="line">REG_Sa5, SBI_SCRATCH_FW_RW_OFFSET(tp)</span><br><span class="line"></span><br><span class="line">/* Store fw_heap_offset and fw_heap_size in scratch space */</span><br><span class="line">REG_Ss10, SBI_SCRATCH_FW_HEAP_OFFSET(tp)</span><br><span class="line">REG_Ss9, SBI_SCRATCH_FW_HEAP_SIZE_OFFSET(tp)</span><br><span class="line"></span><br><span class="line">/* Store next arg1 in scratch space */</span><br><span class="line">MOV_3Rs0, a0, s1, a1, s2, a2</span><br><span class="line">callfw_next_arg1</span><br><span class="line">REG_Sa0, SBI_SCRATCH_NEXT_ARG1_OFFSET(tp)</span><br><span class="line">MOV_3Ra0, s0, a1, s1, a2, s2</span><br><span class="line">/* Store next address in scratch space */</span><br><span class="line">MOV_3Rs0, a0, s1, a1, s2, a2</span><br><span class="line">callfw_next_addr</span><br><span class="line">REG_Sa0, SBI_SCRATCH_NEXT_ADDR_OFFSET(tp)</span><br><span class="line">MOV_3Ra0, s0, a1, s1, a2, s2</span><br><span class="line">/* Store next mode in scratch space */</span><br><span class="line">MOV_3Rs0, a0, s1, a1, s2, a2</span><br><span class="line">callfw_next_mode</span><br><span class="line">REG_Sa0, SBI_SCRATCH_NEXT_MODE_OFFSET(tp)</span><br><span class="line">MOV_3Ra0, s0, a1, s1, a2, s2</span><br><span class="line">/* Store warm_boot address in scratch space */</span><br><span class="line">llaa4, _start_warm</span><br><span class="line">REG_Sa4, SBI_SCRATCH_WARMBOOT_ADDR_OFFSET(tp)</span><br><span class="line">/* Store platform address in scratch space */</span><br><span class="line">llaa4, platform</span><br><span class="line">REG_Sa4, SBI_SCRATCH_PLATFORM_ADDR_OFFSET(tp)</span><br><span class="line">/* Store hartid-to-scratch function address in scratch space */</span><br><span class="line">llaa4, _hartid_to_scratch</span><br><span class="line">REG_Sa4, SBI_SCRATCH_HARTID_TO_SCRATCH_OFFSET(tp)</span><br><span class="line">/* Clear trap_context and tmp0 in scratch space */</span><br><span class="line">REG_Szero, SBI_SCRATCH_TRAP_CONTEXT_OFFSET(tp)</span><br><span class="line">REG_Szero, SBI_SCRATCH_TMP0_OFFSET(tp)</span><br><span class="line">/* Store firmware options in scratch space */</span><br><span class="line">MOV_3Rs0, a0, s1, a1, s2, a2</span><br><span class="line">#ifdef FW_OPTIONS</span><br><span class="line">lia0, FW_OPTIONS</span><br><span class="line">#else</span><br><span class="line">callfw_options</span><br><span class="line">#endif</span><br><span class="line">REG_Sa0, SBI_SCRATCH_OPTIONS_OFFSET(tp)</span><br><span class="line">MOV_3Ra0, s0, a1, s1, a2, s2</span><br><span class="line">/* Move to next scratch space */</span><br><span class="line">addt1, t1, t2</span><br><span class="line">bltt1, s7, _scratch_init</span><br><span class="line"></span><br><span class="line">/* // FDT设备树拷贝到FW_PAYLOAD_FDT_OFFSET处</span><br><span class="line"> * Relocate Flatened Device Tree (FDT)</span><br><span class="line"> * source FDT address = previous arg1</span><br><span class="line"> * destination FDT address = next arg1</span><br><span class="line"> *</span><br><span class="line"> * Note: We will preserve a0 and a1 passed by</span><br><span class="line"> * previous booting stage.</span><br><span class="line"> */</span><br><span class="line">beqza1, _fdt_reloc_done</span><br><span class="line">/* Mask values in a4 */</span><br><span class="line">lia4, 0xff</span><br><span class="line">/* t1 = destination FDT start address */</span><br><span class="line">MOV_3Rs0, a0, s1, a1, s2, a2</span><br><span class="line">callfw_next_arg1</span><br><span class="line">addt1, a0, zero</span><br><span class="line">MOV_3Ra0, s0, a1, s1, a2, s2</span><br><span class="line">beqzt1, _fdt_reloc_done</span><br><span class="line">beqt1, a1, _fdt_reloc_done</span><br><span class="line">/* t0 = source FDT start address */</span><br><span class="line">addt0, a1, zero</span><br><span class="line">/* t2 = source FDT size in big-endian */</span><br><span class="line">#if __riscv_xlen &gt; 32</span><br><span class="line">lwut2, 4(t0)</span><br><span class="line">#else</span><br><span class="line">lwt2, 4(t0)</span><br><span class="line">#endif</span><br><span class="line">/* t3 = bit[15:8] of FDT size */</span><br><span class="line">addt3, t2, zero</span><br><span class="line">srlit3, t3, 16</span><br><span class="line">andt3, t3, a4</span><br><span class="line">sllit3, t3, 8</span><br><span class="line">/* t4 = bit[23:16] of FDT size */</span><br><span class="line">addt4, t2, zero</span><br><span class="line">srlit4, t4, 8</span><br><span class="line">andt4, t4, a4</span><br><span class="line">sllit4, t4, 16</span><br><span class="line">/* t5 = bit[31:24] of FDT size */</span><br><span class="line">addt5, t2, zero</span><br><span class="line">andt5, t5, a4</span><br><span class="line">sllit5, t5, 24</span><br><span class="line">/* t2 = bit[7:0] of FDT size */</span><br><span class="line">srlit2, t2, 24</span><br><span class="line">andt2, t2, a4</span><br><span class="line">/* t2 = FDT size in little-endian */</span><br><span class="line">ort2, t2, t3</span><br><span class="line">ort2, t2, t4</span><br><span class="line">ort2, t2, t5</span><br><span class="line">/* t2 = destination FDT end address */</span><br><span class="line">addt2, t1, t2</span><br><span class="line">/* FDT copy loop */</span><br><span class="line">blet2, t1, _fdt_reloc_done</span><br><span class="line">_fdt_reloc_again:</span><br><span class="line">REG_Lt3, 0(t0)</span><br><span class="line">REG_St3, 0(t1)</span><br><span class="line">addt0, t0, __SIZEOF_POINTER__</span><br><span class="line">addt1, t1, __SIZEOF_POINTER__</span><br><span class="line">bltt1, t2, _fdt_reloc_again</span><br><span class="line">_fdt_reloc_done:</span><br><span class="line"></span><br><span class="line">/* mark boot hart done */</span><br><span class="line">lit0, BOOT_STATUS_BOOT_HART_DONE</span><br><span class="line">llat1, _boot_status</span><br><span class="line">fencerw, rw</span><br><span class="line">REG_St0, 0(t1)</span><br><span class="line">j_start_warm</span><br><span class="line"></span><br><span class="line">/* waiting for boot hart to be done (_boot_status == 2) */</span><br><span class="line">_wait_for_boot_hart: // 所有hart都执行，hart检查到boot_hart_done之后继续往后执行</span><br><span class="line">lit0, BOOT_STATUS_BOOT_HART_DONE</span><br><span class="line">llat1, _boot_status</span><br><span class="line">REG_Lt1, 0(t1)</span><br><span class="line">/* Reduce the bus traffic so that boot hart may proceed faster */</span><br><span class="line">divt2, t2, zero  // 不知道硬件会如何处理，从单步调试上看，没有任何变化t2=-1</span><br><span class="line">divt2, t2, zero</span><br><span class="line">divt2, t2, zero</span><br><span class="line">bnet0, t1, _wait_for_boot_hart</span><br><span class="line"></span><br><span class="line">_start_warm:</span><br><span class="line">/* Reset all registers except ra, a0, a1, a2, a3 and a4 for non-boot HART */</span><br><span class="line">lira, 0</span><br><span class="line">call_reset_regs</span><br><span class="line"></span><br><span class="line">/* Disable all interrupts */</span><br><span class="line">csrwCSR_MIE, zero</span><br><span class="line"></span><br><span class="line">/* Find HART count and HART stack size */</span><br><span class="line">llaa4, platform</span><br><span class="line">#if __riscv_xlen &gt; 32</span><br><span class="line">lwus7, SBI_PLATFORM_HART_COUNT_OFFSET(a4)</span><br><span class="line">lwus8, SBI_PLATFORM_HART_STACK_SIZE_OFFSET(a4)</span><br><span class="line">#else</span><br><span class="line">lws7, SBI_PLATFORM_HART_COUNT_OFFSET(a4)</span><br><span class="line">lws8, SBI_PLATFORM_HART_STACK_SIZE_OFFSET(a4)</span><br><span class="line">#endif</span><br><span class="line">/* index2id实际是根据设备树上的cpu生成的数组generic_hart_index2id，s9指向数组 */</span><br><span class="line">REG_Ls9, SBI_PLATFORM_HART_INDEX2ID_OFFSET(a4) // 不同hart返回不同id</span><br><span class="line"></span><br><span class="line">/* Find HART id */</span><br><span class="line">csrrs6, CSR_MHARTID</span><br><span class="line"></span><br><span class="line">/* Find HART index 判断数组是否存在 */</span><br><span class="line">beqzs9, 3f</span><br><span class="line">lia4, 0</span><br><span class="line">1:</span><br><span class="line">#if __riscv_xlen &gt; 32</span><br><span class="line">/* 从数组中取第一个元素 */</span><br><span class="line">lwua5, (s9)</span><br><span class="line">#else</span><br><span class="line">lwa5, (s9)</span><br><span class="line">#endif</span><br><span class="line">/* 判读hartid是否等于数组中的id */</span><br><span class="line">beqa5, s6, 2f</span><br><span class="line">/* generic_hart_index2id数组每个元素4Bytes, s9指向下一个index */</span><br><span class="line">adds9, s9, 4</span><br><span class="line">/* a4 保存 数组 index */</span><br><span class="line">adda4, a4, 1</span><br><span class="line">blta4, s7, 1b  // 对hart合法性进行检查，没遍历完则继续</span><br><span class="line">2:adds6, a4, zero  // s6原来保存hartid，现在保存index</span><br><span class="line">3:bges6, s7, _start_hang  // index 必须小于count数</span><br><span class="line"></span><br><span class="line">/* Find the scratch space based on HART index */</span><br><span class="line">llatp, _fw_end</span><br><span class="line">mula5, s7, s8  // s7=hart_count, s8=hart stack size</span><br><span class="line">addtp, tp, a5  //</span><br><span class="line">mula5, s8, s6</span><br><span class="line">subtp, tp, a5</span><br><span class="line">lia5, SBI_SCRATCH_SIZE</span><br><span class="line">subtp, tp, a5</span><br><span class="line"></span><br><span class="line">/* update the mscratch */</span><br><span class="line">csrwCSR_MSCRATCH, tp</span><br><span class="line">/* mscratch 和 sp值相同 */</span><br><span class="line">/* Setup stack */</span><br><span class="line">addsp, tp, zero</span><br><span class="line"></span><br><span class="line">/* Setup trap handler */</span><br><span class="line">llaa4, _trap_handler</span><br><span class="line">csrra5, CSR_MISA</span><br><span class="line">srlia5, a5, (&#x27;H&#x27; - &#x27;A&#x27;)</span><br><span class="line">andia5, a5, 0x1</span><br><span class="line">beqa5, zero, _skip_trap_handler_hyp</span><br><span class="line">llaa4, _trap_handler_hyp</span><br><span class="line">_skip_trap_handler_hyp:</span><br><span class="line">csrwCSR_MTVEC, a4</span><br><span class="line"></span><br><span class="line">/* Initialize SBI runtime */</span><br><span class="line">csrra0, CSR_MSCRATCH</span><br><span class="line">callsbi_init  // 所有hart进入C运行环境，不跳回到此处</span><br><span class="line"></span><br><span class="line">/* We don&#x27;t expect to reach here hence just hang */</span><br><span class="line">j_start_hang</span><br><span class="line"></span><br><span class="line">.data</span><br><span class="line">.align 3</span><br><span class="line">_boot_status:</span><br><span class="line">RISCV_PTR0</span><br><span class="line"></span><br><span class="line">.section .entry, &quot;ax&quot;, %progbits</span><br><span class="line">.align 3</span><br><span class="line">.globl _hartid_to_scratch</span><br><span class="line">_hartid_to_scratch:</span><br><span class="line">/*</span><br><span class="line"> * a0 -&gt; HART ID (passed by caller sbi_scratch_init)</span><br><span class="line"> * a1 -&gt; HART Index (passed by caller sbi_scratch_init)</span><br><span class="line"> * t0 -&gt; HART Stack Size</span><br><span class="line"> * t1 -&gt; HART Stack End</span><br><span class="line"> * t2 -&gt; Temporary</span><br><span class="line"> */</span><br><span class="line">llat2, platform</span><br><span class="line">#if __riscv_xlen &gt; 32</span><br><span class="line">/* 这里的hart stack是包含scratch和stack两部分 */</span><br><span class="line">lwut0, SBI_PLATFORM_HART_STACK_SIZE_OFFSET(t2)</span><br><span class="line">lwut2, SBI_PLATFORM_HART_COUNT_OFFSET(t2)</span><br><span class="line">#else</span><br><span class="line">lwt0, SBI_PLATFORM_HART_STACK_SIZE_OFFSET(t2)</span><br><span class="line">lwt2, SBI_PLATFORM_HART_COUNT_OFFSET(t2)</span><br><span class="line">#endif</span><br><span class="line">subt2, t2, a1</span><br><span class="line">mult2, t2, t0</span><br><span class="line">llat1, _fw_end</span><br><span class="line">addt1, t1, t2</span><br><span class="line">lit2, SBI_SCRATCH_SIZE</span><br><span class="line">suba0, t1, t2</span><br><span class="line">ret</span><br><span class="line"></span><br><span class="line">.section .entry, &quot;ax&quot;, %progbits</span><br><span class="line">.align 3</span><br><span class="line">.globl _start_hang</span><br><span class="line">_start_hang:</span><br><span class="line">wfi</span><br><span class="line">j_start_hang</span><br><span class="line"></span><br><span class="line">.section .entry, &quot;ax&quot;, %progbits</span><br><span class="line">.align 3</span><br><span class="line">.weak fw_platform_init</span><br><span class="line">fw_platform_init:</span><br><span class="line">adda0, a1, zero</span><br><span class="line">ret</span><br><span class="line"></span><br><span class="line">/* Map implicit memcpy() added by compiler to sbi_memcpy() */</span><br><span class="line">.section .text</span><br><span class="line">.align 3</span><br><span class="line">.globl memcpy</span><br><span class="line">memcpy:</span><br><span class="line">tailsbi_memcpy</span><br><span class="line"></span><br><span class="line">/* Map implicit memset() added by compiler to sbi_memset() */</span><br><span class="line">.section .text</span><br><span class="line">.align 3</span><br><span class="line">.globl memset</span><br><span class="line">memset:</span><br><span class="line">tailsbi_memset</span><br><span class="line"></span><br><span class="line">/* Map implicit memmove() added by compiler to sbi_memmove() */</span><br><span class="line">.section .text</span><br><span class="line">.align 3</span><br><span class="line">.globl memmove</span><br><span class="line">memmove:</span><br><span class="line">tailsbi_memmove</span><br><span class="line"></span><br><span class="line">/* Map implicit memcmp() added by compiler to sbi_memcmp() */</span><br><span class="line">.section .text</span><br><span class="line">.align 3</span><br><span class="line">.globl memcmp</span><br><span class="line">memcmp:</span><br><span class="line">tailsbi_memcmp</span><br><span class="line"></span><br><span class="line">.macroTRAP_SAVE_AND_SETUP_SP_T0</span><br><span class="line">/* Swap TP and MSCRATCH */</span><br><span class="line">csrrwtp, CSR_MSCRATCH, tp</span><br><span class="line"></span><br><span class="line">/* Save T0 in scratch space */</span><br><span class="line">REG_St0, SBI_SCRATCH_TMP0_OFFSET(tp)</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * Set T0 to appropriate exception stack</span><br><span class="line"> *</span><br><span class="line"> * Came_From_M_Mode = ((MSTATUS.MPP &lt; PRV_M) ? 1 : 0) - 1;</span><br><span class="line"> * Exception_Stack = TP ^ (Came_From_M_Mode &amp; (SP ^ TP))</span><br><span class="line"> *</span><br><span class="line"> * Came_From_M_Mode = 0    ==&gt;    Exception_Stack = TP</span><br><span class="line"> * Came_From_M_Mode = -1   ==&gt;    Exception_Stack = SP</span><br><span class="line"> */</span><br><span class="line">csrrt0, CSR_MSTATUS</span><br><span class="line">srlt0, t0, MSTATUS_MPP_SHIFT</span><br><span class="line">andt0, t0, PRV_M</span><br><span class="line">sltit0, t0, PRV_M</span><br><span class="line">addt0, t0, -1</span><br><span class="line">xorsp, sp, tp</span><br><span class="line">andt0, t0, sp</span><br><span class="line">xorsp, sp, tp</span><br><span class="line">xort0, tp, t0</span><br><span class="line"></span><br><span class="line">/* Save original SP on exception stack */</span><br><span class="line">REG_Ssp, (SBI_TRAP_REGS_OFFSET(sp) - SBI_TRAP_CONTEXT_SIZE)(t0)</span><br><span class="line"></span><br><span class="line">/* Set SP to exception stack and make room for trap context */</span><br><span class="line">addsp, t0, -(SBI_TRAP_CONTEXT_SIZE)</span><br><span class="line"></span><br><span class="line">/* Restore T0 from scratch space */</span><br><span class="line">REG_Lt0, SBI_SCRATCH_TMP0_OFFSET(tp)</span><br><span class="line"></span><br><span class="line">/* Save T0 on stack */</span><br><span class="line">REG_St0, SBI_TRAP_REGS_OFFSET(t0)(sp)</span><br><span class="line"></span><br><span class="line">/* Swap TP and MSCRATCH */</span><br><span class="line">csrrwtp, CSR_MSCRATCH, tp</span><br><span class="line">.endm</span><br><span class="line"></span><br><span class="line">.macroTRAP_SAVE_MEPC_MSTATUS have_mstatush</span><br><span class="line">/* Save MEPC and MSTATUS CSRs */</span><br><span class="line">csrrt0, CSR_MEPC</span><br><span class="line">REG_St0, SBI_TRAP_REGS_OFFSET(mepc)(sp)</span><br><span class="line">csrrt0, CSR_MSTATUS</span><br><span class="line">REG_St0, SBI_TRAP_REGS_OFFSET(mstatus)(sp)</span><br><span class="line">.if \have_mstatush</span><br><span class="line">csrrt0, CSR_MSTATUSH</span><br><span class="line">REG_St0, SBI_TRAP_REGS_OFFSET(mstatusH)(sp)</span><br><span class="line">.else</span><br><span class="line">REG_Szero, SBI_TRAP_REGS_OFFSET(mstatusH)(sp)</span><br><span class="line">.endif</span><br><span class="line">.endm</span><br><span class="line"></span><br><span class="line">.macroTRAP_SAVE_GENERAL_REGS_EXCEPT_SP_T0</span><br><span class="line">/* Save all general regisers except SP and T0 */</span><br><span class="line">REG_Szero, SBI_TRAP_REGS_OFFSET(zero)(sp)</span><br><span class="line">REG_Sra, SBI_TRAP_REGS_OFFSET(ra)(sp)</span><br><span class="line">REG_Sgp, SBI_TRAP_REGS_OFFSET(gp)(sp)</span><br><span class="line">REG_Stp, SBI_TRAP_REGS_OFFSET(tp)(sp)</span><br><span class="line">REG_St1, SBI_TRAP_REGS_OFFSET(t1)(sp)</span><br><span class="line">REG_St2, SBI_TRAP_REGS_OFFSET(t2)(sp)</span><br><span class="line">REG_Ss0, SBI_TRAP_REGS_OFFSET(s0)(sp)</span><br><span class="line">REG_Ss1, SBI_TRAP_REGS_OFFSET(s1)(sp)</span><br><span class="line">REG_Sa0, SBI_TRAP_REGS_OFFSET(a0)(sp)</span><br><span class="line">REG_Sa1, SBI_TRAP_REGS_OFFSET(a1)(sp)</span><br><span class="line">REG_Sa2, SBI_TRAP_REGS_OFFSET(a2)(sp)</span><br><span class="line">REG_Sa3, SBI_TRAP_REGS_OFFSET(a3)(sp)</span><br><span class="line">REG_Sa4, SBI_TRAP_REGS_OFFSET(a4)(sp)</span><br><span class="line">REG_Sa5, SBI_TRAP_REGS_OFFSET(a5)(sp)</span><br><span class="line">REG_Sa6, SBI_TRAP_REGS_OFFSET(a6)(sp)</span><br><span class="line">REG_Sa7, SBI_TRAP_REGS_OFFSET(a7)(sp)</span><br><span class="line">REG_Ss2, SBI_TRAP_REGS_OFFSET(s2)(sp)</span><br><span class="line">REG_Ss3, SBI_TRAP_REGS_OFFSET(s3)(sp)</span><br><span class="line">REG_Ss4, SBI_TRAP_REGS_OFFSET(s4)(sp)</span><br><span class="line">REG_Ss5, SBI_TRAP_REGS_OFFSET(s5)(sp)</span><br><span class="line">REG_Ss6, SBI_TRAP_REGS_OFFSET(s6)(sp)</span><br><span class="line">REG_Ss7, SBI_TRAP_REGS_OFFSET(s7)(sp)</span><br><span class="line">REG_Ss8, SBI_TRAP_REGS_OFFSET(s8)(sp)</span><br><span class="line">REG_Ss9, SBI_TRAP_REGS_OFFSET(s9)(sp)</span><br><span class="line">REG_Ss10, SBI_TRAP_REGS_OFFSET(s10)(sp)</span><br><span class="line">REG_Ss11, SBI_TRAP_REGS_OFFSET(s11)(sp)</span><br><span class="line">REG_St3, SBI_TRAP_REGS_OFFSET(t3)(sp)</span><br><span class="line">REG_St4, SBI_TRAP_REGS_OFFSET(t4)(sp)</span><br><span class="line">REG_St5, SBI_TRAP_REGS_OFFSET(t5)(sp)</span><br><span class="line">REG_St6, SBI_TRAP_REGS_OFFSET(t6)(sp)</span><br><span class="line">.endm</span><br><span class="line"></span><br><span class="line">.macroTRAP_SAVE_INFO have_mstatush have_h_extension</span><br><span class="line">csrrt0, CSR_MCAUSE</span><br><span class="line">REG_St0, (SBI_TRAP_REGS_SIZE + SBI_TRAP_INFO_OFFSET(cause))(sp)</span><br><span class="line">csrrt0, CSR_MTVAL</span><br><span class="line">REG_St0, (SBI_TRAP_REGS_SIZE + SBI_TRAP_INFO_OFFSET(tval))(sp)</span><br><span class="line">.if \have_h_extension</span><br><span class="line">csrrt0, CSR_MTVAL2</span><br><span class="line">REG_St0, (SBI_TRAP_REGS_SIZE + SBI_TRAP_INFO_OFFSET(tval2))(sp)</span><br><span class="line">csrrt0, CSR_MTINST</span><br><span class="line">REG_St0, (SBI_TRAP_REGS_SIZE + SBI_TRAP_INFO_OFFSET(tinst))(sp)</span><br><span class="line">.if \have_mstatush</span><br><span class="line">csrrt0, CSR_MSTATUSH</span><br><span class="line">srlit0, t0, MSTATUSH_GVA_SHIFT</span><br><span class="line">.else</span><br><span class="line">csrrt0, CSR_MSTATUS</span><br><span class="line">srlit0, t0, MSTATUS_GVA_SHIFT</span><br><span class="line">.endif</span><br><span class="line">andt0, t0, 0x1</span><br><span class="line">.else</span><br><span class="line">REG_Szero, (SBI_TRAP_REGS_SIZE + SBI_TRAP_INFO_OFFSET(tval2))(sp)</span><br><span class="line">REG_Szero, (SBI_TRAP_REGS_SIZE + SBI_TRAP_INFO_OFFSET(tinst))(sp)</span><br><span class="line">lit0, 0</span><br><span class="line">.endif</span><br><span class="line">REG_St0, (SBI_TRAP_REGS_SIZE + SBI_TRAP_INFO_OFFSET(gva))(sp)</span><br><span class="line">.endm</span><br><span class="line"></span><br><span class="line">.macroTRAP_CALL_C_ROUTINE</span><br><span class="line">/* Call C routine */</span><br><span class="line">adda0, sp, zero</span><br><span class="line">callsbi_trap_handler</span><br><span class="line">.endm</span><br><span class="line"></span><br><span class="line">.macroTRAP_RESTORE_GENERAL_REGS_EXCEPT_A0_T0</span><br><span class="line">/* Restore all general regisers except A0 and T0 */</span><br><span class="line">REG_Lra, SBI_TRAP_REGS_OFFSET(ra)(a0)</span><br><span class="line">REG_Lsp, SBI_TRAP_REGS_OFFSET(sp)(a0)</span><br><span class="line">REG_Lgp, SBI_TRAP_REGS_OFFSET(gp)(a0)</span><br><span class="line">REG_Ltp, SBI_TRAP_REGS_OFFSET(tp)(a0)</span><br><span class="line">REG_Lt1, SBI_TRAP_REGS_OFFSET(t1)(a0)</span><br><span class="line">REG_Lt2, SBI_TRAP_REGS_OFFSET(t2)(a0)</span><br><span class="line">REG_Ls0, SBI_TRAP_REGS_OFFSET(s0)(a0)</span><br><span class="line">REG_Ls1, SBI_TRAP_REGS_OFFSET(s1)(a0)</span><br><span class="line">REG_La1, SBI_TRAP_REGS_OFFSET(a1)(a0)</span><br><span class="line">REG_La2, SBI_TRAP_REGS_OFFSET(a2)(a0)</span><br><span class="line">REG_La3, SBI_TRAP_REGS_OFFSET(a3)(a0)</span><br><span class="line">REG_La4, SBI_TRAP_REGS_OFFSET(a4)(a0)</span><br><span class="line">REG_La5, SBI_TRAP_REGS_OFFSET(a5)(a0)</span><br><span class="line">REG_La6, SBI_TRAP_REGS_OFFSET(a6)(a0)</span><br><span class="line">REG_La7, SBI_TRAP_REGS_OFFSET(a7)(a0)</span><br><span class="line">REG_Ls2, SBI_TRAP_REGS_OFFSET(s2)(a0)</span><br><span class="line">REG_Ls3, SBI_TRAP_REGS_OFFSET(s3)(a0)</span><br><span class="line">REG_Ls4, SBI_TRAP_REGS_OFFSET(s4)(a0)</span><br><span class="line">REG_Ls5, SBI_TRAP_REGS_OFFSET(s5)(a0)</span><br><span class="line">REG_Ls6, SBI_TRAP_REGS_OFFSET(s6)(a0)</span><br><span class="line">REG_Ls7, SBI_TRAP_REGS_OFFSET(s7)(a0)</span><br><span class="line">REG_Ls8, SBI_TRAP_REGS_OFFSET(s8)(a0)</span><br><span class="line">REG_Ls9, SBI_TRAP_REGS_OFFSET(s9)(a0)</span><br><span class="line">REG_Ls10, SBI_TRAP_REGS_OFFSET(s10)(a0)</span><br><span class="line">REG_Ls11, SBI_TRAP_REGS_OFFSET(s11)(a0)</span><br><span class="line">REG_Lt3, SBI_TRAP_REGS_OFFSET(t3)(a0)</span><br><span class="line">REG_Lt4, SBI_TRAP_REGS_OFFSET(t4)(a0)</span><br><span class="line">REG_Lt5, SBI_TRAP_REGS_OFFSET(t5)(a0)</span><br><span class="line">REG_Lt6, SBI_TRAP_REGS_OFFSET(t6)(a0)</span><br><span class="line">.endm</span><br><span class="line"></span><br><span class="line">.macroTRAP_RESTORE_MEPC_MSTATUS have_mstatush</span><br><span class="line">/* Restore MEPC and MSTATUS CSRs */</span><br><span class="line">REG_Lt0, SBI_TRAP_REGS_OFFSET(mepc)(a0)</span><br><span class="line">csrwCSR_MEPC, t0</span><br><span class="line">REG_Lt0, SBI_TRAP_REGS_OFFSET(mstatus)(a0)</span><br><span class="line">csrwCSR_MSTATUS, t0</span><br><span class="line">.if \have_mstatush</span><br><span class="line">REG_Lt0, SBI_TRAP_REGS_OFFSET(mstatusH)(a0)</span><br><span class="line">csrwCSR_MSTATUSH, t0</span><br><span class="line">.endif</span><br><span class="line">.endm</span><br><span class="line"></span><br><span class="line">.macro TRAP_RESTORE_A0_T0</span><br><span class="line">/* Restore T0 */</span><br><span class="line">REG_Lt0, SBI_TRAP_REGS_OFFSET(t0)(a0)</span><br><span class="line"></span><br><span class="line">/* Restore A0 */</span><br><span class="line">REG_La0, SBI_TRAP_REGS_OFFSET(a0)(a0)</span><br><span class="line">.endm</span><br><span class="line"></span><br><span class="line">.section .entry, &quot;ax&quot;, %progbits</span><br><span class="line">.align 3</span><br><span class="line">.globl _trap_handler</span><br><span class="line">_trap_handler:</span><br><span class="line">TRAP_SAVE_AND_SETUP_SP_T0</span><br><span class="line"></span><br><span class="line">TRAP_SAVE_MEPC_MSTATUS 0</span><br><span class="line"></span><br><span class="line">TRAP_SAVE_GENERAL_REGS_EXCEPT_SP_T0</span><br><span class="line"></span><br><span class="line">TRAP_SAVE_INFO 0 0</span><br><span class="line"></span><br><span class="line">TRAP_CALL_C_ROUTINE</span><br><span class="line"></span><br><span class="line">TRAP_RESTORE_GENERAL_REGS_EXCEPT_A0_T0</span><br><span class="line"></span><br><span class="line">TRAP_RESTORE_MEPC_MSTATUS 0</span><br><span class="line"></span><br><span class="line">TRAP_RESTORE_A0_T0</span><br><span class="line"></span><br><span class="line">mret</span><br><span class="line"></span><br><span class="line">.section .entry, &quot;ax&quot;, %progbits</span><br><span class="line">.align 3</span><br><span class="line">.globl _trap_handler_hyp</span><br><span class="line">_trap_handler_hyp:</span><br><span class="line">TRAP_SAVE_AND_SETUP_SP_T0</span><br><span class="line"></span><br><span class="line">#if __riscv_xlen == 32</span><br><span class="line">TRAP_SAVE_MEPC_MSTATUS 1</span><br><span class="line">#else</span><br><span class="line">TRAP_SAVE_MEPC_MSTATUS 0</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">TRAP_SAVE_GENERAL_REGS_EXCEPT_SP_T0</span><br><span class="line"></span><br><span class="line">#if __riscv_xlen == 32</span><br><span class="line">TRAP_SAVE_INFO 1 1</span><br><span class="line">#else</span><br><span class="line">TRAP_SAVE_INFO 0 1</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">TRAP_CALL_C_ROUTINE</span><br><span class="line"></span><br><span class="line">TRAP_RESTORE_GENERAL_REGS_EXCEPT_A0_T0</span><br><span class="line"></span><br><span class="line">#if __riscv_xlen == 32</span><br><span class="line">TRAP_RESTORE_MEPC_MSTATUS 1</span><br><span class="line">#else</span><br><span class="line">TRAP_RESTORE_MEPC_MSTATUS 0</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">TRAP_RESTORE_A0_T0</span><br><span class="line"></span><br><span class="line">mret</span><br><span class="line"></span><br><span class="line">.section .entry, &quot;ax&quot;, %progbits</span><br><span class="line">.align 3</span><br><span class="line">.globl _reset_regs</span><br><span class="line">_reset_regs:</span><br><span class="line"></span><br><span class="line">/* flush the instruction cache */</span><br><span class="line">fence.i</span><br><span class="line">/* Reset all registers except ra, a0, a1, a2, a3 and a4 */</span><br><span class="line">li sp, 0</span><br><span class="line">li gp, 0</span><br><span class="line">li tp, 0</span><br><span class="line">li t0, 0</span><br><span class="line">li t1, 0</span><br><span class="line">li t2, 0</span><br><span class="line">li s0, 0</span><br><span class="line">li s1, 0</span><br><span class="line">li a5, 0</span><br><span class="line">li a6, 0</span><br><span class="line">li a7, 0</span><br><span class="line">li s2, 0</span><br><span class="line">li s3, 0</span><br><span class="line">li s4, 0</span><br><span class="line">li s5, 0</span><br><span class="line">li s6, 0</span><br><span class="line">li s7, 0</span><br><span class="line">li s8, 0</span><br><span class="line">li s9, 0</span><br><span class="line">li s10, 0</span><br><span class="line">li s11, 0</span><br><span class="line">li t3, 0</span><br><span class="line">li t4, 0</span><br><span class="line">li t5, 0</span><br><span class="line">li t6, 0</span><br><span class="line">csrw CSR_MSCRATCH, 0</span><br><span class="line"></span><br><span class="line">ret</span><br><span class="line"></span><br><span class="line">#ifdef FW_FDT_PATH</span><br><span class="line">.section .rodata</span><br><span class="line">.align 4</span><br><span class="line">.globl fw_fdt_bin</span><br><span class="line">fw_fdt_bin:  // 将dtb二进制文件在此处展开，incbin</span><br><span class="line">.incbin FW_FDT_PATH</span><br><span class="line">#ifdef FW_FDT_PADDING</span><br><span class="line">.fill FW_FDT_PADDING, 1, 0</span><br><span class="line">#endif</span><br><span class="line">#endif</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="重定位"><a href="#重定位" class="headerlink" title="重定位"></a>重定位</h2><p>参考：<a href="https://blog.csdn.net/dai_xiangjun/article/details/123629743">https://blog.csdn.net/dai_xiangjun/article/details/123629743</a><br>将固件的所有段打印出来，Address表示固件中的地址，Off表示elf中的位置。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">riscv64-elf-readelf -SW build/platform/generic/firmware/fw_payload.elf</span><br><span class="line">There are 27 section headers, starting at offset 0x1b6ab8:</span><br><span class="line"></span><br><span class="line">Section Headers:</span><br><span class="line">  [Nr] Name              Type            Address          Off    Size   ES Flg Lk Inf Al</span><br><span class="line">  [ 0]                   NULL            0000000000000000 000000 000000 00      0   0  0</span><br><span class="line">  [ 1] .text             PROGBITS        0000000080000000 001000 01f1a0 00  AX  0   0 16</span><br><span class="line">  [ 2] .rodata           PROGBITS        0000000080020000 021000 002bf0 00 AMS  0   0  8</span><br><span class="line">  [ 3] .dynsym           DYNSYM          0000000080022bf0 023bf0 000018 18   A  7   1  8</span><br><span class="line">  [ 4] .rela.dyn         RELA            0000000080023000 024000 002c88 18   A  3   0  8</span><br><span class="line">  [ 5] .gnu.hash         GNU_HASH        0000000080025c88 026c88 00001c 00   A  3   0  8</span><br><span class="line">  [ 6] .<span class="built_in">hash</span>             HASH            0000000080025ca4 026ca4 000010 04   A  3   0  4</span><br><span class="line">  [ 7] .dynstr           STRTAB          0000000080025cb4 026cb4 000001 00   A  0   0  1</span><br><span class="line">  [ 8] .dynamic          DYNAMIC         0000000080025cb8 026cb8 0000d0 10  WA  7   0  8</span><br><span class="line">  [ 9] .got              PROGBITS        0000000080025d88 026d88 000108 00  WA  0   0  8</span><br><span class="line">  [10] .data             PROGBITS        0000000080040000 027000 002620 00  WA  0   0  8</span><br><span class="line">  [11] .htif             PROGBITS        0000000080042620 029620 000010 00  WA  0   0  8</span><br><span class="line">  [12] .bss              NOBITS          0000000080043000 029630 002fe8 00  WA  0   0  8</span><br><span class="line">  [13] .payload          PROGBITS        0000000080200000 02a000 002018 00  AX  0   0 16</span><br><span class="line">  [14] .riscv.attributes RISCV_ATTRIBUTES 0000000000000000 02c018 00003e 00      0   0  1</span><br><span class="line">  [15] .debug_info       PROGBITS        0000000000000000 02c056 0564da 00      0   0  1</span><br><span class="line">  [16] .debug_abbrev     PROGBITS        0000000000000000 082530 00e820 00      0   0  1</span><br><span class="line">  [17] .debug_aranges    PROGBITS        0000000000000000 090d50 000130 00      0   0  1</span><br><span class="line">  [18] .debug_ranges     PROGBITS        0000000000000000 090e80 003d30 00      0   0  1</span><br><span class="line">  [19] .debug_line       PROGBITS        0000000000000000 094bb0 0360e5 00      0   0  1</span><br><span class="line">  [20] .debug_loc        PROGBITS        0000000000000000 0cac95 03bcf3 00      0   0  1</span><br><span class="line">  [21] .debug_str        PROGBITS        0000000000000000 106988 00d254 01  MS  0   0  1</span><br><span class="line">  [22] .comment          PROGBITS        0000000000000000 113bdc 00003b 01  MS  0   0  1</span><br><span class="line">  [23] .debug_frame      PROGBITS        0000000000000000 113c18 0082f8 00      0   0  8</span><br><span class="line">  [24] .symtab           SYMTAB          0000000000000000 11bf10 0936a8 18     26 24582  8</span><br><span class="line">  [25] .shstrtab         STRTAB          0000000000000000 1af5b8 0000fc 00      0   0  1</span><br><span class="line">  [26] .strtab           STRTAB          0000000000000000 1af6b4 007400 00      0   0  1</span><br><span class="line">Key to Flags:</span><br><span class="line">  W (write), A (alloc), X (execute), M (merge), S (strings), I (info),</span><br><span class="line">  L (<span class="built_in">link</span> order), O (extra OS processing required), G (group), T (TLS),</span><br><span class="line">  C (compressed), x (unknown), o (OS specific), E (exclude),</span><br><span class="line">  D (mbind), p (processor specific)</span><br></pre></td></tr></table></figure><p>将<code>.rela.dyn</code>段从elf中取出来，</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">xxd -s 0x24000 -l 0x2c88 build/platform/generic/firmware/fw_payload.elf</span><br><span class="line">00024000: 905d 0280 0000 0000 0300 0000 0000 0000  .]..............</span><br><span class="line">00024010: 8005 0480 0000 0000 985d 0280 0000 0000  .........]......</span><br><span class="line">00024020: 0300 0000 0000 0000 1000 0480 0000 0000  ................</span><br><span class="line">00024030: a05d 0280 0000 0000 0300 0000 0000 0000  .]..............</span><br><span class="line">00024040: d000 0480 0000 0000 a85d 0280 0000 0000  .........]......</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解析上述数据</span></span><br><span class="line">riscv64-elf-readelf -rW build/platform/generic/firmware/fw_payload.elf</span><br><span class="line"></span><br><span class="line">Relocation section <span class="string">&#x27;.rela.dyn&#x27;</span> at offset 0x24000 contains 475 entries:</span><br><span class="line">    Offset             Info             Type               Symbol<span class="string">&#x27;s Value  Symbol&#x27;</span>s Name + Addend</span><br><span class="line">0000000080025d90  0000000000000003 R_RISCV_RELATIVE                          80040580</span><br><span class="line">0000000080025d98  0000000000000003 R_RISCV_RELATIVE                          80040010</span><br><span class="line">0000000080025da0  0000000000000003 R_RISCV_RELATIVE                          800400d0</span><br><span class="line">0000000080025da8  0000000000000003 R_RISCV_RELATIVE                          800416f8</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Elf64_Addr    r_offset;               <span class="comment">/* Address */</span></span><br><span class="line">  Elf64_Xword   r_info;                 <span class="comment">/* Relocation type and symbol index */</span></span><br><span class="line">  Elf64_Sxword  r_addend;               <span class="comment">/* Addend */</span></span><br><span class="line">&#125; Elf64_Rela;</span><br></pre></td></tr></table></figure><p>结合汇编代码，重定位实际是将addend值存入Offset地址。</p><h2 id="scratch"><a href="#scratch" class="headerlink" title="scratch"></a>scratch</h2><p>_fw_end结束后紧跟stack和scratch空间，分别是hartN stack, hartN scratch, hartN-1 stack, hartN-1 scratch, …<br>platform中的hartid在platform初始化是更新，scratch中hartid是更加hartcount计算得到。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sbi_scratch</span> &#123;</span></span><br><span class="line"><span class="comment">/** Start (or base) address of firmware linked to OpenSBI library */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> fw_start; <span class="comment">// FW_TEXT_START</span></span><br><span class="line"><span class="comment">/** Size (in bytes) of firmware linked to OpenSBI library */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> fw_size; <span class="comment">// 包括heap之后的大小</span></span><br><span class="line"><span class="comment">/** Offset (in bytes) of the R/W section */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> fw_rw_offset;</span><br><span class="line"><span class="comment">/** Offset (in bytes) of the heap area */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> fw_heap_offset;</span><br><span class="line"><span class="comment">/** Size (in bytes) of the heap area */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> fw_heap_size;</span><br><span class="line"><span class="comment">/** Arg1 (or &#x27;a1&#x27; register) of next booting stage for this HART */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> next_arg1; <span class="comment">// payload的FDT地址</span></span><br><span class="line"><span class="comment">/** Address of next booting stage for this HART */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> next_addr; <span class="comment">// payload的地址</span></span><br><span class="line"><span class="comment">/** Privilege mode of next booting stage for this HART */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> next_mode; <span class="comment">// s-mode</span></span><br><span class="line"><span class="comment">/** Warm boot entry point address for this HART */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> warmboot_addr; <span class="comment">// &amp;_start_warn</span></span><br><span class="line"><span class="comment">/** Address of sbi_platform */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> platform_addr; <span class="comment">// &amp;platform, 结构体地址</span></span><br><span class="line"><span class="comment">/** Address of HART ID to sbi_scratch conversion function */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> hartid_to_scratch;   <span class="comment">// &amp;_hartid_to_scratch</span></span><br><span class="line"><span class="comment">/** Address of current trap context */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> trap_context; <span class="comment">// =0</span></span><br><span class="line"><span class="comment">/** Temporary storage */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> tmp0;         <span class="comment">// =0</span></span><br><span class="line"><span class="comment">/** Options for OpenSBI library */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> options;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文主要以调试记录为主，理解更多细节后再结合参考文档进行理解。尽量先以单hart单步调试，然后再用多hart调试。</p>]]></content>
      
      
      <categories>
          
          <category> opensbi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> boot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Devicetree</title>
      <link href="/2024/06/03/Devicetree/"/>
      <url>/2024/06/03/Devicetree/</url>
      
        <content type="html"><![CDATA[<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="https://www.devicetree.org/specifications">Devicetree specification</a><br><a href="https://github.com/Sunrisepeak/devicetree-specification-chinese">devicetree-specification-chinese</a>  </p><p>以下分2步学习设备树：</p><ol><li>学习基本语法，主要以阅读spec为主，结合dts文件进行学习；</li><li>解析dtb文件，结合spec分析dtb文件；</li><li>最后以raspi4b.dts文件的阅读检验学习成果，分析开发板的硬件结构；</li></ol><h1 id="获取dts文件"><a href="#获取dts文件" class="headerlink" title="获取dts文件"></a>获取dts文件</h1><p>直接从linux kernel获取dts文件<code>arch/arm/boot/dts/broadcom/bcm2711-rpi-4-b.dts</code>获取。注意这种方式获取的文件比较零散，不容易看到全茂。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">生成dtb，dts</span></span><br><span class="line">qemu-system-riscv64 -machine virt,dumpdtb=virt.dtb</span><br><span class="line">dtc -I dtb -O dts -o virt.dts virt.dtb</span><br></pre></td></tr></table></figure><h1 id="基本语法学习"><a href="#基本语法学习" class="headerlink" title="基本语法学习"></a>基本语法学习</h1><p>直接学习spec</p><h1 id="dtb解析"><a href="#dtb解析" class="headerlink" title="dtb解析"></a>dtb解析</h1><p>相关知识参考spec第5章。<br>设备树按8字节对齐，非对齐填0.<br>opensbi fw_platform_init 是对dtb关于platform解析的代码，可调试学习。<br><img src="/devicetree_dtb1.jpg"><br>按照spec第5章的定义，可以对dtb数据进行解析，第一部分是header，如绿色部分；第二部分为memory reservation, 从地址0x28到0x37;第三部分从0x38开始，到下一张图的0x14B3;第四部分为strings block, 从0x14B4到结束。<br><img src="/devicetree_dtb2.jpg">  </p><h2 id="Header"><a href="#Header" class="headerlink" title="Header"></a>Header</h2><p>将上图中的header数据按大端格式与结构体一一对应就能得到每个成员的值，如下，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fdt_header</span> &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> magic;                 <span class="comment">// 0xD00DFEED</span></span><br><span class="line">    <span class="type">uint32_t</span> totalsize;             <span class="comment">// 0x00001666</span></span><br><span class="line">    <span class="type">uint32_t</span> off_dt_struct;         <span class="comment">// 0x00000038</span></span><br><span class="line">    <span class="type">uint32_t</span> off_dt_strings;        <span class="comment">// 0x000014B4</span></span><br><span class="line">    <span class="type">uint32_t</span> off_mem_rsvmap;        <span class="comment">// 0x00000028</span></span><br><span class="line">    <span class="type">uint32_t</span> version;               <span class="comment">// 0x00000011</span></span><br><span class="line">    <span class="type">uint32_t</span> last_comp_version;     <span class="comment">// 0x00000010</span></span><br><span class="line">    <span class="type">uint32_t</span> boot_cpuid_phys;       <span class="comment">// 0x00000000</span></span><br><span class="line">    <span class="type">uint32_t</span> size_dt_strings;       <span class="comment">// 0x000001B2</span></span><br><span class="line">    <span class="type">uint32_t</span> size_dt_struct;        <span class="comment">// 0x0000147C</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Memory-Reservation-Block"><a href="#Memory-Reservation-Block" class="headerlink" title="Memory Reservation Block"></a>Memory Reservation Block</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// align 8</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fdt_reserve_entry</span> &#123;</span></span><br><span class="line">    <span class="type">uint64_t</span> address;               <span class="comment">// 0x00000000</span></span><br><span class="line">    <span class="type">uint64_t</span> size;                  <span class="comment">// 0x00000000</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Structure-Block"><a href="#Structure-Block" class="headerlink" title="Structure Block"></a>Structure Block</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// node start</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FDT_BEGIN_NODE  0x00000001</span></span><br><span class="line"><span class="comment">// node end</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FDT_END_NODE    0x00000002</span></span><br><span class="line"><span class="comment">// beginning of one property in the devicetree,</span></span><br><span class="line"><span class="comment">// it shall be followed by extra data describing</span></span><br><span class="line"><span class="comment">// the property</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FDT_PROP        0x00000003</span></span><br><span class="line"><span class="comment">// the extra data strcuture</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> len;</span><br><span class="line">    <span class="type">uint32_t</span> nameoff;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在opensbi中，上述结构体定义实际包含了FDT_XXX宏定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> tag;</span><br><span class="line">    <span class="type">uint32_t</span> len;</span><br><span class="line">    <span class="type">uint32_t</span> nameoff;</span><br><span class="line">    <span class="type">char</span> data[<span class="number">0</span>];   <span class="comment">// 此处为变长数组定义，不占内存空间，sizeof = 12</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ignored by any program</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FDT_NOP         0x00000004</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FDT_END         0x00000009</span></span><br></pre></td></tr></table></figure><p>如图中红色部分，0x38地址出现<code>FDT_BEGIN_NODE</code>,随后由于8字节对齐，填充了4字节0. <code>FDT_PROP</code>开始后紧接<code>len</code>和<code>nameoff</code>,<code>len</code>表示属性的值使用多少个字节表示，<code>nameoff</code>则表示属性名称在strings block中的偏移位置，如此处<code>nameoff=0x0000001D</code>,则属性名称开始位置<code>nameoff + off_dt_strings = 0x0000001D + 0x000014b4 = 0x000014D1</code>,从图上找到该处<code>#address-cells</code>,结合<code>len</code>指定的值<code>0x00000002</code>就可以得到该属性。（由于<code>FDT_BEGIN_NODE</code>后没有节点名，可以认为是根节点？因为其他节点都有名称。）</p><h2 id="Strings-Block"><a href="#Strings-Block" class="headerlink" title="Strings Block"></a>Strings Block</h2><p>该Block全由属性名组成，不同节点相同的属性名只出现一次。属性名以’\0’结尾。</p><h1 id="dts解析"><a href="#dts解析" class="headerlink" title="dts解析"></a>dts解析</h1><p><code>bcm2711-rpi-4-b.dts</code>引用<code>bcm2711.dtsi</code>，后者引用<code>bcm283x.dtsi</code></p><p>以下解析dts的部分内容，效果并不是很好，后续补上virt.dts的，尽量将整个SOC结构画出来。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* 定义根节点 */</span></span><br><span class="line">/ &#123;</span><br><span class="line">compatible = <span class="string">&quot;brcm,bcm2835&quot;</span>;<span class="comment">/* 节点的名称，推荐制造商+型号 */</span></span><br><span class="line">model = <span class="string">&quot;BCM2835&quot;</span>;<span class="comment">/* 设备型号，推荐制造商+型号 */</span></span><br><span class="line"><span class="meta">#address-cells = <span class="string">&lt;1&gt;</span>;<span class="comment">/* 节点中reg地址需要多少个u32表示，这里为1个u32 */</span></span></span><br><span class="line"><span class="meta">#size-cells = <span class="string">&lt;1&gt;</span>;<span class="comment">/* 节点中reg的值需要多少个u32表示 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 定义别名 */</span></span><br><span class="line">aliases &#123;</span><br><span class="line">serial0 = &amp;uart0;<span class="comment">/* uart0别名为serial0 */</span></span><br><span class="line">serial1 = &amp;uart1;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 定义chosen节点，用于传递输入参数 */</span></span><br><span class="line">chosen &#123;</span><br><span class="line"><span class="built_in">stdout</span>-path = <span class="string">&quot;serial0:115200n8&quot;</span>;<span class="comment">/* 指定控制台输入输出设备，输入设备省略时，表示输入输出都是此设备 */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 定义reserved-memory节点 */</span></span><br><span class="line">rmem: reserved-memory &#123;</span><br><span class="line"><span class="meta">#address-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line"><span class="meta">#size-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line">ranges;<span class="comment">/* 子节点地址空间和父地址空间映射方式，为空表示直接映射 */</span></span><br><span class="line"></span><br><span class="line">cma: linux,cma &#123;</span><br><span class="line">compatible = <span class="string">&quot;shared-dma-pool&quot;</span>;<span class="comment">/* 当驱动程序需要申请DMA空间时，可以从这里申请 */</span></span><br><span class="line">size = &lt;<span class="number">0x4000000</span>&gt;; <span class="comment">/* 64MB */</span></span><br><span class="line">reusable;<span class="comment">/* 当驱动程序不使用这段内存时，OS可以使用 */</span></span><br><span class="line">linux,cma-<span class="keyword">default</span>;<span class="comment">/* 该段保留空间是默认的CMA内存池 */</span></span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">thermal-zones &#123;</span><br><span class="line">cpu_thermal: cpu-thermal &#123;</span><br><span class="line">polling-delay-passive = &lt;<span class="number">0</span>&gt;;</span><br><span class="line">polling-delay = &lt;<span class="number">1000</span>&gt;;</span><br><span class="line"></span><br><span class="line">trips &#123;</span><br><span class="line">cpu-crit &#123;</span><br><span class="line">temperature = &lt;<span class="number">90000</span>&gt;;</span><br><span class="line">hysteresis = &lt;<span class="number">0</span>&gt;;</span><br><span class="line">type = <span class="string">&quot;critical&quot;</span>;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">cooling-maps &#123;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">soc &#123;</span><br><span class="line">compatible = <span class="string">&quot;simple-bus&quot;</span>;</span><br><span class="line"><span class="meta">#address-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line"><span class="meta">#size-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 系统时钟节点，reg在地址0x7e00_3000处 */</span></span><br><span class="line">system_timer: timer@<span class="number">7e003000</span> &#123;</span><br><span class="line">compatible = <span class="string">&quot;brcm,bcm2835-system-timer&quot;</span>;</span><br><span class="line">reg = &lt;<span class="number">0x7e003000</span> <span class="number">0x1000</span>&gt;;<span class="comment">/* u32表示，offset，size */</span></span><br><span class="line">interrupts = &lt;<span class="number">1</span> <span class="number">0</span>&gt;, &lt;<span class="number">1</span> <span class="number">1</span>&gt;, &lt;<span class="number">1</span> <span class="number">2</span>&gt;, &lt;<span class="number">1</span> <span class="number">3</span>&gt;;<span class="comment">/* 在父级中偏移为1，触发方式0，1,2,3 */</span></span><br><span class="line"><span class="comment">/* This could be a reference to BCM2835_CLOCK_TIMER,</span></span><br><span class="line"><span class="comment"> * but we don&#x27;t have the driver using the common clock</span></span><br><span class="line"><span class="comment"> * support yet.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">clock-frequency = &lt;<span class="number">1000000</span>&gt;;<span class="comment">/* 1MHz clock */</span></span><br><span class="line">&#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> devicetree </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FDT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo常用命令</title>
      <link href="/2023/01/19/Hexo%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>/2023/01/19/Hexo%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="新建博文"><a href="#新建博文" class="headerlink" title="新建博文"></a>新建博文</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜  Blog git:(master) ✗ hexo new Hexo常用命令</span><br><span class="line">INFO  Created: ~/Blog/source/_posts/2023-01-19-Hexo常用命令.md</span><br></pre></td></tr></table></figure><h1 id="使用布局新建博文"><a href="#使用布局新建博文" class="headerlink" title="使用布局新建博文"></a>使用布局新建博文</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜  Blog git:(master) ✗ hexo new post Hexo常用命令 # 默认布局page.md</span><br><span class="line">INFO  Created: ~/Blog/source/_posts/2023-01-19-Hexo常用命令.md</span><br></pre></td></tr></table></figure><p><code>post</code>在scaffolds中，修改布局在post.md中修改即可。<br><img src="/post.png"></p><h1 id="新建草稿"><a href="#新建草稿" class="headerlink" title="新建草稿"></a>新建草稿</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜  Blog git:(master) ✗ hexo new draft &quot;112&quot;      </span><br><span class="line">INFO  Created: ~/Blog/source/_drafts/112.md</span><br></pre></td></tr></table></figure><h1 id="草稿发布"><a href="#草稿发布" class="headerlink" title="草稿发布"></a>草稿发布</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜  Blog git:(master) ✗ hexo publish 112    </span><br><span class="line">INFO  Published: ~/Blog/source/_posts/2023-01-19-112.md</span><br></pre></td></tr></table></figure><h1 id="本地查看效果"><a href="#本地查看效果" class="headerlink" title="本地查看效果"></a>本地查看效果</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">➜  Blog git:(master) ✗ hexo s          </span><br><span class="line">INFO  Start processing</span><br><span class="line">Version 9 of Highlight.js has reached EOL and is no longer supported.</span><br><span class="line">Please upgrade or ask whatever dependency you are using to upgrade.</span><br><span class="line">https://github.com/highlightjs/highlight.js/issues/2877</span><br><span class="line">INFO  Hexo is running at http://localhost:4000 . Press Ctrl+C to stop.</span><br></pre></td></tr></table></figure><h1 id="生成并部署"><a href="#生成并部署" class="headerlink" title="生成并部署"></a>生成并部署</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">➜  Blog git:(master) ✗ hexo g -d</span><br><span class="line">INFO  Start processing</span><br><span class="line">INFO  Files loaded in 554 ms</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">INFO  Generated: 2023/01/19/Hexo常用命令/index.html</span><br><span class="line">INFO  Generated: tags/hexo/index.html</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">INFO  Deploy done: git</span><br></pre></td></tr></table></figure><h1 id="最后需要到gitee更新"><a href="#最后需要到gitee更新" class="headerlink" title="最后需要到gitee更新"></a>最后需要到gitee更新</h1>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>QEMU自制操作系统</title>
      <link href="/2023/01/19/qemu%E8%87%AA%E5%88%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
      <url>/2023/01/19/qemu%E8%87%AA%E5%88%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="关于操作系统的优秀教程"><a href="#关于操作系统的优秀教程" class="headerlink" title="关于操作系统的优秀教程"></a>关于操作系统的优秀教程</h1><p>MIT课程<a href="https://pdos.csail.mit.edu/6.828/2022/schedule.html">https://pdos.csail.mit.edu/6.828/2022/schedule.html</a><br>针对上述课程的博文<a href="https://zhuanlan.zhihu.com/p/74028717">MIT6.828-神级OS课程-要是早遇到，我还会是这种 five 系列</a>，注意博文对象是2018年版本，上述课程是2022年版本，针对riscv.<br>上述课程提供的书籍<a href="https://pdos.csail.mit.edu/6.828/2018/xv6/book-rev10.pdf">“book-rev10.pdf,2017,x86”</a>,  <a href="https://pdos.csail.mit.edu/6.828/2022/xv6/book-riscv-rev3.pdf">“book-riscv-rev3.pdf,2022”</a><br>中文译本<a href="https://th0ar.gitbooks.io/xv6-chinese/content/">xv6 中文文档, x86.</a>  </p><h1 id="查看qemu支持的平台"><a href="#查看qemu支持的平台" class="headerlink" title="查看qemu支持的平台"></a>查看qemu支持的平台</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">qemu-system-riscv64 -M <span class="built_in">help</span></span>                                    </span><br><span class="line">Supported machines are:</span><br><span class="line">microchip-icicle-kit Microchip PolarFire SoC Icicle Kit</span><br><span class="line">none                 empty machine</span><br><span class="line">shakti_c             RISC-V Board compatible with Shakti SDK</span><br><span class="line">sifive_e             RISC-V Board compatible with SiFive E SDK</span><br><span class="line">sifive_u             RISC-V Board compatible with SiFive U SDK</span><br><span class="line">spike                RISC-V Spike board (default)</span><br><span class="line">virt                 RISC-V VirtIO board</span><br></pre></td></tr></table></figure><h1 id="获取平台信息"><a href="#获取平台信息" class="headerlink" title="获取平台信息"></a>获取平台信息</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">qemu-system-riscv64 -machine virt,dumpdtb=qemu-riscv64-virt.dtb</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">dtc -I dtb -O dts -o qemu-riscv64-virt.dts qemu-riscv64-virt.dtb</span></span><br></pre></td></tr></table></figure><p>第一条命令是将 virt board 的设备树dump下来，第二条命令是将输入类型dtb输出为dts的设备树文件。修改dts后可以通过dtc命令生成dtb文件，可通过<code>dtdiff file1 file2</code>查看差异。  </p><p>安装dtc命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> apt install device-tree-compiler</span></span><br></pre></td></tr></table></figure><p>查看内存布局，方便修改链接文件：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">memory@80000000</span> <span class="punctuation">&#123;</span></span><br><span class="line">device_<span class="attr">type</span> <span class="operator">=</span> <span class="string">&quot;memory&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">reg</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0x00</span> <span class="number">0x80000000</span> <span class="number">0x00</span> <span class="number">0x8000000</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br></pre></td></tr></table></figure><p>查看uart布局，方便打印：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">uart@10000000</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">interrupts</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0x0a</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">interrupt-parent</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0x03</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">clock-frequency</span> <span class="operator">=</span> <span class="string">&quot;\08@&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">reg</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0x00</span> <span class="number">0x10000000</span> <span class="number">0x00</span> <span class="number">0x100</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;ns16550a&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br></pre></td></tr></table></figure><p>可见，将字符输出到0x10000000的内存地址就可以在串口看到信息。  </p><p>源代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">.section .text.boot  #指定此文件编译出的代码在.text.boot段</span><br><span class="line"></span><br><span class="line">.globl _start</span><br><span class="line">_start:</span><br><span class="line">    li s1, 0x10000000 # s1寄存器赋值为uart内存的地址</span><br><span class="line">    la s2, message    # s2寄存器赋值为message的首地址</span><br><span class="line">    addi s3, s2, 14   # s3寄存器赋值为message的结束地址</span><br><span class="line">1:</span><br><span class="line">    lb s4, 0(s2)      # s4赋值为s2内存中的值</span><br><span class="line">    sb s4, 0(s1)      # s4寄存器内的值输出到s1(uart)内存中</span><br><span class="line">    addi s2, s2, 1    # s2 := s2 + 1</span><br><span class="line">    blt s2, s3, 1b    # if s2 &lt; s3, branch back to 1</span><br><span class="line"></span><br><span class="line">.section .data</span><br><span class="line">message:</span><br><span class="line">  .string &quot;Hello, world!\n&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>链接文件：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">OUTPUT_ARCH( <span class="string">&quot;riscv&quot;</span> )</span><br><span class="line">ENTRY( _start )</span><br><span class="line"></span><br><span class="line">SECTIONS</span><br><span class="line">&#123;</span><br><span class="line">. = <span class="number">0x80000000</span>, <span class="comment">//代码启动的地方</span></span><br><span class="line">_text_boot = .;</span><br><span class="line">.text.boot : &#123; *(.text.boot) &#125; <span class="comment">// boot代码存放的地方</span></span><br><span class="line">_etext_boot = .;</span><br><span class="line"></span><br><span class="line">. = ALIGN(<span class="number">4096</span>);</span><br><span class="line">_text = .;</span><br><span class="line">.text :</span><br><span class="line">&#123; </span><br><span class="line">*(.text)    <span class="comment">// 应用代码存放的地方</span></span><br><span class="line">&#125;</span><br><span class="line">_etext = .;</span><br><span class="line"></span><br><span class="line">. = ALIGN(<span class="number">4096</span>);</span><br><span class="line">_rodata = .;</span><br><span class="line">.rodata :</span><br><span class="line">&#123; </span><br><span class="line">*(.rodata)  <span class="comment">// 全局变量，只读变量</span></span><br><span class="line">&#125;</span><br><span class="line">_erodata = .;</span><br><span class="line">    </span><br><span class="line">    . = ALIGN(<span class="number">4096</span>);</span><br><span class="line">_data = .;</span><br><span class="line">.data : &#123; *(.data) &#125; <span class="comment">// .data 存放的地方</span></span><br><span class="line">_edata = .;</span><br><span class="line"></span><br><span class="line">. = ALIGN(<span class="number">0x8</span>);</span><br><span class="line">bss_begin = .;</span><br><span class="line">.bss : &#123; *(.bss*) &#125; </span><br><span class="line">bss_end = .;</span><br><span class="line"></span><br><span class="line">_end = .;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><p>commit 0a9faa86e6d7d538ac61 <a href="https://github.com/AllenZF/risc-v-bm">源码地址</a><br>编译运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">➜  risc-v-bm git:(0a9faa8) make                                       </span><br><span class="line">rm -rf build *.img kernel.map</span><br><span class="line">mkdir -p build</span><br><span class="line">riscv64-linux-gnu-gcc -g -Wall -nostdlib  -Iinclude  -MMD -c src/start.c -o build/start_c.o</span><br><span class="line">riscv64-linux-gnu-gcc -g -Iinclude  -MMD -c -D__ASSEMBLY__ src/startup.S -o build/startup_s.o</span><br><span class="line">riscv64-linux-gnu-ld -T src/linker.ld -Map kernel.map -o build/kernel.elf  build/start_c.o build/startup_s.o</span><br><span class="line">riscv64-linux-gnu-objcopy build/kernel.elf -O binary kernel.img</span><br><span class="line">➜  risc-v-bm git:(0a9faa8) make run</span><br><span class="line">qemu-system-riscv64 -machine virt -bios none -kernel build/kernel.elf  -nographic</span><br><span class="line">Hello, world!</span><br></pre></td></tr></table></figure><p><code>Ctrl + A X </code>退出qemu.</p><h1 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h1><p>运行virt并在startup停住  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">qemu-system-riscv64 -M virt -bios none -nographic -kernel build/kernel.elf -S -s</span></span><br></pre></td></tr></table></figure><p>参数说明</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-S              freeze CPU at startup (use &#x27;c&#x27; to start execution)</span><br><span class="line">-s              shorthand for -gdb tcp::1234</span><br></pre></td></tr></table></figure><p>另外打开终端开始调试：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gdb-multiarch --tui ./build/kernel.elf</span><br></pre></td></tr></table></figure><p>gdb-multiarch是GDB针对多种架构的调试器，与默认的gdb不同，gdb只支持x86&#x2F;x64架构。<br>执行效果如下：<br>![](gdb-multiarch –tui kernel.elf.png)  </p><p>输入<code>c</code>进入，  </p><p>连接到qemu<code>$ target remote :1234</code><br>打断点：<code>b _start</code><br>继续执行：<code>c</code><br><img src="/gdb_2.png"></p><p>显示所有寄存器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) layout regs</span><br></pre></td></tr></table></figure><p>查看寄存器<code>i r s1</code><br><img src="/gdb_3.png"></p>]]></content>
      
      
      <categories>
          
          <category> qemu </category>
          
      </categories>
      
      
        <tags>
            
            <tag> qemu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WSL连接USB设备</title>
      <link href="/2023/01/08/WSL%E8%BF%9E%E6%8E%A5USB%E8%AE%BE%E5%A4%87/"/>
      <url>/2023/01/08/WSL%E8%BF%9E%E6%8E%A5USB%E8%AE%BE%E5%A4%87/</url>
      
        <content type="html"><![CDATA[<p>参考<a href="https://learn.microsoft.com/zh-cn/windows/wsl/connect-usb">连接 USB 设备</a></p><h1 id="常用命令："><a href="#常用命令：" class="headerlink" title="常用命令："></a>常用命令：</h1><h2 id="列出WiN上连接的USB设备"><a href="#列出WiN上连接的USB设备" class="headerlink" title="列出WiN上连接的USB设备"></a>列出WiN上连接的USB设备</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">usbipd wsl list</span><br></pre></td></tr></table></figure><p>命令显示结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">BUSID  DEVICE                                                        STATE</span><br><span class="line">1-10   英特尔(R) 无线 Bluetooth(R)                                   Not attached</span><br><span class="line">1-11   J-Link driver                                                 Not attached</span><br><span class="line">1-12   USB-SERIAL CH340 (COM3)                                       Not attached</span><br><span class="line">1-15   USB 输入设备                                                  Not attached</span><br><span class="line">1-21   USB 输入设备                                                  Not attached</span><br><span class="line">4-4    Xbox Wireless Adapter for Windows                             Not attached</span><br></pre></td></tr></table></figure><h2 id="将设备附加到WSL，附加后通过Ubuntu命令行就可以查看到设备"><a href="#将设备附加到WSL，附加后通过Ubuntu命令行就可以查看到设备" class="headerlink" title="将设备附加到WSL，附加后通过Ubuntu命令行就可以查看到设备"></a>将设备附加到WSL，附加后通过Ubuntu命令行就可以查看到设备</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">usbipd wsl attach <span class="literal">--busid</span> <span class="number">1</span><span class="literal">-11</span></span><br><span class="line"><span class="comment"># usbipd wsl attach --busid &lt;busid&gt;</span></span><br></pre></td></tr></table></figure><p>PowerShell下命令效果：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">PS</span> C:\Users\Sven&gt; usbipd wsl list</span><br><span class="line">BUSID  DEVICE                                                        STATE</span><br><span class="line"><span class="number">1</span><span class="literal">-10</span>   英特尔(<span class="built_in">R</span>) 无线 Bluetooth(<span class="built_in">R</span>)                                   Not attached</span><br><span class="line"><span class="number">1</span><span class="literal">-11</span>   J<span class="literal">-Link</span> driver                                                 Attached - Ubuntu<span class="literal">-22</span>.<span class="number">04</span></span><br><span class="line"><span class="number">1</span><span class="literal">-12</span>   USB<span class="literal">-SERIAL</span> CH340 (COM3)                                       Not attached</span><br><span class="line"><span class="number">1</span><span class="literal">-15</span>   USB 输入设备                                                  Not attached</span><br><span class="line"><span class="number">1</span><span class="literal">-21</span>   USB 输入设备                                                  Not attached</span><br><span class="line"><span class="number">4</span><span class="literal">-4</span>    Xbox Wireless Adapter <span class="keyword">for</span> Windows                             Not attached</span><br></pre></td></tr></table></figure><p>Ubuntu下效果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">➜  Desktop lsusb</span><br><span class="line">Bus 002 Device 001: ID 1d6b:0003 Linux Foundation 3.0 root hub</span><br><span class="line">Bus 001 Device 003: ID 1366:0101 SEGGER J-Link PLUS</span><br><span class="line">Bus 001 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub</span><br></pre></td></tr></table></figure><h2 id="设备使用完后，物理断开USB设备"><a href="#设备使用完后，物理断开USB设备" class="headerlink" title="设备使用完后，物理断开USB设备"></a>设备使用完后，物理断开USB设备</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">usbipd wsl detach <span class="literal">--busid</span> &lt;busid&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> wsl </category>
          
      </categories>
      
      
        <tags>
            
            <tag> usb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ARM芯片调试——BPU &amp; DWU</title>
      <link href="/2023/01/07/ARM%E8%8A%AF%E7%89%87%E8%B0%83%E8%AF%95%E2%80%94%E2%80%94BPU-DWU/"/>
      <url>/2023/01/07/ARM%E8%8A%AF%E7%89%87%E8%B0%83%E8%AF%95%E2%80%94%E2%80%94BPU-DWU/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> Debug </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BPU </tag>
            
            <tag> DWU </tag>
            
            <tag> SCS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ARM芯片调试——Openocd</title>
      <link href="/2023/01/07/ARM%E8%8A%AF%E7%89%87%E8%B0%83%E8%AF%95%E2%80%94%E2%80%94Openocd/"/>
      <url>/2023/01/07/ARM%E8%8A%AF%E7%89%87%E8%B0%83%E8%AF%95%E2%80%94%E2%80%94Openocd/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> Debug </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Openocd </tag>
            
            <tag> bp </tag>
            
            <tag> mww </tag>
            
            <tag> mdw </tag>
            
            <tag> halt </tag>
            
            <tag> wp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ARM芯片调试——建立连接</title>
      <link href="/2023/01/07/ARM%E8%8A%AF%E7%89%87%E8%B0%83%E8%AF%95%E2%80%94%E2%80%94%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5/"/>
      <url>/2023/01/07/ARM%E8%8A%AF%E7%89%87%E8%B0%83%E8%AF%95%E2%80%94%E2%80%94%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>&emsp;&emsp;Arm® Debug Interface Architecture Specification ADIv5.0 to ADIv5.2, Seventh issue<br>&emsp;&emsp;Cortex™-M1 Technical Reference Manual Revision: r0p1  </p><h1 id="调试访问接口DAP"><a href="#调试访问接口DAP" class="headerlink" title="调试访问接口DAP"></a>调试访问接口DAP</h1><p><img src="/ComplexArmDebugInterface.png" alt="Debug Interface"></p><p>通常一颗SOC只有一个DAP(Debug Access port)。每个DAP包含一个DP（用于连接外部的调试器，如Jlink, Ulink, St-link)和多个AP。AP可以访问系统寄存器、外部IP寄存器，ROM, RAM等。图中DAP包含了2类AP，通常SOC中使用MEM-AP类型。DP的作用是将Debugger中的命令转换成AP能识别的命令，而AP则是通过memory map方式去直接访问内存。  </p><h2 id="JTAG-DP"><a href="#JTAG-DP" class="headerlink" title="JTAG-DP"></a>JTAG-DP</h2><p>JTAG-DP的物理连接和数据链路如下。</p><p>![JTAG-DP Scan Chain](JTAG-DP scan chain.png)  </p><h3 id="物理链路"><a href="#物理链路" class="headerlink" title="物理链路"></a>物理链路</h3><p>物理链上包括5个针脚，输入：TDI, TMS, TCK, TRSTn, 输出：TDO.</p><h3 id="数据链路"><a href="#数据链路" class="headerlink" title="数据链路"></a>数据链路</h3><p>数据链路包括1条响应链路——Result，3条DP链路，1条AP链路。整个DAP包含了4条指令，APACC, DPACC, IDCODE, ABORT. 通过这4条指令来选择当前DAP走的是哪一条链路。  </p><h4 id="指令介绍"><a href="#指令介绍" class="headerlink" title="指令介绍"></a>指令介绍</h4><p><img src="/Instructions.png" alt="指令">  </p><ul><li>IDCODE指令是DAP复位时执行的指令，每个DP都有一个ID号，每个AP也有一个ID号，IDCODE指令就是在TDO输出 DP ID 号的指令，ID号保存在 DP ID register中。</li><li>DPACC表示接下来的指令是去访问DP寄存器的。</li><li>APACC表示接下来的指令是去访问AP寄存器的。</li><li>ABORT无效指令。</li></ul><p>指令有2种形式，4bits和8bits. 后文中的指令都是4bits.</p><p>DP中有2条链（DR Chain和IR Chain，实际是2个状态机）来管理这4条指。</p><h4 id="IR-Chain-指令链-的输入输出形式"><a href="#IR-Chain-指令链-的输入输出形式" class="headerlink" title="IR Chain(指令链)的输入输出形式"></a>IR Chain(指令链)的输入输出形式</h4><p><img src="/instruction_shift.png"></p><p>指令从TDI输入。当输入指令时，TDO固定输出0b0001. 整个过程在IR Chain中完成。当指令输入完成后，后续会根据指令进入对应的数据链路。</p><h4 id="DR-IR-Chain"><a href="#DR-IR-Chain" class="headerlink" title="DR IR Chain"></a>DR IR Chain</h4><p><img src="/DR-IR-Chain.png" alt="DR-IR-Chain">  </p><p>如图，TMS每一个TCK都会导致IR Chain的状态更新或保持。指令更新是由TMS驱动的。而指令的输入是由TDI输入的。调试器（openocd）会将指令发送到TDI针脚，IR Chain采集这条指令。指令的采集生效等动作都是IR Chain完成的，IR Chain完成一个动作都会通过Result链路，通过TDO反馈执行效果。DR Chain是用来完成数据传输的，主要执行DPACC和APACC指令下的数据传输。<br>比如TDI输入APACC(0xB)指令，在Capture-IR状态时，二进制0b0001被导入到指令移位区，TMS输入0，IR Chain进入Shift-IR状态，此时IR Chain的指令移位区被选定为TDI到TDO的数据通路。TMS继续输入0，保持Shift-IR状态，并且随着TCK驱动，TDI低比特先输入到移位区，同时将DATA(此时已经是0b0001)底比特0b1输出到TDO. 4个TCK之后，指令输入完成。到Update-IR状态，DATA区的指令APACC会更新成为DAP当前的指令，并且选中对应数据链路。</p><p>当DAP复位时处于 Test-Logic-Reset 状态，此时默认选中IDCODE指令对应的数据链路。</p><h4 id="指令实例分析"><a href="#指令实例分析" class="headerlink" title="指令实例分析"></a>指令实例分析</h4><p><img src="/TMS-TDI.png" alt="指令更新">   </p><p>TMS输入1，DAP从Select DR Scan状态转移到Select IR Scan。TMS输入0，DAP状态进入Capture-IR, 此时 0b0001 被导入到DATA中，TMS继续输入0，DAP进入Shift-IR状态。TDI输入指令APACC(0xB), TDO输出0b0001。</p><h4 id="DR-Chain-数据链-的输入输出"><a href="#DR-Chain-数据链-的输入输出" class="headerlink" title="DR Chain(数据链)的输入输出"></a>DR Chain(数据链)的输入输出</h4><p>IR Chain的作用就是选择TDI到TDO之前的数据通路。当DAP进入Update-IR链之后，会根据指令选中对应的链路，比如APACC就选中通向AP的链路，后续所有操作都针对AP进行。</p><ul><li>DPACC&#x2F;APACC数据链路<br><img src="/DPACC_APACC_DATAPATH.png"><br>图中数据链路为读取数据的示意图，链路的移位寄存器长度为35 bits，高32 bits为输入数据DATAIN，A[3:2]为DP或者AP的寄存器地址，RnW表示访问的方向，读（1）或写（0）。ReadResult是读取结果。ACK有2种值，0b010表示OK&#x2F;FAULT，0b001表示WAIT。</li><li>ABORT数据链路<br><img src="/ABORT_DATAPATH.png"><br>ABORT指令链路时，TDI输入数据为UNKNOWN，输出数据为[ABORT[31:0], A[3:2], 0]</li></ul><h4 id="数据传输实例分析"><a href="#数据传输实例分析" class="headerlink" title="数据传输实例分析"></a>数据传输实例分析</h4><p><a href="instructions_example.png">数据传输</a><br><img src="/instructions_example.png" alt="数据传输">  </p><p>如图，0xB为APACC指令，表示后面的指令是要访问AP寄存器的。0xA为DPACC指令，表示后面的指令是要访问DP寄存器的。0x000000784&#x3D;[0x000000f0,0b10,0b0], 0b0表示写，0b10表示寄存器地址，结合前面指令0xA, 就表示向DP的0b10地址（Select寄存器）中写0x000000f0。通过DP Select寄存器可以选择AP编号，设置AP寄存器bank编号。所以0x00000f0,表示设置AP SEL为第一个AP，选中AP bank为0xF bank。0x6F56DF77F&#x3D;[0xdeadbeef,0b11,0b1]表示读AP的0b11寄存器, 再加上前一条指令就是读 AP 0 的 0xF bank 的 0x11地址，实际上就是AP ID register。0x000000007表示读（0b1）取DP的buffer(地址0b11), buffer里面是刚才读到的AP ID. 0x2A3B80012 &#x3D;&gt; [0x54770002,0b010], 其中0x54770002是ID，0b010表示OK&#x2F;FAULT。</p><h2 id="DP-register"><a href="#DP-register" class="headerlink" title="DP register"></a>DP register</h2><p><img src="/DP_register.png"><br>DP&#x2F;AP的寄存器地址有4bit，但是固定A[1:0]为0b00, 所以从TDI传入的地址只有2bits A[3:2]. 所以DP&#x2F;AP的寄存器地址都是以4为偏移增量的。在数据传输实例中的0x000000784&#x3D;[0x000000f0,0b10,0b0]就表示A[3:2]&#x3D;0b10，及地址0b1000, 也就是Select寄存器。<br><img src="/select.png" alt="Select Register"><br>这个寄存器是需要配置的，特别是APSEL和APBANKSEL字段。DP上挂了多个AP，这个时候就需要APSEL来决定选择哪一个。APBANKSEL字段是选择AP bank的。AP的寄存器有很多，但A[3:2]只能访问4个寄存器，此时就需要APBANKSEL字段来决定哪个Bank生效（BanK是互斥的，因此切换bank就需要配置该字段）。</p><h2 id="AP-register"><a href="#AP-register" class="headerlink" title="AP register"></a>AP register</h2><p><img src="/AHB-AP-register.png" alt="AHB-AP Register"><br>AP寄存器地址的底4bit表示寄存器在bank中的地址，高4bit表示bank号。表中0xFC偏移量就表示0xF bank, 0xC(A[3”2]&#x3D;0b11)地址，即AP ID 寄存器IDR。0xF8偏移表示0xF,0x8（A[3:2]&#x3D;0b10）地址，即ROM table的基地址。0x0 bank中的0x4（A[3:2]&#x3D;0b01）寄存器是AP访问中存放访问地址的寄存器，0x0 bank中0xC地址是AP访问中存放数据的寄存器。比如要枚举ROM table, 则先读取0xF8, ROM table地址。然后将ROM table地址通过TDI输入，传到AP 0x04 Transfer Address寄存器，之后就可以去0x0C Data Read&#x2F;Write 寄存器读取ROM table地址的数据。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="/DAP-STRUCTURE.png" alt="对AP的访问"></p><p>上图中展示了4条数据链，分别是DPACC, IDCODE, ABORT, APACC. 数据链的两端分别是TDI和TDO. 链路的选择即是指令的选择，这由Debug TAP State Machine(DBGTAGSM)来管理更新。当想要读取AP 0的IDR时，首先要通过DPACC指令来配置DP的select寄存器，A[7:4]即时APBANKSEL字段，选择bank，APSEL字段选择AP. 然后切换到APACC指令，通过Rnw和A[3:2]来指定访问方向和地址，从而读出IDR值。</p><p><img src="/MEM-AP-connecting-the-DP-to-debug-components.png" alt="对MEM-AP访问"></p><p>从上图中可以看到ROM table中Processor和ETM模块，其模块基地址分别在ROM table的0x000，0x004偏移地址存储。如果需要访ETM的Register 2, 则主要流程如下：</p><ol><li>配置select寄存器，选择AP和bank;</li><li>读取AP 0xF8地址，获取ROM table的基地址；</li><li>向AP 0x04地址写ROM table地址；（注意，对AP 0xF4进行配置，可自动修改地址进行连续读取）。</li><li>读取AP 0x0C地址读出ROM table地址的0x000偏移的数据。</li><li>当ROM table数据被读取完后就得到了ETM基地址；</li><li>计算ETM Register 2地址，向AP 0x04写该地址；</li><li>读取AP 0x0C地址的数据；<br>最终将得到ETM Register 2的数据。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Debug </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ARM </tag>
            
            <tag> JTAG </tag>
            
            <tag> DAP </tag>
            
            <tag> SWJ-DP </tag>
            
            <tag> DP </tag>
            
            <tag> AP </tag>
            
            <tag> ROM Table </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ARM芯片调试——简介</title>
      <link href="/2023/01/07/ARM%E8%8A%AF%E7%89%87%E8%B0%83%E8%AF%95%E2%80%94%E2%80%94%E7%AE%80%E4%BB%8B/"/>
      <url>/2023/01/07/ARM%E8%8A%AF%E7%89%87%E8%B0%83%E8%AF%95%E2%80%94%E2%80%94%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="背景及目的"><a href="#背景及目的" class="headerlink" title="背景及目的"></a>背景及目的</h1><p>本文初衷是记录ARM芯片调试方法，想要达到效果是能引导新手入门到实际胜任调试芯片工作。文章行文以实际调试为主，避免大篇幅理论介绍，涉及到理论知识时会穿插讲解。</p><h1 id="涉及到的知识和工具"><a href="#涉及到的知识和工具" class="headerlink" title="涉及到的知识和工具"></a>涉及到的知识和工具</h1><table><thead><tr><th align="left">工具</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">JTAG-DAP</td><td align="left">用于连接调试器和目标器件</td></tr><tr><td align="left">Jlink</td><td align="left">充当调试器</td></tr><tr><td align="left">Openocd</td><td align="left">类似于GDB</td></tr><tr><td align="left">Coresight</td><td align="left">SOC中的调试组件</td></tr></tbody></table><h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><p><a href="">ARM芯片调试——建立连接</a><br>&emsp;&emsp;介绍调试接口如何连接SOC，数据如何传输，主要涉及SWJ-DP, DAP, DP, AP，DP register, AP register.<br><a href="">ARM芯片调试——Openocd</a><br>&emsp;&emsp;介绍使用Openocd建立与SOC连接涉及的脚步及相关命令，调试命令，breakpoint命令，watchpoint命令等。<br><a href="">ARM芯片调试——BPU &amp; DWU</a><br>&emsp;&emsp;介绍Breakpoint和Watchpoint的功能原理。</p>]]></content>
      
      
      <categories>
          
          <category> Debug </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ARM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>I2C挂死恢复</title>
      <link href="/2021/06/25/I2C%E6%8C%82%E6%AD%BB%E6%81%A2%E5%A4%8D/"/>
      <url>/2021/06/25/I2C%E6%8C%82%E6%AD%BB%E6%81%A2%E5%A4%8D/</url>
      
        <content type="html"><![CDATA[<p>现象：最近在做CIS SOC的FPGA原型设计验证，芯片使用I2C进行寄存器控制，不知道是不是因为总线上总是有毛刺导致I2C容易提前回复NAK，或者从设备总是在等scl信号。<br>挂死解决方法：host挂死使用PE可以简单恢复。这里主要记录从设备挂死且在等scl情况的解决（前一个项目从设备数据没被读取本来就没有回应，排除）</p><ol><li>释放I2C外设资源（HAL_I2C_Deinit），包括RCC复位寄存器、GPIO释放等；</li><li>初始化GPIO为输出，并拉高数据总线，然后不断翻转时钟总线并检测数据总线状态；</li><li>如果数据总线为释放状态，则释放时钟总线，然后拉低数据总线然后拉高；</li><li>对I2C重新初始化；</li></ol>]]></content>
      
      
      <categories>
          
          <category> problem </category>
          
      </categories>
      
      
        <tags>
            
            <tag> I2C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Doxygen-C</title>
      <link href="/2021/02/11/Doxygen-C/"/>
      <url>/2021/02/11/Doxygen-C/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/silencehuan/p/11877655.html">Vs code添加自定义snippet（代码段)</a><br><a href="https://www.cnblogs.com/silencehuan/p/11169084.html">代码注释规范之Doxygen</a>  </p><h1 id="vs-code-snippets"><a href="#vs-code-snippets" class="headerlink" title="vs code snippets"></a>vs code snippets</h1><p>由于 vs code doxygen 插件功能有限，这里用 snippets 的功能代替 doxygen 插件，功能有重叠。  </p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="comment">// Add snippet</span></span><br><span class="line">    <span class="comment">// ctrl+shift+p, find &quot;snippet&quot;, select &quot;Preferences:Config User Snippets</span></span><br><span class="line">    <span class="attr">&quot;create a new c source file&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;prefix&quot;</span><span class="punctuation">:</span> <span class="string">&quot;doxygen_file_c&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;body&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">            <span class="string">&quot;/*******************************************************************************&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot; * @file $&#123;TM_FILENAME&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot; * @brief $&#123;1:Brief-description&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot; * @details&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot; * @author Justin (Zhoufei848@163.com)&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot; * @version 1.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot; * @date $CURRENT_YEAR-$CURRENT_MONTH-$CURRENT_DATE&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot; * @copyright Copyright (c) $CURRENT_YEAR Justin&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot; *&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot; *&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot; * @par Change log:&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot; * &lt;table&gt;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot; * &lt;tr&gt;&lt;th&gt;Date        &lt;th&gt;Version &lt;th&gt;Author  &lt;th&gt;Description&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot; * &lt;tr&gt;&lt;td&gt;$CURRENT_YEAR-$CURRENT_MONTH-$CURRENT_DATE  &lt;td&gt;1.0     &lt;td&gt;Justin  &lt;td&gt;Draft&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot; * &lt;/table&gt;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot; ******************************************************************************/&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;#include \&quot;$&#123;TM_FILENAME/(.*)\\.c$/$&#123;1&#125;.h/i&#125;\&quot;\n&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;\n\n\n\n&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;/************************* (c) COPYRIGHT $CURRENT_YEAR Justin **************************/\n&quot;</span></span><br><span class="line">        <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;create a new c head file&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;prefix&quot;</span><span class="punctuation">:</span> <span class="string">&quot;doxygen_file_h&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;body&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">            <span class="string">&quot;/*******************************************************************************&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot; * @file $&#123;TM_FILENAME&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot; * @brief $&#123;1:Brief-description&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot; * @details&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot; * @author Justin (Zhoufei848@163.com)&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot; * @version 1.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot; * @date $CURRENT_YEAR-$CURRENT_MONTH-$CURRENT_DATE&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot; * @copyright Copyright (c) $CURRENT_YEAR Justin&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot; *&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot; *&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot; * @par Change log:&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot; * &lt;table&gt;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot; * &lt;tr&gt;&lt;th&gt;Date        &lt;th&gt;Version &lt;th&gt;Author  &lt;th&gt;Description&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot; * &lt;tr&gt;&lt;td&gt;$CURRENT_YEAR-$CURRENT_MONTH-$CURRENT_DATE  &lt;td&gt;1.0     &lt;td&gt;Justin  &lt;td&gt;Draft&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot; * &lt;/table&gt;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot; ******************************************************************************/&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;#ifndef __$&#123;2:$&#123;TM_FILENAME/(.*)\\.h$/$&#123;1:/upcase&#125;_H/i&#125;&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;#define __$2&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;\n\n\n\n&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;#endif // __$2\n&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;/************************* (c) COPYRIGHT $CURRENT_YEAR Justin **************************/\n&quot;</span></span><br><span class="line">        <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;Add struct comment&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;prefix&quot;</span><span class="punctuation">:</span> <span class="string">&quot;doxygen_struct&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;body&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">            <span class="string">&quot;/**&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;  * @struct $CLIPBOARD&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;  * @brief $&#123;1:Brief-description&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;  */&quot;</span></span><br><span class="line">        <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;Add enum comment&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;prefix&quot;</span><span class="punctuation">:</span> <span class="string">&quot;doxygen_enum&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;body&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">            <span class="string">&quot;/**&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;  * @enum $CLIPBOARD&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;  * @brief $&#123;1:Brief-description&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;  */&quot;</span></span><br><span class="line">        <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;Add function comment&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;prefix&quot;</span><span class="punctuation">:</span> <span class="string">&quot;doxygen_fun&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;body&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">            <span class="string">&quot;/**&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;  * @brief      $CLIPBOARD is $&#123;1:for&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;  *&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;  * @param[in]  $&#123;2:param&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;  * @param[out] $&#123;3:param&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;  * @ref        $&#123;4:ref&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;  * @return     $&#123;5:ret&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;  * - $&#123;6:RET1&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;  * - $&#123;7:RET2&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;  * @par Change log:&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;  * &lt;table&gt;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;  * &lt;tr&gt;&lt;th&gt;Date        &lt;th&gt;Version &lt;th&gt;Author  &lt;th&gt;Description&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;  * &lt;tr&gt;&lt;td&gt;$CURRENT_YEAR-$CURRENT_MONTH-$CURRENT_DATE  &lt;td&gt;1.0     &lt;td&gt;Justin  &lt;td&gt;Draft&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;  * &lt;/table&gt;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;  */&quot;</span></span><br><span class="line">        <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;Add name comment&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;prefix&quot;</span><span class="punctuation">:</span> <span class="string">&quot;doxygen_name&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;body&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">            <span class="string">&quot;/**&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;  * @name      $&#123;1:NameSpace&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;  * @brief     $&#123;2:Brief-description&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;  * @&#123;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;  */&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;/** $&#123;3:section&#125; */&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;$CLIPBOARD\n\n&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;/** @&#125; $&#123;1:NameSpace&#125; */\n&quot;</span></span><br><span class="line">        <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;Add group comment&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;prefix&quot;</span><span class="punctuation">:</span> <span class="string">&quot;doxygen_group&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;body&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">            <span class="string">&quot;/**&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;  * @defgroup  $&#123;1:Group&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;  * @&#123;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;  * @ingroup   $&#123;2:Parent_group&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;  * @brief     $&#123;3:Brief-description&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;  */&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;/** $&#123;4:section&#125; */&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;$CLIPBOARD\n\n&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;/** @&#125; $&#123;1:Group&#125; */\n&quot;</span></span><br><span class="line">        <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h1 id="插件配置-Doxygen-Documentation-Generator"><a href="#插件配置-Doxygen-Documentation-Generator" class="headerlink" title="插件配置-Doxygen Documentation Generator"></a>插件配置-Doxygen Documentation Generator</h1><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;doxdocgen.c.commentPrefix&quot;</span><span class="punctuation">:</span> <span class="string">&quot; *&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;doxdocgen.c.firstLine&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/*******************************************************************************&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;doxdocgen.c.lastLine&quot;</span><span class="punctuation">:</span> <span class="string">&quot; ******************************************************************************/&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;doxdocgen.cpp.tparamTemplate&quot;</span><span class="punctuation">:</span> <span class="string">&quot; @tparam &#123;param&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;doxdocgen.file.fileTemplate&quot;</span><span class="punctuation">:</span> <span class="string">&quot; @file &#123;name&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;doxdocgen.file.versionTag&quot;</span><span class="punctuation">:</span> <span class="string">&quot; @version V0.1&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;doxdocgen.generic.authorEmail&quot;</span><span class="punctuation">:</span> <span class="string">&quot;zhoufei848@163.com&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;doxdocgen.generic.authorName&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Justin&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;doxdocgen.generic.authorTag&quot;</span><span class="punctuation">:</span> <span class="string">&quot; @author &#123;author&#125; (&#123;email&#125;)&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;doxdocgen.generic.briefTemplate&quot;</span><span class="punctuation">:</span> <span class="string">&quot; @brief &#123;text&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;doxdocgen.generic.dateTemplate&quot;</span><span class="punctuation">:</span> <span class="string">&quot; @date &#123;date&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;doxdocgen.generic.paramTemplate&quot;</span><span class="punctuation">:</span> <span class="string">&quot; @param &#123;param&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;doxdocgen.generic.returnTemplate&quot;</span><span class="punctuation">:</span> <span class="string">&quot; @return &#123;type&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;doxdocgen.file.copyrightTag&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot; @copyright Copyright © &#123;year&#125; Justin&quot;</span> <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;doxdocgen.generic.generateSmartText&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;doxdocgen.file.fileOrder&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="string">&quot;file&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;brief&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;details&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;author&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;date&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;version&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;copyright&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;empty&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;empty&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;custom&quot;</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;doxdocgen.file.customTag&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="string">&quot; @par change log:&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot; &lt;table&gt;&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot; &lt;tr&gt;&lt;th&gt;Date        &lt;th&gt;Version &lt;th&gt;Author  &lt;th&gt;Description&lt;/tr&gt;&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot; &lt;tr&gt;&lt;td&gt;&#123;date&#125;  &lt;td&gt;0.1     &lt;td&gt;Justin  &lt;td&gt;-# Draft&lt;/tr&gt;&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot; &lt;/table&gt;&quot;</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;editor.rulers&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="number">80</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;doxdocgen.generic.splitCasingSmartText&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> vscode-plug </category>
          
      </categories>
      
      
        <tags>
            
            <tag> doxygen </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git学习资料</title>
      <link href="/2021/01/16/Git%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/"/>
      <url>/2021/01/16/Git%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/</url>
      
        <content type="html"><![CDATA[<p><a href="https://oschina.gitee.io/learn-git-branching/">Git学习小游戏</a><br><a href="http://git.oschina.net/progit/">权威书籍 ProGit中文版</a><br><a href="https://git-scm.com/docs">Git 官网手册</a><br><a href="https://www.cnblogs.com/syp172654682/p/7689328.html">深入浅出Git教程</a><br><a href="https://www.cnblogs.com/yaozhongxiao/p/3811130.html">Git 图解剖析</a><br><a href="https://gitee.com/all-about-git">Git 资源汇总</a></p><hr><p>下载<a href="git.png">git</a>图片<br><img src="/git.png" alt="git"><br>下载<a href="git_%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE.png">git思维导图</a>图片<br><img src="/git_%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE.png" alt="git思维导图"></p>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ASUS RT-ACRH17 救援模式强制刷机教程</title>
      <link href="/2020/04/30/ASUS-RT-ACRH17-%E6%95%91%E6%8F%B4%E6%A8%A1%E5%BC%8F%E5%BC%BA%E5%88%B6%E5%88%B7%E6%9C%BA%E6%95%99%E7%A8%8B/"/>
      <url>/2020/04/30/ASUS-RT-ACRH17-%E6%95%91%E6%8F%B4%E6%A8%A1%E5%BC%8F%E5%BC%BA%E5%88%B6%E5%88%B7%E6%9C%BA%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h1><ul><li>固件恢复工具<a href="https://dlsvr04.asus.com.cn/pub/ASUS/wireless/4G-AC53U/Rescue_2102.zip">ASUS Firmware Restoration</a><br>地址：<a href="https://www.asus.com.cn/networking-iot-servers/wifi-routers/asus-wifi-routers/rt-acrh17/helpdesk_download/?model2Name=RT-ACRH17">https://www.asus.com.cn/Networking/RT-ACRH17/HelpDesk_Download&#x2F;</a><br><img src="/FirmwareRestoration.png"></li><li><a href="https://dlsvr04.asus.com.cn/pub/ASUS/wireless/4G-AC53U/Discovery_1482.zip">固件（一定要下最老的版本）；3.0.0.4.382.50243</a></li></ul><h1 id="刷机过程"><a href="#刷机过程" class="headerlink" title="刷机过程"></a>刷机过程</h1><ul><li>PC上操作<ol><li>修改PC的IP地址192.168.1.10 网关192.168.1.1；</li><li>禁用除本地网络或者以太网以外的其他网络；</li><li>安装工具打开工具加载好固件等待路由器进入救援模式；</li></ol></li><li>路由器上操作<ol><li>进入救援模式：断开RT-ACRH17电源（<strong>重点：拔插座</strong>），<strong>按住</strong>RT-ACRH17的reset按钮，然后通电（<strong>插插座</strong>）（应该不需要按电源键，忘了，可以先试一下不按电源，如果进入救援模式就说明不按电源键）等待电源灯慢闪；</li><li>当电源指示灯慢闪后，点击工具上的上传按钮等待上传和自动更新完成；</li></ol></li></ul><h1 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h1><ul><li>未发现无线设备，这是由于设备没有进入救援模式；<br>解决办法：禁用以太网以外的其他网络，重新进入救援模式；</li><li>固件上传成功，但是系统自动更新失败；<br>解决办法：使用固件版本较高，换为更老旧的低版本固件；</li></ul>]]></content>
      
      
      <categories>
          
          <category> 路由器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RT-ACRH17 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mathjax-LaTex-reference</title>
      <link href="/2020/04/27/MathJax-%E5%B8%B8%E7%94%A8%E5%85%AC%E5%BC%8F%E3%80%81%E7%AC%A6%E5%8F%B7%E5%8F%82%E8%80%83%E6%89%8B%E5%86%8C/"/>
      <url>/2020/04/27/MathJax-%E5%B8%B8%E7%94%A8%E5%85%AC%E5%BC%8F%E3%80%81%E7%AC%A6%E5%8F%B7%E5%8F%82%E8%80%83%E6%89%8B%E5%86%8C/</url>
      
        <content type="html"><![CDATA[<h1 id="MathJax-常用公式、符号参考手册"><a href="#MathJax-常用公式、符号参考手册" class="headerlink" title="MathJax 常用公式、符号参考手册"></a>MathJax 常用公式、符号参考手册</h1><hr><p>LaTeX-2种使用形式</p><ul><li>行内使用单个<code>$</code>符号：<ul><li>文本：<code> $</code>\Gamma(z) &#x3D; \int_0^\infty t^{z-1}e^{-t}dt<code>$ </code></li><li>效果：$\Gamma(z) &#x3D; \int_0^\infty t^{z-1}e^{-t}dt$</li></ul></li><li>单独成行，2个<code>$$</code>单独成行：<ul><li>文本：</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$$</span><br><span class="line">\Gamma(z) = \int_0^\infty t^&#123;z-1&#125;e^&#123;-t&#125;dt</span><br><span class="line">$$</span><br></pre></td></tr></table></figure><pre><code>*   效果（文本前有一行空行）：</code></pre><p>$$\Gamma(z) &#x3D; \int_0^\infty t^{z-1}e^{-t}dt$$</p><h1 id="希腊字母"><a href="#希腊字母" class="headerlink" title="希腊字母"></a>希腊字母</h1><table><thead><tr><th align="center">名称</th><th align="center">大写</th><th align="center">Tex</th><th align="center">小写</th><th align="center">Tex</th></tr></thead><tbody><tr><td align="center">alpha</td><td align="center">$ \Alpha $</td><td align="center">\Alpha</td><td align="center">$ \alpha $</td><td align="center">\alpha</td></tr><tr><td align="center">beta</td><td align="center">$ \Beta $</td><td align="center">\Beta</td><td align="center">$ \beta $</td><td align="center">\beta</td></tr><tr><td align="center">gamma</td><td align="center">$ \Gamma $</td><td align="center">\Gamma</td><td align="center">$ \gamma $</td><td align="center">\gamma</td></tr><tr><td align="center">delta</td><td align="center">$ \Delta $</td><td align="center">\Delta</td><td align="center">$ \delta $</td><td align="center">\delta</td></tr><tr><td align="center">epsilon</td><td align="center">$ \Epsilon $</td><td align="center">\Epsilon</td><td align="center">$ \epsilon $</td><td align="center">\epsilon</td></tr><tr><td align="center">zeta</td><td align="center">$ \Zeta $</td><td align="center">\Zeta</td><td align="center">$ \zeta $</td><td align="center">\zeta</td></tr><tr><td align="center">eta</td><td align="center">$ \Eta $</td><td align="center">\Eta</td><td align="center">$ \eta $</td><td align="center">\eta</td></tr><tr><td align="center">theta</td><td align="center">$ \Theta $</td><td align="center">\Theta</td><td align="center">$ \theta $</td><td align="center">\theta</td></tr><tr><td align="center">iota</td><td align="center">$ \Iota $</td><td align="center">\Iota</td><td align="center">$ \iota $</td><td align="center">\iota</td></tr><tr><td align="center">kappa</td><td align="center">$ \Kappa $</td><td align="center">\Kappa</td><td align="center">$ \kappa $</td><td align="center">\kappa</td></tr><tr><td align="center">lambda</td><td align="center">$ \Lambda $</td><td align="center">\Lambda</td><td align="center">$ \lambda $</td><td align="center">\lambda</td></tr><tr><td align="center">mu</td><td align="center">$ \Mu $</td><td align="center">\Mu</td><td align="center">$ \mu $</td><td align="center">\mu</td></tr><tr><td align="center">nu</td><td align="center">$ \Nu $</td><td align="center">\Nu</td><td align="center">$ \nu $</td><td align="center">\nu</td></tr><tr><td align="center">xi</td><td align="center">$ \Xi $</td><td align="center">\Xi</td><td align="center">$ \xi $</td><td align="center">\xi</td></tr><tr><td align="center">omicron</td><td align="center">$ \Omicron $</td><td align="center">\Omicron</td><td align="center">$ \omicron $</td><td align="center">\omicron</td></tr><tr><td align="center">pi</td><td align="center">$ \Pi $</td><td align="center">\Pi</td><td align="center">$ \pi $</td><td align="center">\pi</td></tr><tr><td align="center">rho</td><td align="center">$ \Rho $</td><td align="center">\Rho</td><td align="center">$ \rho $</td><td align="center">\rho</td></tr><tr><td align="center">sigma</td><td align="center">$ \Sigma $</td><td align="center">\Sigma</td><td align="center">$ \sigma $</td><td align="center">\sigma</td></tr><tr><td align="center">tau</td><td align="center">$ \Tau $</td><td align="center">\Tau</td><td align="center">$ \tau $</td><td align="center">\tau</td></tr><tr><td align="center">upsilon</td><td align="center">$ \Upsilon $</td><td align="center">\Upsilon</td><td align="center">$ \upsilon $</td><td align="center">\upsilon</td></tr><tr><td align="center">phi</td><td align="center">$ \Phi $</td><td align="center">\Phi</td><td align="center">$ \phi $</td><td align="center">\phi</td></tr><tr><td align="center">chi</td><td align="center">$ \Chi $</td><td align="center">\Chi</td><td align="center">$ \chi $</td><td align="center">\chi</td></tr><tr><td align="center">psi</td><td align="center">$ \Psi $</td><td align="center">\Psi</td><td align="center">$ \psi $</td><td align="center">\psi</td></tr><tr><td align="center">omega</td><td align="center">$ \Omega $</td><td align="center">\Omega</td><td align="center">$ \omega $</td><td align="center">\omega</td></tr></tbody></table><h1 id="上下标"><a href="#上下标" class="headerlink" title="上下标"></a>上下标</h1><table><thead><tr><th align="center">语法($*$)</th><th align="center">效果</th></tr></thead><tbody><tr><td align="center">x_i^2</td><td align="center">$x_i^2$</td></tr><tr><td align="center">x^2_i</td><td align="center">$x^2_i$</td></tr><tr><td align="center">{x_i}^2</td><td align="center">${x_i}^2$</td></tr><tr><td align="center">x_{i^2}</td><td align="center">$x_{i^2}$</td></tr><tr><td align="center">x_i_2</td><td align="center">error</td></tr><tr><td align="center">x_{i_2}</td><td align="center">$x_{i_2}$</td></tr><tr><td align="center">x^i^2</td><td align="center">error</td></tr><tr><td align="center">x^{i^2}</td><td align="center">$x^{i^2}$</td></tr><tr><td align="center">\hat {x}</td><td align="center">$\hat {x}$</td></tr><tr><td align="center">\widehat {xy}</td><td align="center">$\widehat {xy}$</td></tr><tr><td align="center">\overline {x}</td><td align="center">$\overline {x}$</td></tr><tr><td align="center">\overline {x+y}</td><td align="center">$\overline {x+y}$</td></tr><tr><td align="center">\underline {x}</td><td align="center">$\underline {x}$</td></tr><tr><td align="center">\underline {x+y}</td><td align="center">$\underline {x+y}$</td></tr><tr><td align="center">\vec {x}</td><td align="center">$\vec {x}$</td></tr><tr><td align="center">\dot {x}</td><td align="center">$\dot {x}$</td></tr><tr><td align="center">\ddot {x}</td><td align="center">$\ddot {x}$</td></tr></tbody></table><h1 id="括号"><a href="#括号" class="headerlink" title="括号"></a>括号</h1><table><thead><tr><th align="center">语法（$*$）</th><th align="center">效果</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">(2+3)</td><td align="center">$(2+3)$</td><td align="center"></td></tr><tr><td align="center">[2+3]</td><td align="center">$[2+3]$</td><td align="center"></td></tr><tr><td align="center">{x}</td><td align="center">${x}$</td><td align="center"></td></tr><tr><td align="center">\lbrace x \rbrace</td><td align="center">$\lbrace x \rbrace$</td><td align="center"></td></tr><tr><td align="center">\langle x \rangle</td><td align="center">$\langle x \rangle$</td><td align="center">尖括号</td></tr><tr><td align="center">\lceil x \rceil</td><td align="center">$\lceil x \rceil$</td><td align="center">上取整</td></tr><tr><td align="center">\lfloor x \rfloor</td><td align="center">$\lfloor x \rfloor$</td><td align="center">下取整</td></tr></tbody></table><h1 id="关系运算"><a href="#关系运算" class="headerlink" title="关系运算"></a>关系运算</h1><table><thead><tr><th align="center">语法（$*$）</th><th align="center">效果</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">\pm</td><td align="center">$\pm$</td><td align="center"></td></tr><tr><td align="center">\times</td><td align="center">$\times$</td><td align="center"></td></tr><tr><td align="center">\div</td><td align="center">$\div$</td><td align="center"></td></tr><tr><td align="center">\mid</td><td align="center">$\mid$</td><td align="center"></td></tr><tr><td align="center">\cdot</td><td align="center">$\cdot$</td><td align="center"><em>a$\cdot$b</em></td></tr><tr><td align="center">\cdots</td><td align="center">$\cdots$</td><td align="center"><em>a$\ldots$b</em></td></tr><tr><td align="center">\ldots</td><td align="center">$\ldots$</td><td align="center"><em>a$\ldots$b</em></td></tr><tr><td align="center">\ast</td><td align="center">$\ast$</td><td align="center"></td></tr><tr><td align="center">\lt</td><td align="center">$\lt$</td><td align="center"></td></tr><tr><td align="center">\leq 或 \le</td><td align="center">$\leq $</td><td align="center"></td></tr><tr><td align="center">\not\lt</td><td align="center">$\not\lt$</td><td align="center"></td></tr><tr><td align="center">\gt</td><td align="center">$\gt$</td><td align="center"></td></tr><tr><td align="center">\geq 或 \ge</td><td align="center">$\ge$</td><td align="center"></td></tr><tr><td align="center">\not\gt</td><td align="center">$\not\gt$</td><td align="center"></td></tr><tr><td align="center">\neq 或 \ne</td><td align="center">$\neq$</td><td align="center"></td></tr><tr><td align="center">\approx</td><td align="center">$\approx$</td><td align="center"></td></tr><tr><td align="center">\equiv</td><td align="center">$\equiv$</td><td align="center"></td></tr><tr><td align="center">\sim</td><td align="center">$\sim$</td><td align="center"></td></tr><tr><td align="center">\cong</td><td align="center">$\cong$</td><td align="center"></td></tr><tr><td align="center">\prec</td><td align="center">$\prec$</td><td align="center"></td></tr><tr><td align="center">\not</td><td align="center">$\not$</td><td align="center"></td></tr><tr><td align="center">\star</td><td align="center">$\star$</td><td align="center"></td></tr><tr><td align="center">\oplus</td><td align="center">$\oplus$</td><td align="center"></td></tr><tr><td align="center">\bullet</td><td align="center">$\bullet$</td><td align="center"></td></tr><tr><td align="center">\circ</td><td align="center">$\circ$</td><td align="center"></td></tr></tbody></table><h1 id="集合运算"><a href="#集合运算" class="headerlink" title="集合运算"></a>集合运算</h1><table><thead><tr><th align="center">语法（$*$）</th><th align="center">效果</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">\varnothing</td><td align="center">$\varnothing$</td><td align="center">空</td></tr><tr><td align="center">\emptyset</td><td align="center">$\emptyset$</td><td align="center">空集</td></tr><tr><td align="center">\notin</td><td align="center">$\notin$</td><td align="center">不属于</td></tr><tr><td align="center">\in</td><td align="center">$\in$</td><td align="center">属于</td></tr><tr><td align="center">\subset</td><td align="center">$\subset$</td><td align="center">真子集</td></tr><tr><td align="center">\subsetneq</td><td align="center">$\subsetneq$</td><td align="center">真子集</td></tr><tr><td align="center">\subseteq</td><td align="center">$\subseteq$</td><td align="center">子集</td></tr><tr><td align="center">\supset</td><td align="center">$\supset$</td><td align="center">父集</td></tr><tr><td align="center">\supseteq</td><td align="center">$\supseteq$</td><td align="center">父集</td></tr><tr><td align="center">\cap</td><td align="center">$\cap$</td><td align="center">交集</td></tr><tr><td align="center">\bigcap</td><td align="center">$\bigcap$</td><td align="center">交集</td></tr><tr><td align="center">\cup</td><td align="center">$\cup$</td><td align="center">并集</td></tr><tr><td align="center">\bigcup</td><td align="center">$\bigcup$</td><td align="center">并集</td></tr><tr><td align="center">\bigvee</td><td align="center">$\bigvee$</td><td align="center"></td></tr><tr><td align="center">\bigwedge</td><td align="center">$\bigwedge$</td><td align="center"></td></tr></tbody></table><h1 id="微积分运算"><a href="#微积分运算" class="headerlink" title="微积分运算"></a>微积分运算</h1><table><thead><tr><th align="center">语法（$*$）</th><th align="center">效果</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">\prime</td><td align="center">$\prime$</td><td align="center">微分</td></tr><tr><td align="center">\int</td><td align="center">$\int$</td><td align="center">一重积分</td></tr><tr><td align="center">\iint</td><td align="center">$\iint$</td><td align="center"></td></tr><tr><td align="center">\iiint</td><td align="center">$\iiint$</td><td align="center"></td></tr><tr><td align="center">\oint</td><td align="center">$\oint$</td><td align="center"></td></tr><tr><td align="center">\lim</td><td align="center">$\lim$</td><td align="center"></td></tr><tr><td align="center">\lim_{x\rightarrow +\infty}</td><td align="center">$\lim_{x\rightarrow +\infty}$</td><td align="center"></td></tr><tr><td align="center">\lim\limits_{x\rightarrow+\infty}</td><td align="center">$\lim\limits_{x\rightarrow+\infty}$</td><td align="center"></td></tr><tr><td align="center">\lim\nolimits_{x\rightarrow+\infty}</td><td align="center">$\lim\nolimits_{x\rightarrow+\infty}$</td><td align="center"></td></tr><tr><td align="center">\infty</td><td align="center">$\infty$</td><td align="center"></td></tr><tr><td align="center">\nabla</td><td align="center">$\nabla$</td><td align="center"></td></tr><tr><td align="center">\prod</td><td align="center">$\prod$</td><td align="center"></td></tr><tr><td align="center">\sum</td><td align="center">$\sum$</td><td align="center"></td></tr><tr><td align="center">\sum_{k&#x3D;1}^n{kx}</td><td align="center">$\sum_{k&#x3D;1}^n{kx}$</td><td align="center"></td></tr><tr><td align="center">\sum\limits_{k&#x3D;1}^n{kx}</td><td align="center">$\sum\limits_{k&#x3D;1}^n{kx}$</td><td align="center"></td></tr><tr><td align="center">\sum\nolimits_{k&#x3D;1}^n{kx}</td><td align="center">$\sum\nolimits_{k&#x3D;1}^n{kx}$</td><td align="center"></td></tr><tr><td align="center">\aleph</td><td align="center">$\aleph$</td><td align="center"></td></tr><tr><td align="center">\partial</td><td align="center">$\partial$</td><td align="center"></td></tr><tr><td align="center">\Im</td><td align="center">$\Im$</td><td align="center"></td></tr><tr><td align="center">\Re</td><td align="center">$\Re$</td><td align="center"></td></tr></tbody></table><h1 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h1><table><thead><tr><th align="center">语法（$*$）</th><th align="center">效果</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">\because</td><td align="center">$\because$</td><td align="center">因为</td></tr><tr><td align="center">\therefore</td><td align="center">$\therefore$</td><td align="center">所以</td></tr><tr><td align="center">\forall</td><td align="center">$\forall$</td><td align="center">任意</td></tr><tr><td align="center">\exists</td><td align="center">$\exists$</td><td align="center">存在</td></tr><tr><td align="center">\land</td><td align="center">$\land$</td><td align="center">与</td></tr><tr><td align="center">\lor</td><td align="center">$\lor$</td><td align="center">或</td></tr><tr><td align="center">\lnot</td><td align="center">$\lnot$</td><td align="center">非</td></tr><tr><td align="center">\top</td><td align="center">$\top$</td><td align="center"></td></tr><tr><td align="center">\bot</td><td align="center">$\bot$</td><td align="center"></td></tr><tr><td align="center">\vdash</td><td align="center">$\vdash$</td><td align="center"></td></tr><tr><td align="center">\vDash</td><td align="center">$\vDash$</td><td align="center"></td></tr></tbody></table><h1 id="箭头符号"><a href="#箭头符号" class="headerlink" title="箭头符号"></a>箭头符号</h1><table><thead><tr><th align="center">语法（$*$）</th><th align="center">效果</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">\uparrow</td><td align="center">$\uparrow$</td><td align="center"></td></tr><tr><td align="center">\Uparrow</td><td align="center">$\Uparrow$</td><td align="center"></td></tr><tr><td align="center">\downarrow</td><td align="center">$\downarrow$</td><td align="center"></td></tr><tr><td align="center">\Downarrow</td><td align="center">$\Downarrow$</td><td align="center"></td></tr><tr><td align="center">\leftarrow</td><td align="center">$\leftarrow$</td><td align="center"></td></tr><tr><td align="center">\Leftarrow</td><td align="center">$\Leftarrow$</td><td align="center"></td></tr><tr><td align="center">\rightarrow</td><td align="center">$\rightarrow$</td><td align="center"></td></tr><tr><td align="center">\Rightarrow</td><td align="center">$\Rightarrow$</td><td align="center"></td></tr><tr><td align="center">\to</td><td align="center">$\to$</td><td align="center"></td></tr><tr><td align="center">\mapsto</td><td align="center">$\mapsto$</td><td align="center"></td></tr></tbody></table><h1 id="分式、根式"><a href="#分式、根式" class="headerlink" title="分式、根式"></a>分式、根式</h1><table><thead><tr><th align="center">语法（$*$）</th><th align="center">效果</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">\frac ab</td><td align="center">$\frac ab$</td><td align="center"></td></tr><tr><td align="center">\frac {a}{b}</td><td align="center">$\frac {a}{b}$</td><td align="center">标准</td></tr><tr><td align="center">{a+1 \over b+1}</td><td align="center">${a+1 \over b+1}$</td><td align="center"></td></tr><tr><td align="center">\sqrt[4]{\frac xy}</td><td align="center">$\sqrt[4]{\frac xy}$</td><td align="center"></td></tr></tbody></table><h2 id="连分式"><a href="#连分式" class="headerlink" title="连分式"></a>连分式</h2><ul><li>书写：<code>x = a_0 + \frac {1^2}{a_1 +\frac {2^2}{a_3 + ...}}</code></li><li>效果：</li></ul><p>$$x &#x3D; a_0 + \frac {1^2}{a_1 +\frac {2^2}{a_3 + …}}$$</p><ul><li>书写：<code>x = a_0 + \cfrac {1^2}{a_1 +\cfrac {2^2}{a_3 + ...}}</code></li><li>效果($\color{lime}{推荐}$)：</li></ul><p>$$x &#x3D; a_0 + \cfrac {1^2}{a_1 +\cfrac {2^2}{a_3 + …}}$$</p><h1 id="多行表达式"><a href="#多行表达式" class="headerlink" title="多行表达式"></a>多行表达式</h1><p>通用语法：<code>\begin{cases}...\end{cases}</code>,常使用<code>\\</code>来分类，使用<code>&amp;</code>来对其，用<code>\空格</code>表示空格。</p><h2 id="分类表达式"><a href="#分类表达式" class="headerlink" title="分类表达式"></a>分类表达式</h2><ul><li>书写：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$$</span><br><span class="line">f(n)</span><br><span class="line">\begin&#123;cases&#125;</span><br><span class="line">\cfrac n2, &amp;if\ n\ is\ even\\</span><br><span class="line">3n + 1, &amp;if\ n\ is\ odd</span><br><span class="line">\end&#123;cases&#125;</span><br><span class="line">$$</span><br></pre></td></tr></table></figure><ul><li>效果：</li></ul><p>$$<br>f(n)<br>\begin{cases}<br>\cfrac n2, &amp;if\ n\ is\ even\<br>3n + 1, &amp;if\ n\ is\ odd<br>\end{cases}<br>$$</p><p>&emsp;&emsp;如果想分类之间的垂直间隔变大，可使用<code>\\[2ex]</code>代替<code>\\</code>来分隔不同的情况。（1ex:原始距离。3ex,4ex都可以）</p><p>$$<br>f(n)<br>\begin{cases}<br>\cfrac n2, &amp;if\ n\ is\ even\[2ex]<br>3n + 1, &amp;if\ n\ is\ odd<br>\end{cases}<br>$$</p><h2 id="多行等式"><a href="#多行等式" class="headerlink" title="多行等式"></a>多行等式</h2><ul><li>书写：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$$</span><br><span class="line">\begin&#123;aligned&#125;</span><br><span class="line">y &amp;= (a+b)^2\\</span><br><span class="line">  &amp;= a^2 +b^2 +2ab\\</span><br><span class="line">  &amp;= 0</span><br><span class="line">\end&#123;aligned&#125;</span><br><span class="line">$$</span><br></pre></td></tr></table></figure><ul><li>效果：</li></ul><p>$$<br>\begin{aligned}<br>y &amp;&#x3D; (a+b)^2\<br>  &amp;&#x3D; a^2 +b^2 +2ab\<br>  &amp;&#x3D; 0<br>\end{aligned}<br>$$</p><h2 id="方程组"><a href="#方程组" class="headerlink" title="方程组"></a>方程组</h2><p>使用<code>\begin{array}...\end{array}</code>与<code>\left \{</code>与<code>\right.</code>配合表示方程组</p><ul><li>书写：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$$</span><br><span class="line">\left \&#123;</span><br><span class="line">\begin&#123;array&#125;&#123;c&#125;</span><br><span class="line">a_1x+b_1y+c_1z=d_1 \\</span><br><span class="line">a_2x+b_2y+c_2z=d_2 \\</span><br><span class="line">a_3x+b_3y+c_3z=d_3</span><br><span class="line">\end&#123;array&#125;</span><br><span class="line">\right .</span><br><span class="line">$$</span><br><span class="line">或</span><br><span class="line">$$</span><br><span class="line">\begin&#123;cases&#125;</span><br><span class="line">a_1x+\ b_1y+\quad c_1z=d_1 \\</span><br><span class="line">a_2x+\;b_2y+\qquad c_2z=d_2 \\</span><br><span class="line">a_3x+b_3y+c_3z=d_3</span><br><span class="line">\end&#123;cases&#125;</span><br><span class="line">$$</span><br></pre></td></tr></table></figure><ul><li>效果1：</li></ul><p>$$<br>\left {<br>\begin{array}{c}<br>a_1x+b_1y+c_1z&#x3D;d_1 \<br>a_2x+b_2y+c_2z&#x3D;d_2 \<br>a_3x+b_3y+c_3z&#x3D;d_3<br>\end{array}<br>\right .<br>$$</p><ul><li>效果2：</li></ul><p>$$<br>\begin{cases}<br>a_1x+\ b_1y+\quad c_1z&#x3D;d_1 \<br>a_2x+;b_2y+\qquad c_2z&#x3D;d_2 \<br>a_3x+b_3y+c_3z&#x3D;d_3<br>\end{cases}<br>$$</p><p><b>注意</b>：通常MathJax通过内部策略自己管理公式内部的空间，因此a…b与a……b（<kbd>.</kbd>表示空格）都会显示为ab。可以通过在ab间加入<kbd>\空格</kbd>增加些许间隙，<code>\;</code>增加较宽的间隙，<code>\quad</code>与 <code>\qquad</code>会增加更大的间隙。</p><h1 id="特殊函数"><a href="#特殊函数" class="headerlink" title="特殊函数"></a>特殊函数</h1><table><thead><tr><th align="center">语法（$*$）</th><th align="center">效果</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">\sin x</td><td align="center">$\sin x$</td><td align="center"></td></tr><tr><td align="center">\cos x</td><td align="center">$\cos x$</td><td align="center"></td></tr><tr><td align="center">\tan x</td><td align="center">$\tan x$</td><td align="center"></td></tr><tr><td align="center">\arctan x</td><td align="center">$\arctan x$</td><td align="center"></td></tr></tbody></table><h1 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h1><p>使用<code>\begin{matrix}…\end{matrix}</code>这样的形式来表示矩阵，在<code>\begin</code>与<code>\end</code>之间加入矩阵中的元素即可。矩阵的行之间使用<code>\\</code>分隔，列之间使用<code>&amp;</code>分隔。使用<code>\cdots</code>$\cdots$,<code>\ddots</code>$\ddots$,<code>\vdots</code> $\vdots$ ,来省略矩阵中的元素。</p><ul><li>书写：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$$</span><br><span class="line">\begin&#123;matrix&#125;</span><br><span class="line">x_&#123;11&#125; &amp; x_&#123;12&#125; &amp; x_&#123;13&#125; \\</span><br><span class="line">x_&#123;21&#125; &amp; x_&#123;22&#125; &amp; x_&#123;23&#125; \\</span><br><span class="line">x_&#123;31&#125; &amp; x_&#123;32&#125; &amp; x_&#123;33&#125;</span><br><span class="line">\end&#123;matrix&#125;</span><br><span class="line">$$</span><br></pre></td></tr></table></figure><ul><li>效果1：<strong>matrix</strong></li></ul><p>$$<br>\begin{matrix}<br>x_{11} &amp; x_{12} &amp; x_{13} \<br>x_{21} &amp; x_{22} &amp; x_{23} \<br>x_{31} &amp; x_{32} &amp; x_{33}<br>\end{matrix}<br>$$</p><ul><li>效果2：使用参数<b>pmatrix</b>或在<code>效果1</code>前后加<code>\left(...\right)</code></li></ul><p>$$<br>\left(<br>\begin{matrix}<br>x_{11} &amp; x_{12} &amp; x_{13} \<br>x_{21} &amp; x_{22} &amp; x_{23} \<br>x_{31} &amp; x_{32} &amp; x_{33}<br>\end{matrix}<br>\right)<br>$$</p><ul><li>效果3：bmatrix或 <code>\left[...\right]</code></li></ul><p>$$<br>\begin{bmatrix}<br>x_{11} &amp; x_{12} &amp; x_{13} \<br>x_{21} &amp; x_{22} &amp; x_{23} \<br>x_{31} &amp; x_{32} &amp; x_{33}<br>\end{bmatrix}<br>$$</p><ul><li>效果4：Bmatrix或 <code>\left{...\right}</code></li></ul><p>$$<br>\begin{Bmatrix}<br>x_{11} &amp; x_{12} &amp; x_{13} \<br>x_{21} &amp; x_{22} &amp; x_{23} \<br>x_{31} &amp; x_{32} &amp; x_{33}<br>\end{Bmatrix}<br>$$</p><ul><li>效果5：vmatrix</li></ul><p>$$<br>\begin{vmatrix}<br>x_{11} &amp; x_{12} &amp; x_{13} \<br>x_{21} &amp; x_{22} &amp; x_{23} \<br>x_{31} &amp; x_{32} &amp; x_{33}<br>\end{vmatrix}<br>$$</p><ul><li>效果6：Vmatrix</li></ul><p>$$<br>\begin{Vmatrix}<br>x_{11} &amp; x_{12} &amp; x_{13} \<br>x_{21} &amp; x_{22} &amp; x_{23} \<br>x_{31} &amp; x_{32} &amp; x_{33}<br>\end{Vmatrix}<br>$$</p><ul><li>矩阵中的省略号</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$$</span><br><span class="line">\begin&#123;pmatrix&#125;</span><br><span class="line">1&amp;a_1&amp;a_1^2&amp;\cdots&amp;a_1^n\\</span><br><span class="line">1&amp;a_2&amp;a_2^2&amp;\cdots&amp;a_2^n\\</span><br><span class="line">\vdots&amp;\vdots&amp;\vdots&amp;\ddots&amp;\vdots\\</span><br><span class="line">1&amp;a_m&amp;a_m^2&amp;\cdots&amp;a_m^n\\</span><br><span class="line">\end&#123;pmatrix&#125;</span><br><span class="line">$$</span><br></pre></td></tr></table></figure><p>$$<br>\begin{pmatrix}<br>1&amp;a_1&amp;a_1^2&amp;\cdots&amp;a_1^n\<br>1&amp;a_2&amp;a_2^2&amp;\cdots&amp;a_2^n\<br>\vdots&amp;\vdots&amp;\vdots&amp;\ddots&amp;\vdots\<br>1&amp;a_m&amp;a_m^2&amp;\cdots&amp;a_m^n\<br>\end{pmatrix}<br>$$</p><ul><li>增广矩阵</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$$</span><br><span class="line">\left[</span><br><span class="line">\begin&#123;array&#125;&#123;cc|c&#125;</span><br><span class="line">1&amp;2&amp;3\\</span><br><span class="line">4&amp;5&amp;6</span><br><span class="line">\end&#123;array&#125;</span><br><span class="line">\right]</span><br><span class="line">$$</span><br></pre></td></tr></table></figure><p>$$<br>\left[<br>\begin{array}{cc|c}<br>1&amp;2&amp;3\<br>4&amp;5&amp;6<br>\end{array}<br>\right]<br>$$</p><h1 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h1><p>&emsp;&emsp;使用<code>\begin{array}{列样式}…\end{array}</code>这样的形式来创建表格，列样式可以是<code>c l r</code>表示居中，左，右对齐，还可以使用<code>|</code>表示一条竖线。表格中各行使用<code>\\</code>分隔，各列使用<code>&amp;</code>分隔。使用<code>\hline</code>在本行前加入一条直线。</p><ul><li>书写：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$$</span><br><span class="line">\begin&#123;array&#125;&#123;c|lcr&#125;</span><br><span class="line">n &amp; \text&#123;Left&#125; &amp; \text&#123;Center&#125; &amp; \text&#123;Right&#125; \\</span><br><span class="line">hlin</span><br><span class="line">1 &amp; 0.24 &amp; 1 &amp; 125 \\</span><br><span class="line">2 &amp; -1 &amp; 189 &amp; -8 \\</span><br><span class="line">3 &amp; -20 &amp; 2000 &amp; 1+10i \\</span><br><span class="line">\end&#123;array&#125;</span><br><span class="line">$$</span><br></pre></td></tr></table></figure><p>$$<br>\begin{array}{c|lcr}<br>n &amp; \text{Left} &amp; \text{Center} &amp; \text{Right} \<br>\hline<br>1 &amp; 0.24 &amp; 1 &amp; 125 \<br>2 &amp; -1 &amp; 189 &amp; -8 \<br>3 &amp; -20 &amp; 2000 &amp; 1+10i \<br>\end{array}<br>$$</p><h1 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h1><p>$$<br>\begin{array}{l|l|l}<br>\text{字体名} &amp; \text{表达式} &amp; \text{效果} \<br>\hline<br>\text{黑板粗体} &amp; mathbb\ {ALLEN} &amp; \mathbb {ALLEN} \<br>\hline<br>\text{黑体} &amp; mathbf\ {ALLEN} &amp; \mathbf {ALLEN} \<br>\hline<br>\text{打印机字体} &amp; mathbt\ {ALLEN} &amp; \mathtt {ALLEN} \<br>\hline<br>\text{罗马字体} &amp; mathrm\ {ALLEN} &amp; \mathrm {ALLEN} \<br>\hline<br>\text{手写体} &amp; mathscr\ {ALLEN} &amp; \mathscr {ALLEN} \<br>\end{array}<br>$$</p><p><b>注意</b>: 表达式前面需要加<code>\</code>, 如<code>\mathbb {ALLEN}</code></p><h1 id="颜色"><a href="#颜色" class="headerlink" title="颜色"></a>颜色</h1><p><code>\color{black}{text}</code> ：$\color{black}{text}$<br><code>\color{gray}{text}</code> ：$\color{gray}{text}$<br><code>\color{silver}{text}</code> :$\color{silver}{text}$<br><code>\color{white}{text}</code> :$\color{white}{text}$<br><code>\color{maroon}{text}</code> :$\color{maroon}{text}$<br><code>\color{red}{text}</code> :$\color{red}{text}$<br><code>\color{yellow}{text}</code> :$\color{yellow}{text}$<br><code>\color{lime}{text}</code> :$\color{lime}{text}$<br><code>\color{olive}{text}</code> :$\color{olive}{text}$<br><code>\color{green}{text}</code> :$\color{green}{text}$<br><code>\color{teal}{text}</code> :$\color{teal}{text}$<br><code>\color{aqua}{text}</code> :$\color{aqua}{text}$<br><code>\color{blue}{text}</code> :$\color{blue}{text}$<br><code>\color{navy}{text}</code> :$\color{navy}{text}$<br><code>\color{purple}{text}</code> :$\color{purple}{text}$<br><code>\color{fuchsia}{text}</code> :$\color{fuchsia}{text}$</p>]]></content>
      
      
      <categories>
          
          <category> Math </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MathJax </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo-Theme-Snail</title>
      <link href="/2019/11/01/Hexo-Theme-Snail/"/>
      <url>/2019/11/01/Hexo-Theme-Snail/</url>
      
        <content type="html"><![CDATA[<h1 id="hexo-theme-snail"><a href="#hexo-theme-snail" class="headerlink" title="hexo-theme-snail"></a>hexo-theme-snail</h1><p><a href="https://github.com/dusign/hexo-theme-snail">View Hexo-Theme-Snail Sources On Github &#10174; </a></p><p><a href="https://www.dusign.net/">View Live Super Snail Blog &#10174;</a></p><p><img src="/snail.png" alt="hexo-theme-snail"></p><p>Hexo-theme-snail is a succinct hexo theme. It has two colors, light and star, that can be set according to your own preferences in the settings, and also has the functions of sharing and commenting. More features are under development.</p><h2 id="Features"><a href="#Features" class="headerlink" title="Features"></a>Features</h2><ul><li>light color theme and star theme</li><li>diversified comment system</li><li>notice tips</li><li>share to other platforms (under development)</li><li>picture sharing (under development)</li></ul><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Install-Hexo"><a href="#Install-Hexo" class="headerlink" title="Install Hexo"></a>Install Hexo</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-cli -g</span><br></pre></td></tr></table></figure><h3 id="Setup-your-blog"><a href="#Setup-your-blog" class="headerlink" title="Setup your blog"></a>Setup your blog</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo init blog</span><br></pre></td></tr></table></figure><h3 id="Installation-Theme"><a href="#Installation-Theme" class="headerlink" title="Installation Theme"></a>Installation Theme</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> blog</span><br><span class="line">$ <span class="built_in">rm</span> -rf <span class="built_in">source</span></span><br><span class="line">$ <span class="built_in">rm</span> _config.yml package.json README.md LICENSE</span><br><span class="line">$ git <span class="built_in">clone</span> https://github.com/dusign/hexo-theme-snail.git</span><br><span class="line">$ <span class="built_in">mv</span> ./hexo-theme-snail/snail ./themes</span><br><span class="line">$ <span class="built_in">mv</span> ./hexo-theme-snail/* ./</span><br><span class="line">$ npm install</span><br></pre></td></tr></table></figure><h3 id="Set-Theme"><a href="#Set-Theme" class="headerlink" title="Set Theme"></a>Set Theme</h3><p>Modify the value of <code>theme:</code> in <code>_config.yml</code></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Extensions</span></span><br><span class="line"><span class="comment">## Plugins: https://hexo.io/plugins/</span></span><br><span class="line"><span class="comment">## Themes: https://hexo.io/themes/</span></span><br><span class="line"><span class="attr">theme:</span> <span class="string">snail</span></span><br></pre></td></tr></table></figure><h3 id="Start-the-Server"><a href="#Start-the-Server" class="headerlink" title="Start the Server"></a>Start the Server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><h2 id="Configuration"><a href="#Configuration" class="headerlink" title="Configuration"></a>Configuration</h2><h3 id="Site"><a href="#Site" class="headerlink" title="Site"></a>Site</h3><p>Replace the following information with your own.</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Site</span></span><br><span class="line"><span class="attr">title:</span> </span><br><span class="line"><span class="attr">subtitle:</span> <span class="string">At</span> <span class="string">the</span> <span class="string">bottom</span> <span class="string">of</span> <span class="string">the</span> <span class="string">well,</span> <span class="string">it</span> <span class="string">is</span> <span class="string">destined</span> <span class="string">to</span> <span class="string">see</span> <span class="string">only</span> <span class="string">the</span> <span class="string">sky</span> <span class="string">at</span> <span class="string">the</span> <span class="string">wellhead.</span> </span><br><span class="line">          <span class="string">However,</span> <span class="string">the</span> <span class="string">starting</span> <span class="string">point</span> <span class="string">only</span> <span class="string">affects</span> <span class="string">the</span> <span class="string">process</span> <span class="string">of</span> <span class="string">reaching</span> <span class="string">your</span> <span class="string">peak</span> <span class="string">and</span> <span class="string">does</span> <span class="string">not</span> <span class="string">determine</span> <span class="string">the</span> <span class="string">height</span> <span class="string">you</span> <span class="string">reach.</span></span><br><span class="line"><span class="attr">author:</span> <span class="string">Dusign</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">en</span></span><br><span class="line"><span class="attr">timezone:</span></span><br></pre></td></tr></table></figure><h3 id="Site-Settings"><a href="#Site-Settings" class="headerlink" title="Site Settings"></a>Site Settings</h3><p>Put customized pictures in <code>img</code> directory.</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Site settings</span></span><br><span class="line"><span class="attr">SEOTitle:</span> <span class="string">Hexo-theme-snail</span></span><br><span class="line"><span class="attr">email:</span> <span class="string">hexo-theme-snail@mail.com</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">&quot;A hexo theme&quot;</span></span><br><span class="line"><span class="attr">keyword:</span> <span class="string">&quot;dusign, hexo-theme-snail&quot;</span></span><br><span class="line"><span class="attr">header-img:</span> <span class="string">img/header_img/home-bg-1-dark.jpg</span></span><br><span class="line"><span class="attr">signature:</span> <span class="literal">true</span> <span class="comment">#show signature</span></span><br><span class="line"><span class="attr">signature-img:</span> <span class="string">img/signature/Just-do-it-white.png</span></span><br></pre></td></tr></table></figure><h3 id="SNS-Settings"><a href="#SNS-Settings" class="headerlink" title="SNS Settings"></a>SNS Settings</h3><p>If you don’t want to display it, you can delete it directly.</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># SNS settings</span></span><br><span class="line"><span class="attr">github_username:</span>    <span class="string">dusign</span></span><br><span class="line"><span class="attr">twitter_username:</span>   <span class="string">dusignr</span></span><br><span class="line"><span class="attr">facebook_username:</span>  <span class="string">Gang</span> <span class="string">Du</span></span><br><span class="line"><span class="attr">zhihu_username:</span> <span class="string">dusignr</span></span><br></pre></td></tr></table></figure><h3 id="Sidebar-Settings"><a href="#Sidebar-Settings" class="headerlink" title="Sidebar Settings"></a>Sidebar Settings</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Sidebar Settings</span></span><br><span class="line"><span class="attr">sidebar:</span> <span class="literal">true</span>                      <span class="comment"># whether or not using Sidebar.</span></span><br><span class="line"><span class="attr">sidebar-about-description:</span> <span class="string">&quot;Welcome to visit, I&#x27;m Dusign!&quot;</span></span><br><span class="line"><span class="attr">sidebar-avatar:</span> <span class="string">img/ironman-draw.png</span>      <span class="comment"># use absolute URL, seeing it&#x27;s used in both `/` and `/about/`</span></span><br><span class="line"><span class="attr">widgets:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">featured-tags</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">short-about</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">recent-posts</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">friends-blog</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">archive</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">category</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># widget behavior</span></span><br><span class="line"><span class="comment">## Archive</span></span><br><span class="line"><span class="attr">archive_type:</span> <span class="string">&#x27;monthly&#x27;</span></span><br><span class="line"><span class="attr">show_count:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">## Featured Tags</span></span><br><span class="line"><span class="attr">featured-tags:</span> <span class="literal">true</span>                     <span class="comment"># whether or not using Feature-Tags</span></span><br><span class="line"><span class="attr">featured-condition-size:</span> <span class="number">1</span>              <span class="comment"># A tag will be featured if the size of it is more than this condition value</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">## Friends</span></span><br><span class="line"><span class="attr">friends:</span> [</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">title:</span> <span class="string">&quot;Dusign&#x27;s Blog&quot;</span>,</span><br><span class="line">        <span class="attr">href:</span> <span class="string">&quot;https://blog.csdn.net/d_Nail&quot;</span></span><br><span class="line">    &#125;,&#123;</span><br><span class="line">        <span class="attr">title:</span> <span class="string">&quot;Dusign&#x27;s Web&quot;</span>,</span><br><span class="line">        <span class="attr">href:</span> <span class="string">&quot;#&quot;</span></span><br><span class="line">    &#125;,&#123;</span><br><span class="line">        <span class="attr">title:</span> <span class="string">&quot;Dusign&#x27;s Github&quot;</span>,</span><br><span class="line">        <span class="attr">href:</span> <span class="string">&quot;https://github.com/dusign&quot;</span></span><br><span class="line">    &#125;,&#123;</span><br><span class="line">        <span class="attr">title:</span> <span class="string">&quot;Other&quot;</span>,</span><br><span class="line">        <span class="attr">href:</span> <span class="string">&quot;#&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h3 id="Theme"><a href="#Theme" class="headerlink" title="Theme"></a>Theme</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Extensions</span></span><br><span class="line"><span class="comment">## Plugins: https://hexo.io/plugins/</span></span><br><span class="line"><span class="comment">## Themes: https://hexo.io/themes/</span></span><br><span class="line"><span class="attr">theme:</span> <span class="string">snail</span></span><br></pre></td></tr></table></figure><h3 id="Deployment"><a href="#Deployment" class="headerlink" title="Deployment"></a>Deployment</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Deployment</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/deployment.html</span></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span></span><br><span class="line">      <span class="attr">github:</span> <span class="string">github.repository.address</span></span><br><span class="line">      <span class="attr">coding:</span> <span class="string">coding.repository.address</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure><h3 id="Comment"><a href="#Comment" class="headerlink" title="Comment"></a>Comment</h3><p>See httpymls:&#x2F;&#x2F;github.com&#x2F;imsun&#x2F;gitment for detailed configuration method.</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Comment</span></span><br><span class="line"><span class="comment">## This comment system is gitment</span></span><br><span class="line"><span class="comment">## gitment url: https://github.com/imsun/gitment</span></span><br><span class="line"><span class="attr">comment:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">owner:</span></span><br><span class="line">  <span class="attr">repo:</span></span><br><span class="line">  <span class="attr">client_id:</span></span><br><span class="line">  <span class="attr">client_secret:</span></span><br></pre></td></tr></table></figure><h3 id="Tip"><a href="#Tip" class="headerlink" title="Tip"></a>Tip</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Tip</span></span><br><span class="line"><span class="attr">tip:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">content:</span> <span class="string">欢迎访问</span> <span class="string">&lt;a</span> <span class="string">href=&quot;https://www.dusign.net&quot;</span> <span class="string">target=&quot;dusign&quot;&gt;dusign&lt;/a&gt;</span> <span class="string">的博客，博客系统一键分享的功能还在完善中，请大家耐心等待。</span></span><br><span class="line">          <span class="string">若有问题或者有好的建议欢迎留言，笔者看到之后会及时回复。</span></span><br><span class="line">          <span class="string">评论点赞需要github账号登录，如果没有账号的话请点击</span> </span><br><span class="line">          <span class="string">&lt;a</span> <span class="string">href=&quot;https://github.com&quot;</span> <span class="string">target=&quot;view_window&quot;</span> <span class="string">&gt;</span> <span class="string">github</span> <span class="string">&lt;/a&gt;</span> <span class="string">注册，</span> <span class="string">谢谢</span> <span class="string">!</span></span><br></pre></td></tr></table></figure><h3 id="Color-Sheme"><a href="#Color-Sheme" class="headerlink" title="Color Sheme"></a>Color Sheme</h3><p>Set the <code>enable</code> value of the desired color sheme to <code>true</code>. If the value of <code>bg_effects.star.enable</code> is <code>true</code>, please modify the value of <code>highlight_theme</code> in <code>./themes/snail/_config.yml</code> to <code>night</code>.</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Color Sheme</span></span><br><span class="line"><span class="comment">## If there is no effect after modification, please empty the cache and try again.</span></span><br><span class="line"><span class="comment">## ⚠️ The following special effects will take up a lot of cpu resorces, please open it carefully.</span></span><br><span class="line"><span class="attr">bg_effects:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">line:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">color:</span> <span class="number">129</span><span class="string">,200,61</span></span><br><span class="line">    <span class="attr">pointColor:</span> <span class="number">129</span><span class="string">,200,61</span></span><br><span class="line">    <span class="attr">opacity:</span> <span class="number">0.7</span></span><br><span class="line">    <span class="attr">zIndex:</span> <span class="number">-9</span></span><br><span class="line">    <span class="attr">count:</span> <span class="number">99</span></span><br><span class="line">  <span class="attr">mouse_click:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">content:</span> <span class="string">&#x27;&quot;🌱&quot;,&quot;just do it&quot;,&quot;🌾&quot;,&quot;🍀&quot;,&quot;don<span class="char escape_">&#x27;&#x27;</span>t give up&quot;,&quot;🍂&quot;,&quot;🌻&quot;,&quot;try it again&quot;,&quot;🍃&quot;,&quot;never say die&quot;,&quot;🌵&quot;,&quot;🌿&quot;,&quot;🌴&quot;&#x27;</span></span><br><span class="line">    <span class="attr">color:</span> <span class="string">&#x27;&quot;rgb(121,93,179)&quot;</span></span><br><span class="line"><span class="string">          ,&quot;rgb(76,180,231)&quot;</span></span><br><span class="line"><span class="string">          ,&quot;rgb(184,90,154)&quot;</span></span><br><span class="line"><span class="string">          ,&quot;rgb(157,211,250)&quot;</span></span><br><span class="line"><span class="string">          ,&quot;rgb(255,0,0)&quot;</span></span><br><span class="line"><span class="string">          ,&quot;rgb(242,153,29)&quot;</span></span><br><span class="line"><span class="string">          ,&quot;rgb(23,204,16)&quot;</span></span><br><span class="line"><span class="string">          ,&quot;rgb(222,0,0)&quot;</span></span><br><span class="line"><span class="string">          ,&quot;rgb(22,36,92)&quot;</span></span><br><span class="line"><span class="string">          ,&quot;rgb(127,24,116)&quot;</span></span><br><span class="line"><span class="string">          ,&quot;rgb(119,195,79)&quot;</span></span><br><span class="line"><span class="string">          ,&quot;rgb(4,77,34)&quot;</span></span><br><span class="line"><span class="string">          ,&quot;rgb(122,2,60)&quot;&#x27;</span></span><br><span class="line">  <span class="attr">star:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><h2 id="Releases"><a href="#Releases" class="headerlink" title="Releases"></a>Releases</h2><p>V1.0</p><ul><li>fix the bugs</li><li>add comment system</li><li>add notice tips</li><li>add star sheme</li></ul><h2 id="License"><a href="#License" class="headerlink" title="License"></a>License</h2><p>Apache License 2.0 Copyright(c) 2018-2020 <a href="https://github.com/dusign">Dusign</a>   </p><p><a href="https://github.com/dusign/hexo-theme-snail">hexo-theme-snail</a> is derived from <a href="https://github.com/Huxpro/huxpro.github.io">Huxpro</a> Apache License 2.0. Copyright (c) 2015-2020 Huxpro</p>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo-theme-snail </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>经典排序、查找算法</title>
      <link href="/2016/01/05/%E6%8E%92%E5%BA%8F%E4%B8%8E%E6%9F%A5%E6%89%BE%E6%80%BB%E7%BB%93/"/>
      <url>/2016/01/05/%E6%8E%92%E5%BA%8F%E4%B8%8E%E6%9F%A5%E6%89%BE%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p><img src="/ranking.png"></p><h1 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h1><h2 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h2><ol><li>基本思想：在要排序的一组数中，假设前面(n-1) [n&gt;&#x3D;2] 个数已经是排好顺序的，现在要把第n个数插到前面的有序数中，使得这n个数也是排好顺序的。如此反复循环，直到全部排好顺序。  </li><li>实例:<br><img src="/%E6%8F%92%E5%85%A5.png"></li></ol><h2 id="希尔排序（也称最小增量排序）"><a href="#希尔排序（也称最小增量排序）" class="headerlink" title="希尔排序（也称最小增量排序）"></a>希尔排序（也称最小增量排序）</h2><ol><li>基本思想：算法先将要排序的一组数按某个增量d（n&#x2F;2,n为要排序数的个数）分成若干组，每组中记录的下标相差d.对每组中全部元素进行直接插入排序，然后再用一个较小的增量（d&#x2F;2）对它进行分组，在每组中再进行直接插入排序。当增量减到1时，进行直接插入排序后，排序完成。</li><li>实例：<br><img src="/%E5%B8%8C%E5%B0%94.png"></li></ol><h2 id="简单选择排序"><a href="#简单选择排序" class="headerlink" title="简单选择排序"></a>简单选择排序</h2><ol><li>基本思想：在要排序的一组数中，选出最小的一个数与第一个位置的数交换;然后在剩下的数当中再找最小的与第二个位置的数交换，如此循环到倒数第二个数和最后一个数比较为止。</li><li>实例：<br><img src="/%E9%80%89%E6%8B%A9.png"></li></ol><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><ol><li>基本思想：堆排序是一种树形选择排序，是对直接选择排序的有效改进。<br><strong>堆的定义如下</strong>：具有n个元素的序列（h1,h2,…,hn),当且仅当满足（hi&gt;&#x3D;h2i,hi&gt;&#x3D;2i+1）或（hi&lt;&#x3D;h2i,hi&lt;&#x3D;2i+1）(i&#x3D;1,2,…,n&#x2F;2)时称之为堆。在这里只讨论满足前者条件的堆。由堆的定义可以看出，堆顶元素（即第一个元素）必为最大项（大顶堆）。完全二叉树可以很直观地表示堆的结构。堆顶为根，其它为左子树、右子树。初始时把要排序的数的序列看作是一棵顺序存储的二叉树，调整它们的存储序，使之成为一个堆，这时堆的根节点的数最大。然后将根节点与堆的最后一个节点交换。然后对前面(n-1)个数重新调整使之成为堆。依此类推，直到只有两个节点的堆，并对它们作交换，最后得到有n个节点的有序序列。从算法描述来看，堆排序需要两个过程，一是建立堆，二是堆顶与堆的最后一个元素交换位置。所以堆排序有两个函数组成。一是建堆的渗透函数，二是反复调用渗透函数实现排序的函数。</li><li>实例：<br><strong>初始序列</strong>：46,79,56,38,40,84<br><strong>建堆</strong>：<br><img src="/%E5%BB%BA%E5%A0%86.png"><br><strong>交换，从堆中踢出最大数</strong><br><img src="/%E5%A0%86_%E4%BA%A4%E6%8D%A2.png"><br><strong>剩余结点再建堆，再交换踢出最大数</strong><br><img src="/%E5%A0%86_wan.png"><br>依次类推：最后堆中剩余的最后两个结点交换，踢出一个，排序完成。</li></ol><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><ol><li>基本思想：在要排序的一组数中，对当前还未排好序的范围内的全部数，自上而下对相邻的两个数依次进行比较和调整，让较大的数往下沉，较小的往上冒。即：每当两相邻的数比较后发现它们的排序与排序要求相反时，就将它们互换。</li><li>实例：<br><img src="/%E5%86%92%E6%B3%A1.png"></li></ol><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><ol><li>基本思想：选择一个基准元素,通常选择第一个元素或者最后一个元素,通过一趟扫描，将待排序列分成两部分,一部分比基准元素小,一部分大于等于基准元素,此时基准元素在其排好序后的正确位置,然后再用同样的方法递归地排序划分的两部分。</li><li>实例：<br><img src="/%E5%BF%AB%E6%8E%92.png"><br>上图中将待排序列分成两部分,一部分比基准元素小,一部分大于基准元素,然后对这两部分重复上图的求解过程。（这只是快速排序的一种实现方式，个人认为比较容易理解.</li></ol><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><ol><li>基本排序：归并（Merge）排序法是将两个（或两个以上）有序表合并成一个新的有序表，即把待排序序列分为若干个子序列，每个子序列是有序的。然后再把有序子序列合并为整体有序序列。</li><li>实例：<br><img src="/%E5%BD%92%E5%B9%B6.png"></li></ol><h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><ol><li>基本思想：将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后,数列就变成一个有序序列。  </li><li>实例：<br><img src="/%E5%9F%BA%E6%95%B0.png"></li></ol><h2 id="稳定性说明"><a href="#稳定性说明" class="headerlink" title="稳定性说明"></a>稳定性说明</h2><p>排序前，2（或者更多）个相等的数在序列的前后位置顺序和排序后它们在序列中的前后位置顺序一样。<br><strong>实例</strong>：  </p><table><thead><tr><th align="center"></th><th align="center"></th></tr></thead><tbody><tr><td align="center">待排序数列</td><td align="center">5,4,<strong>8</strong>,6,1,<em>8</em>,7,9</td></tr><tr><td align="center">排序结果</td><td align="center">1,4,5,6,7,8,8,9</td></tr><tr><td align="center">稳定</td><td align="center">1,4,5,6,7,<strong>8</strong>,<em>8</em>,9</td></tr><tr><td align="center">不稳定</td><td align="center">1,4,5,6,7,<em>8</em>,<strong>8</strong>,9</td></tr></tbody></table><p>说明：对比红色的8和紫色的8，看他们排序前后的位置。排序前，红8在紫8前面，如果排序后红8仍然在紫8前面，则排序算法稳定，否则不稳定。</p><p>现在我们分析一下8种排序算法的稳定性。</p><p>（1）直接插入排序：一般插入排序，比较是从有序序列的最后一个元素开始，如果比它大则直接插入在其后面，否则一直往前比。如果找到一个和插入元素相等的，那么就插入到这个相等元素的后面。插入排序是稳定的。</p><p>（2）希尔排序：希尔排序是按照不同步长对元素进行插入排序，一次插入排序是稳定的，不会改变相同元素的相对顺序，但在不同的插入排序过程中，相同的元素可能在各自的插入排序中移动，稳定性就会被破坏，所以希尔排序不稳定。</p><p>（3）简单选择排序：在一趟选择，如果当前元素比一个元素小，而该小的元素又出现在一个和当前元素相等的元素后面，那么交换后稳定性就被破坏了。光说可能有点模糊，来看个小实例：858410，第一遍扫描，第1个元素8会和4交换，那么原序列中2个8的相对前后顺序和原序列不一致了，所以选择排序不稳定。</p><p>（4）堆排序：堆排序的过程是从第n&#x2F;2开始和其子节点共3个值选择最大(大顶堆)或者最小(小顶堆),这3个元素之间的选择当然不会破坏稳定性。但当为n&#x2F;2-1, n&#x2F;2-2, …这些父节点选择元素时，有可能第n&#x2F;2个父节点交换把后面一个元素交换过去了，而第n&#x2F;2-1个父节点把后面一个相同的元素没有交换，所以堆排序并不稳定。</p><p>（5）冒泡排序：由前面的内容可知，冒泡排序是相邻的两个元素比较，交换也发生在这两个元素之间，如果两个元素相等，不用交换。所以冒泡排序稳定。</p><p>（6）快速排序：在中枢元素和序列中一个元素交换的时候，很有可能把前面的元素的稳定性打乱。还是看一个小实例：6 4 4 5 4 7 8 9，第一趟排序，中枢元素6和第三个4交换就会把元素4的原序列破坏，所以快速排序不稳定。</p><p>（7）归并排序：在分解的子列中，有1个或2个元素时，1个元素不会交换，2个元素如果大小相等也不会交换。在序列合并的过程中，如果两个当前元素相等时，我们把处在前面的序列的元素保存在结果序列的前面，所以，归并排序也是稳定的。</p><p>（8）基数排序：是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序，最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。基数排序基于分别排序，分别收集，所以是稳定的。</p><p>8种排序的分类，稳定性，时间复杂度和空间复杂度总结：<br><img src="/%E6%8E%92%E5%BA%8F%E6%80%BB%E7%BB%93.png">  </p><hr><h1 id="查找算法"><a href="#查找算法" class="headerlink" title="查找算法"></a>查找算法</h1><p>顺序查找，二分法查找（折半查找），分块查找，散列表<br><img src="/%E6%9F%A5%E6%89%BE.png">  </p><h2 id="顺序查找"><a href="#顺序查找" class="headerlink" title="顺序查找"></a>顺序查找</h2><p>从表的一端开始，顺序扫描表，依次将扫描到的结点关键字和给定值（假定为a）相比较，若当前结点关键字与a相等，则查找成功；若扫描结束后，仍未找到关键字等于a的结点，则查找失败。<br>说白了就是，从头到尾，一个一个地比，找着相同的就成功，找不到就失败。很明显的缺点就是查找效率低。<br>适用于线性表的顺序存储结构和链式存储结构。<br><img src="/%E6%9F%A5%E6%89%BE_1.png"><br><strong>计算平均查找长度</strong><br>例如上表，查找1，需要1次，查找2需要2次，依次往下推，可知查找16需要16次，<br>可以看出，我们只要将这些查找次数求和（我们初中学的，上底加下底乘以高除以2），然后除以结点数，即为平均查找长度。<br>设n&#x3D;节点数<br>平均查找长度&#x3D;（n+1）&#x2F; 2</p><h2 id="二分法查找（折半查找）"><a href="#二分法查找（折半查找）" class="headerlink" title="二分法查找（折半查找）"></a>二分法查找（折半查找）</h2><p>前提：</p><p>（1）确定该区间的中点位置：mid&#x3D;（low+high）&#x2F;2</p><p>min代表区间中间的结点的位置，low代表区间最左结点位置，high代表区间最右结点位置</p><p>（2）将待查a值与结点mid的关键字（下面用R[mid].key）比较，若相等，则查找成功，否则确定新的查找区间：</p><blockquote><p>如果R[mid].key&gt;a，则由表的有序性可知，R[mid].key右侧的值都大于a，所以等于a的关键字如果存在，必然在R[mid].key左边的表中。这时high&#x3D;mid-1<br>如果R[mid].key&lt;a，则等于a的关键字如果存在，必然在R[mid].key右边的表中。这时low&#x3D;mid<br>如果R[mid].key&#x3D;a，则查找成功。</p></blockquote><p>（3）下一次查找针对新的查找区间，重复步骤（1）和（2）</p><p>（4）在查找过程中，low逐步增加，high逐步减少，如果high&lt;low，则查找失败。</p><p><img src="/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.png"><br>平均查找长度&#x3D;Log2(n+1)-1</p><p>注：虽然二分法查找的效率高，但是要将表按关键字排序。而排序本身是一种很费时的运算，所以二分法比较适用于顺序存储结构。为保持表的有序性，在顺序结构中插入和删除都必须移动大量的结点。因此，二分查找特别适用于那种一经建立就很少改动而又经常需要查找的线性表。</p><h2 id="分块查找"><a href="#分块查找" class="headerlink" title="分块查找"></a>分块查找</h2><p>二分查找表使分块有序的线性表和索引表（抽取各块中的最大关键字及其起始位置构成索引表）组成，由于表是分块有序的，所以索引表是一个递增有序表，因此采用顺序或二分查找索引表，以确定待查结点在哪一块，由于块内无序，只能用顺序查找。<br><img src="/%E5%88%86%E5%9D%97.png"><br>设表共n个结点，分b块，s&#x3D;n&#x2F;b</p><p>(分块查找索引表)平均查找长度&#x3D;Log2（n&#x2F;s+1）+s&#x2F;2</p><p>(顺序查找索引表)平均查找长度&#x3D;(S2+2S+n)&#x2F;(2S)</p><p>注：分块查找的优点是在表中插入或删除一个记录时，只要找到该记录所属块，就在该块中进行插入或删除运算（因块内无序，所以不需要大量移动记录）。它主要代价是增加一个辅助数组的存储控件和将初始表分块排序的运算。</p><p>它的性能介于顺序查找和二分查找之间。</p><h2 id="散列表（哈希表）"><a href="#散列表（哈希表）" class="headerlink" title="散列表（哈希表）"></a>散列表（哈希表）</h2><p>散列表查找技术不同于顺序查找、二分查找、分块查找。它不以关键字的比较为基本操作，采用直接寻址技术。在理想情况下，无须任何比较就可以找到待查关键字，查找的期望时间为O(1)。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序 </tag>
            
            <tag> 查找 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
