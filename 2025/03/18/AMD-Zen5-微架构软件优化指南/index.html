<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI" />
    <meta name="baidu-site-verification" content="093lY4ziMu" />
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="description" content="记录点滴">
    <meta name="keyword"  content="加油, 个人博客">
    <link rel="shortcut icon" href="/img/ironman-draw.png">
    <!-- Place this tag in your head or just before your close body tag. -->
    <script async defer src="https://buttons.github.io/buttons.js"></script>
    <!--<link href='http://fonts.googleapis.com/css?family=Montserrat:400,700' rel='stylesheet' type='text/css'>-->
    <title>
        
          AMD Zen5 微架构软件优化指南 - Sven-Blog
        
    </title>

    <link rel="canonical" href="https://allenzf.github.io/2025/03/18/AMD-Zen5-微架构软件优化指南/">

    <!-- Bootstrap Core CSS -->
    
<link rel="stylesheet" href="/css/bootstrap.min.css">


    <!-- Custom CSS --> 
    
        
<link rel="stylesheet" href="/css/dusign-light.css">

        
<link rel="stylesheet" href="/css/dusign-common-light.css">

        
<link rel="stylesheet" href="/css/font-awesome.css">

        
<link rel="stylesheet" href="/css/toc.css">

        <!-- background effects end -->
    
    
    <!-- Pygments Highlight CSS -->
    
<link rel="stylesheet" href="/css/highlight.css">


    
<link rel="stylesheet" href="/css/widget.css">


    
<link rel="stylesheet" href="/css/rocket.css">


    
<link rel="stylesheet" href="/css/signature.css">


    
<link rel="stylesheet" href="/css/fonts.googleapis.css">


    <link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.3.0/css/font-awesome.min.css">

    <!-- photography -->
    
<link rel="stylesheet" href="/css/photography.css">


    <!-- ga & ba script hoook -->
    <script></script>
<meta name="generator" content="Hexo 8.1.0"></head>


<!-- hack iOS CSS :active style -->
<body ontouchstart="">

    <!-- background effects start -->
    
    <!-- background effects end -->

	<!-- Modified by Yu-Hsuan Yen -->
<!-- Post Header -->
<style type="text/css">
    header.intro-header{
        
            
                background-image: linear-gradient(rgba(0, 0, 0, 0.3), rgba(0, 0, 0, 0.3)), url('../../../../img/header_img/Iron-Man-3.jpg')
                /*post*/
            
        
    }
    
    #signature{
        background-image: url('/img/signature/Just-do-it-white.png');
    }
    
</style>

<header class="intro-header" >
    <!-- Signature -->
    <div id="signature">
        <div class="container">
            <div class="row">
                <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                
                    <div class="post-heading">
                        <div class="tags">
                            
                              <a class="tag" href="/tags/#x86" title="x86">x86</a>
                            
                              <a class="tag" href="/tags/#微架构" title="微架构">微架构</a>
                            
                        </div>
                        <h1>AMD Zen5 微架构软件优化指南</h1>
                        <h2 class="subheading">软件优化参考</h2>
                        <span class="meta">
                            Posted by 周郎借风 on
                            2025-03-18
                        </span>

                        
                            <div class="blank_box"></div>
                            <span class="meta">
                                Words <span class="post-count">22.2k</span> and
                                Reading Time <span class="post-count">82</span> Minutes
                            </span>
                            <div class="blank_box"></div>
                            <!-- 不蒜子统计 start -->
                            <span class="meta">
                                Viewed <span id="busuanzi_value_page_pv"><i class="fa fa-spinner fa-spin"></i></span> Times
                            </span>
                            <!-- 不蒜子统计 end -->
                        

                    </div>
                

                </div>
            </div>
        </div>      
    </div>

    
    <div class="waveWrapper">
        <div class="wave wave_before" style="background-image: url('/img/wave-light.png')"></div>
        <div class="wave wave_after" style="background-image: url('/img/wave-light.png')"></div>
    </div>
    
</header>

	
    <!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">周郎借风</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <!-- Known Issue, found by Hux:
            <nav>'s height woule be hold on by its content.
            so, when navbar scale out, the <nav> will cover tags.
            also mask any touch event of tags, unfortunately.
        -->
        <div id="huxblog_navbar">
            <div class="navbar-collapse">
                <ul class="nav navbar-nav navbar-right">
                    <li>
                        <a href="/">主页</a>
                    </li>

                    

                        
                    

                        
                        <li>
                            <a href="/about/">关于</a>
                        </li>
                        
                    

                        
                        <li>
                            <a href="/categories/">分类</a>
                        </li>
                        
                    

                        
                        <li>
                            <a href="/archive/">归档</a>
                        </li>
                        
                    

                        
                    

                        
                    

                        
                    

                        
                    

                        
                    

                        
                    

                        
                    

                        
                    

                        
                    

                        
                    

                        
                    

                        
                    

                        
                    

                        
                    

                        
                    

                        
                    

                        
                    

                        
                    

                        
                    

                        
                    

                        
                    

                        
                    

                        
                    

                        
                    

                        
                    

                        
                    

                        
                    

                        
                    

                        
                    

                        
                    

                        
                    

                        
                    

                        
                    

                        
                    

                        
                        <li>
                            <a href="/tags/">标签</a>
                        </li>
                        
                    

                        
                        <li>
                            <a href="/photography/">摄影</a>
                        </li>
                        
                    

                        
                    

                        
                    

                        
                    

                        
                    

                        
                    

                        
                    
                    
                    
                    <li>
                        <a href="https://allenzf.github.io" target="_blank">中文博客</a>
                    </li>
                    
                </ul>
            </div>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>
<script>
    // Drop Bootstarp low-performance Navbar
    // Use customize navbar with high-quality material design animation
    // in high-perf jank-free CSS3 implementation
    var $body   = document.body;
    var $toggle = document.querySelector('.navbar-toggle');
    var $navbar = document.querySelector('#huxblog_navbar');
    var $collapse = document.querySelector('.navbar-collapse');

    $toggle.addEventListener('click', handleMagic)
    function handleMagic(e){
        if ($navbar.className.indexOf('in') > 0) {
        // CLOSE
            $navbar.className = " ";
            // wait until animation end.
            setTimeout(function(){
                // prevent frequently toggle
                if($navbar.className.indexOf('in') < 0) {
                    $collapse.style.height = "0px"
                }
            },400)
        }else{
        // OPEN
            $collapse.style.height = "auto"
            $navbar.className += " in";
        }
    }
</script>


    <!-- Main Content -->
    <!-- Post Content -->
<article>
    <div class="container">
        <div class="row">

            <!-- Post Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                post-container">

                <h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><ul>
<li><p><a href="#1-%E5%BC%95%E8%A8%80">1. 引言</a></p>
<ul>
<li><a href="#11-%E7%9B%AE%E6%A0%87%E5%8F%97%E4%BC%97">1.1 目标受众</a></li>
<li><a href="#12-%E7%9B%B8%E5%85%B3%E6%96%87%E6%A1%A3">1.2 相关文档</a></li>
<li><a href="#13-%E4%B8%93%E4%B8%9A%E6%9C%AF%E8%AF%AD">1.3 专业术语</a></li>
</ul>
</li>
<li><p><a href="#2-zen5-%E5%A4%84%E7%90%86%E5%99%A8%E5%BE%AE%E6%9E%B6%E6%9E%84">2. Zen5 处理器微架构</a></p>
<ul>
<li><a href="#21-%E5%85%B3%E9%94%AE%E5%BE%AE%E6%9E%B6%E6%9E%84%E7%89%B9%E6%80%A7">2.1 关键微架构特性</a></li>
<li><a href="#22-%E7%BC%93%E5%AD%98%E4%B8%8E%E6%95%B0%E6%8D%AE%E9%80%9A%E8%B7%AF">2.2 缓存与数据通路</a></li>
<li><a href="#23-%E6%8C%87%E4%BB%A4%E5%88%86%E8%A7%A3%E6%9C%BA%E5%88%B6">2.3 指令分解机制</a></li>
<li><a href="#24-%E8%B6%85%E6%A0%87%E9%87%8F%E6%9E%B6%E6%9E%84">2.4 超标量架构</a></li>
<li><a href="#25-%E5%A4%84%E7%90%86%E5%99%A8%E7%BB%93%E6%9E%84">2.5 处理器结构</a></li>
<li><a href="#26-%E7%BC%93%E5%AD%98%E6%93%8D%E4%BD%9C">2.6 缓存操作</a><ul>
<li><a href="#261-l1i-cache">2.6.1 L1I Cache</a></li>
<li><a href="#262-l1d-cache">2.6.2 L1D Cache</a><ul>
<li><a href="#2621-bank-conflicts">2.6.2.1 Bank Conflicts</a></li>
<li><a href="#2622-512bit-loadstore-%E6%93%8D%E4%BD%9C">2.6.2.2 512bit load&#x2F;store 操作</a></li>
<li><a href="#2623-%E5%9F%BA%E4%BA%8E%E7%BA%BF%E6%80%A7%E5%9C%B0%E5%9D%80%E7%9A%84utagway-predictor">2.6.2.3 基于线性地址的utag&#x2F;way-predictor</a></li>
</ul>
</li>
<li><a href="#263-l2-cache">2.6.3 L2 Cache</a></li>
<li><a href="#264-l3-cache">2.6.4 L3 Cache</a></li>
</ul>
</li>
<li><a href="#27-%E5%86%85%E5%AD%98%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2">2.7 内存地址转换</a><ul>
<li><a href="#271-%E4%B8%A4%E7%BA%A7tlb%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1">2.7.1 两级TLB结构设计</a></li>
<li><a href="#272-%E7%A1%AC%E4%BB%B6%E9%A1%B5%E8%A1%A8%E9%81%8D%E5%8E%86%E5%99%A8%E4%B8%8E%E5%8A%A0%E9%80%9F%E6%9C%BA%E5%88%B6">2.7.2 硬件页表遍历器与加速机制</a></li>
<li><a href="#273-%E8%99%9A%E6%8B%9F%E5%8C%96%E4%B8%8E%E8%83%BD%E6%95%88%E4%BC%98%E5%8C%96">2.7.3 虚拟化与能效优化</a></li>
<li><a href="#274-%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94%E4%B8%8E%E5%9C%BA%E6%99%AF%E5%BA%94%E7%94%A8">2.7.4 性能对比与场景应用</a></li>
</ul>
</li>
<li><a href="#28-%E5%88%86%E6%94%AF%E4%BC%98%E5%8C%96">2.8 分支优化</a><ul>
<li><a href="#281-%E5%88%86%E6%94%AF%E9%A2%84%E6%B5%8B%E5%99%A8">2.8.1 分支预测器</a><ul>
<li><a href="#2811-next-address-logic">2.8.1.1 next-address logic</a></li>
<li><a href="#2812-branch-target-buffer">2.8.1.2 Branch Target Buffer</a></li>
<li><a href="#2813-return-address-stack">2.8.1.3 Return Address Stack</a></li>
<li><a href="#2814-indirect-target-predictor">2.8.1.4 Indirect Target Predictor</a></li>
<li><a href="#2815-advanced-conditional-branch-direction-predictor">2.8.1.5 Advanced Conditional Branch Direction Predictor</a></li>
<li><a href="#2816-fetch-window-tracking-structure">2.8.1.6 Fetch Window Tracking Structure</a></li>
</ul>
</li>
<li><a href="#282">2.8.2 跨边界分支 Boundary Crossing Branches</a></li>
<li><a href="#283">2.8.3 循环对齐 Loop Alignment</a><ul>
<li><a href="#2831-%E7%BC%96%E7%A0%81%E5%A1%AB%E5%85%85%E4%BB%A5%E5%AE%9E%E7%8E%B0%E5%BE%AA%E7%8E%AF%E5%AF%B9%E9%BD%90">2.8.3.1 编码填充以实现循环对齐</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#29-%E5%8F%96%E6%8C%87%E4%B8%8E%E8%AF%91%E7%A0%81">2.9 取指与译码</a><ul>
<li><a href="#291-op-cache">2.9.1 Op Cache</a></li>
<li><a href="#292">2.9.2 依赖项消除的惯用方法Idioms for Dependency removal</a></li>
<li><a href="#293">2.9.3 分支融合</a></li>
<li><a href="#294-mov--alu-fusion">2.9.4 MOV + ALU Fusion</a></li>
<li><a href="#295-zero-cycle-move">2.9.5 Zero Cycle Move</a></li>
<li><a href="#296">2.9.6 栈指针跟踪以消除依赖</a></li>
<li><a href="#297">2.9.7 指令分发</a></li>
<li><a href="#298">2.9.8 使用 PAUSE 指令优化自旋循环</a></li>
<li><a href="#299">2.9.9 其他解码注意事项</a></li>
</ul>
</li>
<li><a href="#210">2.10 整数执行单元</a><ul>
<li><a href="#2101-schedulers">2.10.1 Schedulers</a></li>
<li><a href="#2102">2.10.2 执行单元</a></li>
<li><a href="#2103">2.10.3 退役控制单元</a></li>
</ul>
</li>
<li><a href="#211">2.11 浮点单元</a><ul>
<li><a href="#2111">2.11.1 浮点执行资源</a></li>
<li><a href="#2112">2.11.2 代码优化建议</a></li>
<li><a href="#2113-x87-%E4%BB%A3%E7%A0%81%E7%9A%84%E6%B5%AE%E7%82%B9%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96">2.11.3 x87 代码的浮点性能优化</a></li>
<li><a href="#2114">2.11.4 非规格化数</a></li>
<li><a href="#2115-xmm-%E5%AF%84%E5%AD%98%E5%99%A8%E5%90%88%E5%B9%B6%E4%BC%98%E5%8C%96">2.11.5 XMM 寄存器合并优化</a></li>
<li><a href="#2116-%E6%B7%B7%E5%90%88%E4%BD%BF%E7%94%A8-avx-%E5%92%8C-sse-%E6%8C%87%E4%BB%A4%E7%9A%84%E6%80%A7%E8%83%BD%E6%83%A9%E7%BD%9A">2.11.6 混合使用 AVX 和 SSE 指令的性能惩罚</a></li>
<li><a href="#2117-%E4%BD%95%E6%97%B6%E4%BD%BF%E7%94%A8-fma-%E8%80%8C%E9%9D%9E-fmulfadd">2.11.7 何时使用 FMA 而非 FMUL&#x2F;FADD</a></li>
</ul>
</li>
<li><a href="#212">2.12 加载-存储单元</a><ul>
<li><a href="#2121">2.12.1 数据预取</a></li>
</ul>
</li>
<li><a href="#213">2.13 写入数据优化</a><ul>
<li><a href="#2131-%E8%BD%AF%E4%BB%B6%E9%A2%84%E5%8F%96%E6%95%B0%E6%8D%AE%E6%88%96%E6%8C%87%E4%BB%A4">2.13.1 软件预取数据或指令</a></li>
<li><a href="#2132">2.13.2 写合并操作</a></li>
<li><a href="#2133">2.13.3 将写缓冲区数据发送到系统</a></li>
<li><a href="#2134">2.13.4 字符串存储优化</a></li>
</ul>
</li>
<li><a href="#214">2.14 同步多线程</a></li>
</ul>
</li>
</ul>
<hr>
<h1 id="1-引言"><a href="#1-引言" class="headerlink" title="1. 引言"></a>1. 引言</h1><h2 id="1-1-目标受众"><a href="#1-1-目标受众" class="headerlink" title="1.1 目标受众"></a>1.1 目标受众</h2><ul>
<li><strong>编译器&#x2F;汇编器设计者</strong></li>
<li><strong>高性能代码开发者</strong>（C&#x2F;C++&#x2F;汇编语言）</li>
<li>要求熟悉 AMD64 指令集与架构（寄存器&#x2F;编程模式）</li>
</ul>
<h2 id="1-2-相关文档"><a href="#1-2-相关文档" class="headerlink" title="1.2 相关文档"></a>1.2 相关文档</h2><table>
<thead>
<tr>
<th>文档标题</th>
<th>编号</th>
</tr>
</thead>
<tbody><tr>
<td>AMD64 架构程序员手册（应用编程）</td>
<td>24592</td>
</tr>
<tr>
<td>AMD64 架构程序员手册（系统编程）</td>
<td>24593</td>
</tr>
<tr>
<td>Zen5 处理器编程参考（PPR）</td>
<td>55901</td>
</tr>
</tbody></table>
<h2 id="1-3-专业术语"><a href="#1-3-专业术语" class="headerlink" title="1.3 专业术语"></a>1.3 专业术语</h2><table>
<thead>
<tr>
<th>术语</th>
<th>定义</th>
</tr>
</thead>
<tbody><tr>
<td>CPU Complex</td>
<td>共享 L3 缓存的 CPU 核心组</td>
</tr>
<tr>
<td>Dispatching</td>
<td>将宏操作（macro-ops）从前端传输到乱序后端</td>
</tr>
<tr>
<td>Issuing</td>
<td>从调度器选择微操作（micro-ops）派发到执行管道</td>
</tr>
</tbody></table>
<hr>
<h1 id="2-Zen5-处理器微架构"><a href="#2-Zen5-处理器微架构" class="headerlink" title="2. Zen5 处理器微架构"></a>2. Zen5 处理器微架构</h1><h2 id="2-1-关键微架构特性"><a href="#2-1-关键微架构特性" class="headerlink" title="2.1 关键微架构特性"></a>2.1 关键微架构特性</h2><ul>
<li><strong>指令集支持</strong>：<ul>
<li><strong>AVX-512 全功能扩展</strong>（F&#x2F;BW&#x2F;VL&#x2F;CD&#x2F;VNNI&#x2F;BF16 等 12 个子集）</li>
<li><strong>安全扩展</strong>：SEV-SNP（RMPUPDATE&#x2F;PVALIDATE）</li>
<li><strong>虚拟化加速</strong>：INVLPGB&#x2F;TLBSYNC</li>
</ul>
</li>
<li><strong>缓存层次</strong>：<ul>
<li>L1 指令缓存：32KB&#x2F;8-way</li>
<li>L1 数据缓存：48KB&#x2F;12-way（支持 512 位存储）</li>
<li>L2 缓存：1MB&#x2F;16-way（14 周期延迟）</li>
<li>L3 缓存：最高 96MB（46 周期延迟）</li>
</ul>
</li>
</ul>
<hr>
<h2 id="2-2-缓存与数据通路"><a href="#2-2-缓存与数据通路" class="headerlink" title="2.2 缓存与数据通路"></a>2.2 缓存与数据通路</h2><table border="1">
  <thead align="center">
  <tr>
    <td colspan='17' > Fetch Width </td>
  </tr>
  </thead>
  <tbody align="center">
  <tr>
    <td rowspan='2' align='left' > OC Fetch </td>
    <td colspan='8' > 128 </td>
    <td colspan='4'> </td>
  </tr>
  <tr>
    <td colspan='4'> </td>
    <td colspan='8' > 128 </td>
  </tr>
  <tr>
    <td align='left'> Cacheline </td>
    <td colspan='4' > 64 </td>
    <td colspan='4' > 64 </td>
    <td colspan='4' > 64 </td>
  </tr>
  <tr>
    <td align='left'> IC Fetch </td>
    <td colspan='2' > 32 </td>
    <td colspan='2' > 32 </td>
    <td colspan='2' > 32 </td>
    <td colspan='2' > 32 </td>
    <td colspan='2' > 32 </td>
    <td colspan='2' > 32 </td>
  </tr>
  <tr>
    <td align='left'> Decode </td>
    <td > 16 </td>
    <td > 16 </td>
    <td > 16 </td>
    <td > 16 </td>
    <td > 16 </td>
    <td > 16 </td>
    <td > 16 </td>
    <td > 16 </td>
    <td > 16 </td>
    <td > 16 </td>
    <td > 16 </td>
    <td > 16 </td>
  </tr>
  </tbody>
</table>

<table>
<thead>
<tr>
<th>参数</th>
<th>宽度（字节）</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>OC Fetch</td>
<td>128</td>
<td>Op Cache单次抓取指令块大小，支持高吞吐指令预取</td>
</tr>
<tr>
<td>Cacheline</td>
<td>64</td>
<td>所有缓存层级的行大小（L1&#x2F;L2&#x2F;L3），决定内存对齐优化粒度</td>
</tr>
<tr>
<td>IC Fetch</td>
<td>32</td>
<td>L1指令缓存单周期抓取32字节指令块，支持双解码器并行处理</td>
</tr>
<tr>
<td>Decode</td>
<td>16</td>
<td>解码器单周期处理16字节指令，需结合宏操作拆分策略优化指令密度</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>参数</th>
<th>值</th>
</tr>
</thead>
<tbody><tr>
<td>缓存行大小 Cacheline</td>
<td>64 字节</td>
</tr>
<tr>
<td>数据通路宽度 Data Pipe</td>
<td>64 字节</td>
</tr>
<tr>
<td>存储提交宽度 Store Commit</td>
<td>64 字节</td>
</tr>
</tbody></table>
<p><strong>数据对齐优化</strong>：</p>
<ul>
<li>64 字节对齐访问避免跨缓存行惩罚</li>
<li>256 位向量建议 32 字节对齐（性能提升 20%）</li>
</ul>
<hr>
<h2 id="2-3-指令分解机制"><a href="#2-3-指令分解机制" class="headerlink" title="2.3 指令分解机制"></a>2.3 指令分解机制</h2><p><strong>1. 指令实现方式</strong></p>
<ul>
<li><strong>宏操作（Macro-ops）</strong>：处理器管理的主要工作单元。</li>
<li><strong>微操作（Micro-ops）</strong>：在处理器执行单元中执行的原始操作。</li>
<li><strong>AMD64指令集支持</strong>：通过宏操作和微操作实现，遵循高性能原则，包括固定长度编码、规整化指令字段和大寄存器集。</li>
<li><strong>微架构优势</strong>：提升处理器内核性能，并为未来设计提供直接的可扩展性。</li>
</ul>
<p><strong>2. 指令分类</strong></p>
<ul>
<li><strong>快速单路径（Fast Path Single）</strong>：一个宏操作。</li>
<li><strong>快速双路径（Fast Path Double）</strong>：两个宏操作。</li>
<li><strong>微码（Microcode）</strong>：多于两个宏操作。</li>
<li><strong>宏操作容量</strong>：通常一个宏操作最多可包含两个微操作。</li>
</ul>
<p><strong>3. 指令映射</strong></p>
<ul>
<li><strong>指令到宏操作的映射</strong>：指令被映射到宏操作。</li>
<li><strong>宏操作到微操作的映射</strong>：宏操作被映射到一个或多个微操作。</li>
<li><strong>示例表格</strong>：展示了指令如何映射到宏操作，以及宏操作如何映射到微操作。</li>
</ul>
<table>
<thead>
<tr>
<th>指令示例</th>
<th>Macro-ops 宏操作</th>
<th>Micro-ops 微操作</th>
<th>类型</th>
</tr>
</thead>
<tbody><tr>
<td><code>MOV reg, [mem]</code></td>
<td>1</td>
<td>1 : load</td>
<td>Fastpath single</td>
</tr>
<tr>
<td><code>ADD [mem], reg</code></td>
<td>1</td>
<td>2 : load&#x2F;store, add</td>
<td>Fastpath double</td>
</tr>
<tr>
<td><code>REP MOVS [mem], [mem]</code></td>
<td>M</td>
<td>many</td>
<td>Microcode</td>
</tr>
</tbody></table>
<hr>
<h2 id="2-4-超标量架构"><a href="#2-4-超标量架构" class="headerlink" title="2.4 超标量架构"></a>2.4 超标量架构</h2><p>Zen5处理器是一款支持乱序执行的双线程超标量AMD64处理器。其采用解耦执行单元的结构来处理fetch&#x2F;branch-predict, decode, schedule&#x2F;execute, 和 retirement pilelines.</p>
<ul>
<li><strong>独立的整数调度器队列</strong>，分组设计，服务于6个ALU算术逻辑单元流水线</li>
<li><strong>独立的地址生成队列</strong>，分组设计，服务于4个AGU地址生成单元流水线</li>
<li><strong>两套解耦的浮点调度器</strong>，每套调度器控制2个浮点流水线</li>
<li><strong>一套专用的浮点调度器</strong>，负责浮点store data，或者浮点到整数数据转换流水线</li>
</ul>
<p>这些调度器可协同工作，最高可同时向6个ALU流水线、4个AGU地址生成流水线和6个FPU浮点处理流水线分发16个微操作。</p>
<hr>
<h2 id="2-5-处理器结构"><a href="#2-5-处理器结构" class="headerlink" title="2.5 处理器结构"></a>2.5 处理器结构</h2><p><img src="/image_1.png" alt="处理器结构"></p>
<p><strong>L1I缓存</strong>：32 KB，8路组相联，64B&#x2F;周期（分2组32字节块喂给2个解码器管线&lt;双线程&gt;）</p>
<p><strong>L1D缓存</strong>：48 KB，12路组相联，4读&#x2F;2写端口，64字节填充与替换策略</p>
<p><strong>分支预测器</strong>：2分支&#x2F;周期</p>
<p><strong>解码器</strong>：单线程4指令&#x2F;周期，双线程8指令&#x2F;周期</p>
<p><strong>微码缓存</strong>：可缓存6K条指令，每个周期12条指令，单个线程6条&#x2F;周期，存储被解码的指令信息</p>
<p><strong>微操作队列UOPQ</strong>: 每个周期调度（Dispatch）8条宏操作</p>
<p><strong>整数单元</strong></p>
<ul>
<li>一个整数重命名单元，一个周期可处理8条指令</li>
<li>2个独立的调度器，指令调度器一个周期最多 <strong>issue</strong> 6条整数指令; 地址生成调度器一个周期处理4条地址生成指令</li>
<li>通用寄存器位宽：64bit</li>
<li>6个ALU, 4个AGU</li>
</ul>
<p><strong>浮点单元</strong></p>
<ul>
<li>一个重命名单元，一个周期可处理6条指令</li>
<li>调度器：3组</li>
<li>向量寄存器：512bit</li>
<li>浮点运算单元：FMUL, FMA, FADD</li>
<li>存储和转换单元：Std, IntD</li>
</ul>
<hr>
<h2 id="2-6-缓存操作"><a href="#2-6-缓存操作" class="headerlink" title="2.6 缓存操作"></a>2.6 缓存操作</h2><p>Zen5微架构在三个层次使用5个缓存来加速指令执行和数据处理：<strong>专用L1I Cache, 专用的L1D Cache, 专用的L1 Op Cache, 每个Core（指令和数据统一）L2 Cache，高达96MB L3 Cache</strong></p>
<hr>
<h3 id="2-6-1-L1I-Cache"><a href="#2-6-1-L1I-Cache" class="headerlink" title="2.6.1 L1I Cache:"></a><strong>2.6.1 L1I Cache</strong>:</h3><ul>
<li>32KB，8路组相连，Cacheline 64 bytes（内存总线上512b&#x2F;cycle）</li>
<li>每周期64 bytes，即2个32字节对齐的块，提供给2个解码器管线&lt;双线程&gt;</li>
<li>主要功能：L1I Cache Miss时，从L2缓存提取缓存行-&gt;向解码器提供指令字节-&gt;预取指令</li>
</ul>
<p>当指令在L1指令缓存中未命中时，请求会从L2缓存中提取；如果L2缓存中也不存在，则从L3缓存（如果有）中提取；如果所有级别缓存均未命中，则从系统内存中提取。</p>
<p>当发生未命中时，L1指令缓存会为包含未命中地址的自然对齐的64字节缓存行生成填充请求。这些缓存行从分支预测单元生成的地址处预取。对于之前从未见过的缓存行，分支预测器通常预测为顺序访问，从而起到行预取器的作用，避免下游缓存未命中造成的停顿。</p>
<p>由于代码通常表现出空间局部性，预取是一种有效避免缓存未命中停顿的技术。缓存行替换基于最近最少使用（LRU）算法。L1指令缓存使用奇偶校验来防止错误。</p>
<hr>
<h3 id="2-6-2-L1D-Cache"><a href="#2-6-2-L1D-Cache" class="headerlink" title="2.6.2 L1D Cache:"></a><strong>2.6.2 L1D Cache</strong>:</h3><ul>
<li>48 KB, 12路组相联</li>
<li>工作模式，回写式，支持高吞吐量内存操作</li>
<li>最多4个load&#x2F;周期，其中最多2个512&#x2F;256&#x2F;128位 load操作</li>
<li>最多2个store&#x2F;周期, 大小8-256B，最多一个512位 store操作</li>
<li>纠错：ECC</li>
<li>硬件预取器将数据预取到L1D Cache，避免Miss</li>
<li>延迟：整数load,4-5周期；FPU load, 7-8周期</li>
<li>对齐：64B，否则至少惩罚1个周期，吞吐量降低50%</li>
<li>跨4 KB边界的未对齐操作在某些情况下会遭受额外的显著处罚<ul>
<li>AXI协议按4KB地址空间进行划分，跨4KB会被分成2次突发传输</li>
<li>Page分页按4KB粒度一个条目，跨页会导致MMU2次页表查询</li>
<li>未对齐访问可能引发异常</li>
<li>对于SIMD指令或向量化操作，跨4KB边界的未对齐访问可能破坏向量化条件，导致回退为标量处理</li>
</ul>
</li>
</ul>
<hr>
<h4 id="2-6-2-1-Bank-Conflicts"><a href="#2-6-2-1-Bank-Conflicts" class="headerlink" title="2.6.2.1 Bank Conflicts:"></a><strong>2.6.2.1 Bank Conflicts</strong>:</h4><p>L1数据缓存（L1 DC）采用分Bank结构提供多个访问端口。读端口由4个加载流水线（load pipe）和受害者缓存（victim read）共享，写操作则使用独立的写端口。地址的第5-3位（bits 5:3）以及访问大小与DC的Way（由线性地址的utag&#x2F;way预测器决定）共同决定访问所需的Bank。当多个操作请求同一Bank或端口时，会触发Bank冲突或端口冲突，导致需重新执行冲突的加载操作，表现为更高的加载延迟。</p>
<p>若怀疑存在Bank冲突，可通过以下方法缓解：</p>
<ul>
<li><strong>使用对齐内存访问</strong>：未对齐访问可能占用更多Bank或端口</li>
<li><strong>合并小粒度操作</strong>：将连续的字节级加载&#x2F;存储合并为双字（doubleword）或四字（quadword）操作</li>
<li><strong>优化存储操作</strong>：未对齐或小于双字大小的存储对Bank&#x2F;端口利用率最低</li>
<li><strong>循环展开与指令编排</strong>：对连续地址的流式访问循环进行展开，每组循环中合并最多4个标量加载（或2个向量&#x2F;浮点加载），以降低Bank冲突。但受乱序执行影响，指令编排不保证实际执行顺序</li>
</ul>
<hr>
<h4 id="2-6-2-2-512bit-load-store-操作："><a href="#2-6-2-2-512bit-load-store-操作：" class="headerlink" title="2.6.2.2 512bit load&#x2F;store 操作："></a><strong>2.6.2.2 512bit load&#x2F;store 操作</strong>：</h4><p><strong>1. 512位加载操作的执行逻辑</strong></p>
<p>Zen5的L1数据缓存（L1 DC）采用分Bank设计，支持每个周期最多两个512位加载操作。为实现512位（64字节）加载，硬件将两个256位加载流水线（Load Pipe）<strong>配对使用</strong>，以单周期完成一次完整操作</p>
<ul>
<li><strong>限制条件</strong>：若当前周期执行512位加载，则<strong>整数加载无法使用配对的流水线</strong>，因为两个256位流水线已被完全占用。这一设计通过动态分配流水线资源，优先保障大位宽操作的吞吐效率</li>
</ul>
<p><strong>2. 512位存储操作的执行逻辑</strong></p>
<p>512位存储操作被分解为两个独立<strong>微</strong>操作：</p>
<ul>
<li><strong>地址生成微操作（Store Address uOP）</strong>：计算存储地址并提交到存储队列。</li>
<li><strong>数据提交微操作（Store Data uOP）</strong>：将512位数据写入缓存行（需占用浮点单元的数据通路）</li>
<li><strong>资源占用</strong>：每个存储操作需占用<strong>两个派发槽（Dispatch Slots）和两个存储队列条目（Store Queue Entries）</strong>，以分别处理地址与数据</li>
</ul>
<p><strong>3. 硬件优化与约束</strong>：</p>
<p>Zen5的L1数据缓存支持每个周期最多两个存储操作，其中<strong>仅允许一个512位存储</strong>。这一限制源于存储队列的带宽与容量设计：</p>
<ul>
<li><strong>存储队列结构</strong>：每个条目需同时保存地址与数据元数据，512位存储因数据体积较大需拆分到两个条目</li>
<li><strong>浮点单元协同</strong>：512位存储的数据部分依赖浮点执行单元（FPU）的512位数据通路，而Zen5的FPU经过升级可直接处理完整512位数据包，避免了Zen4中双256位拼接的开销</li>
</ul>
<p><strong>4. 架构设计意义与性能权衡</strong></p>
<p><strong>4.1 AVX-512指令集优化</strong></p>
<p>Zen5通过引入<strong>真正的512位FPU单元</strong>，显著提升了AVX-512指令的执行效率。与Zen4使用双256位拼接的“伪512位”方案相比，Zen5的完整位宽支持降低了指令拆分带来的延迟，并减少了功耗</p>
<ul>
<li><strong>数据吞吐提升</strong>：在AI推理与科学计算中，512位操作的单周期完成能力可提高向量化代码的吞吐量，例如矩阵乘法（FMA指令）的峰值性能提升约30%</li>
</ul>
<p><strong>4.2 资源冲突管理</strong></p>
<p>Zen5通过<strong>动态流水线分配策略</strong>平衡大位宽操作与常规整数操作的需求：</p>
<ul>
<li><strong>优先级机制</strong>：512位加载&#x2F;存储优先占用流水线资源，确保向量化密集型任务的效率，而整数操作通过乱序执行引擎（OoO）调度填补空闲周期</li>
<li><strong>队列深度优化</strong>：存储队列条目数量的增加（相比Zen4）缓解了拆分微操作导致的资源争用问题，减少流水线停顿概率</li>
</ul>
<hr>
<h4 id="2-6-2-3-基于线性地址的utag-way-predictor"><a href="#2-6-2-3-基于线性地址的utag-way-predictor" class="headerlink" title="2.6.2.3 基于线性地址的utag&#x2F;way-predictor"></a><strong>2.6.2.3 基于线性地址的utag&#x2F;way-predictor</strong></h4><p>L1数据缓存的标签中存储了一个<strong>基于线性地址的微标签（UTAG）</strong>，该标签用于标记缓存行最初访问时使用的线性地址。</p>
<ul>
<li><strong>加载操作</strong>利用UTAG，在物理地址通过TLB转换完成之前，直接根据线性地址预测应访问的缓存路（Way）。UTAG是线性地址的哈希值。</li>
<li>这种基于线性地址的路预测机制允许在读取缓存数据前<strong>精准预测目标缓存行所在的路</strong>，从而只需访问单一路而非全部12路，显著降低功耗并减少Bank冲突。</li>
</ul>
<p><strong>1. UTAG误判的可能情况</strong>：</p>
<ul>
<li><strong>误命中</strong>（预测命中但实际未命中）或<strong>误未命中</strong>（预测未命中但实际命中）。此时会触发向L2缓存的填充请求，并在L2响应后更新UTAG。</li>
<li><strong>线性别名冲突</strong>：不同线性地址映射到同一物理地址时，可能导致性能损失。例如，对同一物理地址但不同线性别名的加载操作会触发L1缓存未命中，需向L2请求数据，延迟通常等同于L2命中时间。</li>
<li><strong>哈希冲突</strong>：不同线性地址（未映射到同一物理地址）因哈希碰撞导致UTAG冲突。此时，L1缓存索引（线性地址[11:6]）下仅允许存在一个匹配哈希的缓存行，其他冲突行将被标记为无效。</li>
</ul>
<p><strong>2. UTAG的核心设计思想</strong></p>
<p>UTAG是Zen5 L1数据缓存的关键创新，其核心逻辑在于提前利用线性地址哈希预测缓存路，从而规避传统物理地址转换（TLB查询）的延迟。通过将缓存路选择与物理地址解耦，UTAG在以下方面实现优化：</p>
<ul>
<li><strong>功耗降低</strong>：无需激活所有12路缓存，仅读取预测路的数据</li>
<li><strong>Bank冲突缓解</strong>：减少多路并行访问引发的Bank资源争用，提升吞吐量</li>
</ul>
<hr>
<h3 id="2-6-3-L2-Cache"><a href="#2-6-3-L2-Cache" class="headerlink" title="2.6.3 L2 Cache"></a><strong>2.6.3 L2 Cache</strong></h3><p>AMD Zen5微架构为每个核心实现了一个<strong>统一的16路组相联回写式L2缓存</strong>。该片上L2缓存采用<strong>包含性策略</strong>（Inclusive），即包含核心内所有L1缓存的内容。L2缓存容量为1 MB，其加载到使用的延迟可变且<strong>不低于14个周期</strong>。L2到L1的数据通路宽度为64字节。</p>
<p><strong>1. 包含性策略（Inclusive Policy）</strong><br><strong>1.1 定义与核心特性</strong><br>包含性策略是多级缓存架构中的一种设计原则，指<strong>外层缓存（如L3）包含所有内层缓存（如L1&#x2F;L2）的有效缓存行</strong>。例如，若L1缓存中存在某数据，则该数据的副本也必须存在于L2或L3缓存中 。</p>
<ul>
<li>其核心特性包括：<ul>
<li><strong>数据冗余</strong>：内层缓存的数据必须在外层缓存中存在备份。</li>
<li><strong>一致性简化</strong>：外层缓存作为全局数据状态的“目录”，可快速过滤一致性请求（如snoop操作），减少核间通信开销。</li>
<li><strong>空间效率牺牲</strong>：因数据重复存储，外层缓存的实际可用容量降低。</li>
</ul>
</li>
</ul>
<p><strong>1.2 工作原理</strong><br>以L1和L2缓存为例，包含性策略的执行流程如下：</p>
<ul>
<li><p>1.2.1 <strong>读</strong>请求处理：</p>
<ul>
<li>若数据在L1命中，直接返回。</li>
<li>若L1未命中但L2命中，将数据从L2加载到L1，并更新L1标签。</li>
<li>若L2未命中，从内存加载数据并同时写入L1和L2。</li>
</ul>
</li>
<li><p>1.2.2 <strong>写</strong>请求处理：</p>
<ul>
<li>修改L1数据时，需同步更新L2中的对应缓存行以维持包含性。</li>
</ul>
</li>
<li><p>1.2.3 <strong>缓存行淘汰</strong></p>
<ul>
<li>当L2淘汰某缓存行时，需发送“反向无效化”（Back Invalidation）信号，强制L1中对应的缓存行失效。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="2-6-4-L3-Cache"><a href="#2-6-4-L3-Cache" class="headerlink" title="2.6.4 L3 Cache"></a><strong>2.6.4 L3 Cache</strong></h3><p>AMD Zen5微架构实现了最高96 MB的L3缓存（具体容量取决于SoC配置），该缓存为<strong>16路组相联结构</strong>，<u> 由CPU复合体（Core Complex,简写CCX）内的所有核心共享 </u>。L3缓存采用回写策略，其内容由L2缓存的淘汰数据填充。当<u>发生L3命中</u>时：</p>
<ul>
<li><strong>若命中来自存储操作</strong>，或该缓存行<strong>仅被单个核心读取过</strong>，则该行会被标记为无效并从L3中移除；</li>
<li><strong>若命中来自代码预取</strong>，或该行<strong>被多个核心读取过</strong>，则保留在L3中。 L3缓存为每个L2维护<strong>影子标签（Shadow Tags）</strong>。当某核心的本地L2和L3均未命中时，会查询影子标签：若发现数据存在于CCX内的其他L2缓存中，则触发<strong>缓存间直接传输</strong>。 L3缓存的平均加载到使用延迟为46个周期。</li>
<li>通过非时间性缓存填充指令（PREFETCHNTA）可减少一次性数据的缓存污染：使用PREFETCHNTA加载到L2的数据会被标记为快速淘汰候选；当这些数据从L2淘汰时，不会插入L3缓存。</li>
</ul>
<hr>
<h2 id="2-7-内存地址转换"><a href="#2-7-内存地址转换" class="headerlink" title="2.7 内存地址转换"></a>2.7 内存地址转换</h2><p>AMD Zen5微架构在内存地址转换机制上进行了多项创新，通过<strong>两级TLB结构、硬件页表遍历器优化及页面粉碎技术</strong>，显著提升了虚拟地址到物理地址的转换效率。以下从TLB层级设计、硬件加速机制及虚拟化支持三个维度展开分析：</p>
<h3 id="2-7-1-两级TLB结构设计"><a href="#2-7-1-两级TLB结构设计" class="headerlink" title="2.7.1 两级TLB结构设计"></a><strong>2.7.1 两级TLB结构设计</strong></h3><ul>
<li><strong>L1 TLB：全相联高灵活性</strong><ul>
<li><strong>L1指令TLB（ITLB）</strong>：64项(entries)全相联结构，支持4KB、2MB、1GB页面。全相联设计确保任意虚拟页可映射到任意TLB项，减少冲突概率，尤其适合指令流的空间局部性特征。</li>
<li><strong>L1数据TLB（DTLB）</strong>：96项(entries)全相联结构，额外支持16KB页面，并引入<strong>合并映射优化</strong>。当4个连续的4KB虚拟页对齐且物理地址连续时，可合并为单个16KB条目存储，提升TLB有效容量（如合并后等效384项）。</li>
<li><strong>模式限制</strong>：合并优化仅在**长模式（64位）**下启用，兼容现代操作系统与大型应用需求。</li>
</ul>
</li>
<li><strong>L2 TLB：组相联大容量</strong><ul>
<li><strong>L2 ITLB</strong>：2048项8路组相联，仅缓存4KB与2MB页，1GB页由L1 ITLB独占管理。组相联设计在容量与访问延迟间取得平衡，适合处理多线程高并发的指令流。</li>
<li><strong>L2 DTLB</strong>：4096项16路组相联（支持4KB&#x2F;16KB&#x2F;2MB页）+ 1024项4路组相联（专用于1GB页）。分层设计优化大页场景（如数据库、虚拟化），减少TLB未命中率。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="2-7-2-硬件页表遍历器与加速机制"><a href="#2-7-2-硬件页表遍历器与加速机制" class="headerlink" title="2.7.2 硬件页表遍历器与加速机制"></a><strong>2.7.2 硬件页表遍历器与加速机制</strong></h3><ul>
<li><strong>硬件页表遍历器（Table Walker）</strong><ul>
<li><strong>并行处理能力</strong>：Zen5配备<strong>6个硬件遍历器</strong>，可同时处理指令侧与数据侧的TLB未命中请求，支持<strong>推测性页表预取</strong>，减少流水线停顿。</li>
<li><strong>缓存层级优化</strong>：<ul>
<li><strong>Page Walker Cache（PWC）</strong>：缓存页目录指针项（PDPEs）与页目录项（PDEs），跳过页表层级访问（如从PDPE直接获取物理页，减少3级访问）。</li>
<li><strong>Page Directory Cache（PDC）</strong>：64项缓存PML4E&#x2F;PML5E，加速顶级页表查询，尤其针对多级虚拟化（如嵌套分页）场景。</li>
</ul>
</li>
</ul>
</li>
<li><strong>页面粉碎（Page Smashing）技术</strong><ul>
<li><strong>动态页大小适配</strong>：当遇到<strong>客户机大页</strong>（<strong>如1GB</strong>）但宿主机仅支持小页时，Zen5将大页“粉碎”为小页（如拆分为2MB页）存储于TLB，兼容混合页表环境。</li>
<li><strong>刷新机制</strong>：执行INVLPG等指令时，L1 TLB会刷新同一1GB客户机线性地址对应的所有粉碎条目，L2 TLB则按上下文（如进程ID）批量刷新，确保一致性。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="2-7-3-虚拟化与能效优化"><a href="#2-7-3-虚拟化与能效优化" class="headerlink" title="2.7.3 虚拟化与能效优化"></a><strong>2.7.3 虚拟化与能效优化</strong></h3><ul>
<li><strong>虚拟化支持</strong><ul>
<li><strong>嵌套分页加速</strong>：通过PDC与PWC缓存宿主机与客户机页表项，减少二级地址转换（SLAT）开销，提升虚拟机性能。</li>
<li><strong>EPT&#x2F;NPT优化</strong>：硬件遍历器直接处理扩展页表（EPT）与嵌套页表（NPT），避免软件模拟延迟，适用于云计算高密度虚拟化场景。</li>
</ul>
</li>
<li><strong>能效与面积平衡</strong><ul>
<li><strong>SRAM单元压缩</strong>：Zen5采用台积电N4X工艺，L3缓存面积较Zen4缩小34.6%（24→15.7 mm²），通过高密度SRAM与TSV（硅通孔）优化，维持高带宽同时降低功耗。</li>
<li><strong>动态功耗管理</strong>：TLB未命中时，硬件遍历器根据负载动态调整电压频率，结合Zen5的SMU（系统管理单元）实现能效最优。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="2-7-4-性能对比与场景应用"><a href="#2-7-4-性能对比与场景应用" class="headerlink" title="2.7.4 性能对比与场景应用"></a><strong>2.7.4 性能对比与场景应用</strong></h3><ul>
<li><strong>性能优势</strong><ul>
<li><strong>延迟对比</strong>：L1 DTLB命中仅需1-2周期，L2 DTLB命中约5-7周期，显著低于传统页表遍历（14+周期）。</li>
<li><strong>吞吐量提升</strong>：6个硬件遍历器支持每周期处理多个未命中请求，向量化负载（如AI推理）的TLB未命中率降低40% 。</li>
</ul>
</li>
<li><strong>典型应用场景</strong><ul>
<li><strong>高性能计算</strong>：1GB大页支持减少TLB条目占用，优化大规模矩阵运算（如HPC）的内存访问。</li>
<li><strong>实时系统</strong>：合并映射与推测预取减少确定性延迟波动，满足高频交易、工业控制等实时性需求。</li>
<li><strong>云计算</strong>：页面粉碎与嵌套分页加速提升虚拟机密度，配合Zen5的3D V-Cache实现数据中心能效比优化。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="2-8-分支优化"><a href="#2-8-分支优化" class="headerlink" title="2.8 分支优化"></a>2.8 分支优化</h2><p><strong>分支对指令吞吐量的影响</strong></p>
<ul>
<li>分支的概念 ：</li>
</ul>
<p>分支是程序控制流的一部分，通常用于实现条件语句（如 if-else）、循环（如 for、while）或函数调用等逻辑。分支会导致程序在运行时选择不同的执行路径。</p>
<ul>
<li><strong>分支带来的问题</strong> ：<ul>
<li><strong>流水线停滞（Pipeline Stall）</strong> ：<br>在现代处理器中，指令通常是通过流水线（pipeline）并行执行的。然而，当遇到分支指令时，处理器需要知道分支的方向（即是否跳转到目标地址），才能继续执行后续指令。如果分支的结果依赖于前面尚未完成的指令（例如比较操作或计算结果），则处理器必须等待这些指令完成，从而导致流水线停滞，降低指令吞吐量。</li>
<li><strong>性能瓶颈</strong> ：<br>流水线停滞会减少处理器的有效吞吐量，尤其是在分支密集型代码中，这种延迟会显著影响性能。</li>
</ul>
</li>
</ul>
<p><strong>分支预测的作用</strong></p>
<ul>
<li>分支预测的概念 ：</li>
</ul>
<p>分支预测是一种硬件技术，用于猜测分支指令的结果（即是否跳转）以及目标地址，从而使处理器能够在分支结果确定之前继续执行后续指令。如果预测正确，则可以避免流水线停滞；如果预测错误，则需要丢弃错误的指令并重新执行正确的路径。zen5上预测错误会带来<strong>12-18 cycles</strong>的延迟，通常情况是15cycles.</p>
<hr>
<h3 id="2-8-1-分支预测器"><a href="#2-8-1-分支预测器" class="headerlink" title="2.8.1 分支预测器"></a><strong>2.8.1 分支预测器</strong></h3><p>为了预测和加速分支，zen5采用了如下策略：</p>
<ul>
<li>next-address logic</li>
<li>branch target buffer</li>
<li>return address stack (RAS)</li>
<li>indirect target predictor</li>
<li>advanced conditional branch direction predictor</li>
<li>fetch window tracking structure</li>
</ul>
<hr>
<h4 id="2-8-1-1-next-address-logic"><a href="#2-8-1-1-next-address-logic" class="headerlink" title="2.8.1.1 next-address logic"></a><strong>2.8.1.1 next-address logic</strong></h4><p><strong>1. 指令获取地址的生成</strong></p>
<ul>
<li>Next-Address Logic 的作用 ：<ul>
<li><strong>Next-Address Logic 是处理器中用于确定下一条指令获取地址的硬件逻辑</strong>。</li>
<li>它的主要任务是为指令提取（instruction fetch）生成正确的地址。</li>
</ul>
</li>
<li><strong>无分支时的行为</strong> ：<ul>
<li>当当前获取块（fetch block）中未检测到分支时，Next-Address Logic 会计算下一个顺序（sequential）对齐的 64 字节指令块的起始地址。</li>
<li>这种计算是基于自然对齐的 64 字节缓存行（cacheline），并且每周期都会进行，以支持操作缓存（Op Cache）的带宽需求。</li>
<li>Fetch Block 是处理器每次从缓存中提取的一段固定大小的指令集合，通常与缓存行（Cache Line）的大小对齐。Zen5 为32Bytes, 每周期2个block.</li>
</ul>
</li>
<li>优化目标 ：<ul>
<li>在没有分支的情况下，按顺序提取指令可以最大化指令获取的效率，并充分利用缓存和流水线资源。(分支替换成其他指令以实现顺序执行)。</li>
</ul>
</li>
</ul>
<p><strong>2. 分支对指令获取的影响</strong></p>
<ul>
<li>分支导致的性能损失 ：<ul>
<li>如果分支的目标地址位于当前 64 字节缓存行的末尾，会导致一个缩短的获取块（shortened fetch block）。</li>
<li>缩短的获取块意味着该周期内提取的指令数量减少，从而导致指令获取带宽的损失。</li>
</ul>
</li>
<li>优化建议<ul>
<li>优化代码布局 ：<ul>
<li>开发者可以通过优化代码布局（如减少分支指令的数量或将分支集中在一起）来提高 Fetch Block 的利用率。</li>
<li>例如，将热点代码（frequently executed code）放置在连续的内存区域中，可以减少跨缓存行提取指令的频率。</li>
</ul>
</li>
<li>硬件设计 ：<ul>
<li>处理器设计者通过优化 Fetch Block 的大小和分支预测逻辑，来平衡指令获取效率和硬件复杂性。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>3. 分支预测与非顺序地址生成</strong></p>
<ul>
<li><strong>分支识别后的行为</strong> ：<ul>
<li>当分支被识别时，Next-Address Logic 会被分支目标预测（branch target prediction）和分支方向预测（branch direction prediction）硬件重定向。</li>
<li>此时，Next-Address Logic 将生成一个非顺序的指令获取地址，而不是继续顺序提取下一个 64 字节块。</li>
<li>分支目标预测硬件负责预测分支的目标地址，确保处理器能够快速跳转到正确的指令流。</li>
<li>分支方向预测则负责判断分支是否会被执行（即是否跳转）。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="2-8-1-2-Branch-Target-Buffer"><a href="#2-8-1-2-Branch-Target-Buffer" class="headerlink" title="2.8.1.2 Branch Target Buffer"></a><strong>2.8.1.2 Branch Target Buffer</strong></h4><p>分支目标缓冲区（BTB）具有两级结构（L1 BTB, L2 BTB），通过<strong>前一个fetch block得到的地址</strong>作为索引，在BTB中找到匹配的分支条目，从而得到目标跳转地址。每个条目存储了与分支指令及其目标地址相关的关键信息。这些信息用于加速分支预测和指令获取过程。</p>
<p><strong>1. BTB条目包含的信息：</strong></p>
<ul>
<li><strong>分支指令的地址</strong><ul>
<li>分支指令本身在内存中的地址（即分支指令的程序计数器值，PC）。</li>
<li>用于标识哪个分支指令对应此 BTB 条目。</li>
<li>当处理器遇到某个分支指令时，会通过其地址查找对应的 BTB 条目。</li>
</ul>
</li>
<li><strong>分支目标地址</strong><ul>
<li>如果分支被预测为“跳转”（taken），则分支目标地址是跳转后指令的起始地址。</li>
<li>用于快速定位分支跳转的目标地址，从而避免流水线停滞。</li>
</ul>
</li>
<li><strong>分支方向预测信息</strong><ul>
<li>表示分支是否会被执行（taken 或 not-taken）。</li>
<li>通常使用一个简单的状态机（如 2-bit 饱和计数器）来记录分支的历史行为。</li>
<li>状态机的状态可以反映分支的动态行为，例如：<ul>
<li>强预测为“跳转”（strongly taken）</li>
<li>弱预测为“跳转”（weakly taken）</li>
<li>强预测为“不跳转”（strongly not-taken）</li>
<li>弱预测为“不跳转”（weakly not-taken）</li>
</ul>
</li>
</ul>
</li>
<li><strong>分支类型</strong><ul>
<li>条件分支 ：根据某些条件决定是否跳转。</li>
<li>直接分支 ：目标地址在指令编码中明确指定。</li>
<li>间接分支 ：目标地址在运行时确定（例如函数指针调用或返回指令）。</li>
<li>调用（CALL）和返回（RET） ：特殊的分支指令，涉及栈操作。</li>
<li>循环分支：用于实现循环结构，通常出现在 for 或 while 循环中。</li>
<li>表驱动分支：使用跳转表（jump table）实现多路分支（类似于 switch-case）。</li>
<li>长跳转（Far Jump）：跨越较大的地址范围进行跳转，通常涉及段寄存器或跨模块跳转。</li>
</ul>
</li>
<li><strong>分支历史信息</strong><ul>
<li>某些高级 BTB 实现可能会存储分支的历史行为信息，例如最近几次分支是否被跳转。</li>
<li>用于提高分支方向预测的准确性。例如，全局历史寄存器（Global History Register, GHR）可能会与 BTB 结合使用，以捕获跨多个分支的行为模式。</li>
</ul>
</li>
</ul>
<p><strong>2. BTB工作流程</strong></p>
<p><strong>2.1 检测分支指令</strong></p>
<ul>
<li>当处理器从指令缓存中提取指令时，会检查当前 Fetch Block 是否包含分支指令。</li>
<li>如果检测到分支指令，则会尝试在 BTB 中查找对应的条目。</li>
</ul>
<p><strong>2.2 查找 BTB 条目</strong></p>
<ul>
<li>使用分支指令的程序计数器（PC）作为索引，在 BTB 中查找对应的条目。</li>
<li>如果找到匹配的条目，则读取以下信息：<ul>
<li>分支目标地址。</li>
<li>分支方向预测（taken 或 not-taken）。</li>
</ul>
</li>
</ul>
<p><strong>2.3 根据预测信息调整指令流</strong></p>
<ul>
<li>如果分支被预测为“跳转”（taken），则处理器会立即跳转到分支目标地址，并开始从该地址提取后续指令。</li>
<li>如果分支被预测为“不跳转”（not-taken），则处理器继续<strong>顺序</strong>提取下一条指令。</li>
</ul>
<p><strong>2.4 更新 BTB</strong></p>
<ul>
<li>如果分支指令的结果最终被确定（例如通过执行单元解析分支条件），处理器会更新 BTB 中的相应条目：<ul>
<li>更新分支目标地址（如果目标地址发生变化）。</li>
<li>更新分支方向预测信息（例如调整 2-bit 饱和计数器的状态）。</li>
</ul>
</li>
</ul>
<p><strong>3. BTB 的设计优化</strong></p>
<p><strong>3.1 BTB 的两级结构</strong></p>
<ul>
<li>L1 BTB ：<ul>
<li>容量为 16K 条目，主要用于<strong>快速预测常见分支类型</strong>（如直接分支、条件分支等）。</li>
<li>对于大多数分支类型，L1 BTB 可以实现<strong>零延迟</strong>预测（zero prediction bubbles），但对于返回指令和多目标间接分支，会有<strong>两周期的延迟</strong>（two-cycle bubble）。</li>
</ul>
</li>
<li>L2 BTB ：<ul>
<li><strong>容量为 8K 条目，用于处理 L1 BTB 未命中的情况</strong>。</li>
<li>如果预测在 L1 BTB 中未命中但在 L2 BTB 中命中，则会产生<strong>八周期的延迟</strong>（eight prediction bubbles）。这表明 L2 BTB 的访问速度较慢，但其更大的容量可以覆盖更多分支场景。</li>
</ul>
</li>
</ul>
<p><strong>3.2 BTB 条目的设计</strong></p>
<ul>
<li>存储能力 ：<ul>
<li>每个 BTB 条目最多可以存储<strong>两</strong>个分支，前提是这两个分支满足<strong>特定的配对条件</strong>。<ul>
<li>一个条件分支后跟随另一个分支，且这两个分支的最后一个字节位于同一个 64 字节对齐的缓存行中。</li>
<li>一个直接分支（不包括调用指令 CALL）后跟随一个在 64 字节对齐缓存行内结束的分支，该缓存行包含第一个分支的目标。</li>
</ul>
</li>
<li>如果分支目标地址与其获取地址在大量位上存在差异，则可能限制 BTB 条目仅能存储一个分支。这反映了硬件资源的限制。</li>
</ul>
</li>
</ul>
<p><strong>3.3 分支预测的性能影响</strong></p>
<ul>
<li><strong>预测气泡（Prediction Bubbles）</strong> ：<ul>
<li><strong>预测气泡是指由于分支预测失败或延迟导致的流水线停滞</strong>。不同的分支类型和 BTB 级别会导致不同的预测气泡：<ul>
<li>L1 BTB 提供零延迟预测（对于大多数分支类型）。</li>
<li>返回指令和多目标间接分支会产生两周期的延迟。</li>
<li>L2 BTB 命中会产生八周期的延迟。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>3.4 优化建议</strong> ：</p>
<ul>
<li>尽可能减少代码中的分支数量，尤其是那些难以预测的分支（如多目标间接分支）。</li>
<li>在某些情况下，可以使用条件移动指令（conditional mov instructions）替代分支指令，从而避免分支预测的开销。</li>
<li>保持关键分支的工作集尽可能小，可以提高 BTB 的命中率，从而减少预测延迟。</li>
<li>BTB 的容量有限，因此如果分支过多或分布过于分散，可能会导致频繁的未命中，进而影响性能。</li>
</ul>
<hr>
<h4 id="2-8-1-3-Return-Address-Stack"><a href="#2-8-1-3-Return-Address-Stack" class="headerlink" title="2.8.1.3 Return Address Stack"></a><strong>2.8.1.3 Return Address Stack</strong></h4><p>处理器为每个线程实现了一个包含 52 个条目的返回地址栈（Return Address Stack, RAS），用于预测近调用（near call）的返回地址。在获取调用指令时，下一条指令的地址会被压入返回地址栈中。通常情况下，返回地址可以通过从返回地址栈顶部弹出的地址正确预测。然而，在推测执行过程中有时会出现错误预测，这可能导致返回地址栈被错误地压入或弹出。处理器实现了机制，能够在大多数情况下正确恢复返回地址栈。如果返回地址栈无法恢复，则会被置为无效并重置到一个一致的状态。<strong>以下部分将讨论用于优化子程序调用和返回的常见编码实践</strong>。</p>
<p><strong>1. CALL 0h</strong></p>
<p>当 CALL 指令与零偏移量（displacement of zero）一起使用时，它会被识别并特殊处理；尽管 CALL 0h 的语义是调用当前指令地址本身（即跳转到下一条指令），但处理器不会将返回地址压入返回地址栈（RAS）。这种设计确保了即使没有对应的 RET 指令，返回地址栈（RAS）仍然保持一致。作为 CALL 0h 的替代方法，64 位软件可以使用带有 RIP 相对寻址的 LEA 指令将 RIP 加载到寄存器中，如下例所示：</p>
<blockquote>
<p>lea rax, [rip + 0]</p>
</blockquote>
<p>不管是硬件特殊处理还是使用LEA替换，目的都是防止RAS产生返回地址栈，从而导致性能的损失和RAS的混乱。</p>
<p><strong>2. REP RET</strong></p>
<p>对于之前的处理器家族（例如 Family 10h 和 12h），曾推荐使用三字节的返回立即数（return-immediate，RET 指令）作为一种优化手段，以提高性能，相较于单字节的近返回（near-return）。然而，对于 AMD Zen5 微架构，这种推荐已不再适用。现在可以使用单字节的近返回指令（操作码 C3h），而不会对性能产生负面影响。这将使得代码大小比三字节方法更小。(这一条是硬件上改进，对软件优化没有参考价值)。</p>
<p><strong>3. Function Inlining</strong></p>
<p>对于 L1 BTB（一级分支目标缓冲区）预测，返回指令（RET）会导致两个周期的气泡延迟（two-cycle bubble）。因此，在热点循环中调用的函数如果调用者较少或函数本身较小，则应尽量进行内联（inlining），以提高性能。</p>
<hr>
<h4 id="2-8-1-4-Indirect-Target-Predictor"><a href="#2-8-1-4-Indirect-Target-Predictor" class="headerlink" title="2.8.1.4 Indirect Target Predictor"></a><strong>2.8.1.4 Indirect Target Predictor</strong></h4><p>处理器实现了一个包含 3072 个条目的<strong>间接目标数组</strong>（Indirect Target Array，记录历史目标地址信息） ，<strong>用于预测某些非返回（non-RET）间接分支的目标地址</strong>。如果某个分支曾经有过多个不同的目标地址，间接目标预测器会根据全局历史（global history）在这些目标地址中进行选择。而对于始终具有相同目标地址的间接分支，则使用该分支在 BTB（分支目标缓冲区）条目中存储的静态目标地址进行预测。因此，<strong>代码应尽量减少每个间接分支的不同目标数量以提高预测命中率</strong>。</p>
<ul>
<li><strong>优化建议</strong><ul>
<li><strong>减少间接分支的数量</strong> ：尽量避免频繁使用函数指针、虚函数或跳转表等可能导致间接分支的编程模式。</li>
<li><strong>合并目标地址</strong> ：如果可能，将多个相似的分支目标合并为一个目标地址，以减少目标地址的变化。</li>
<li><strong>优化热路径（hot path）</strong> ：对于热点代码路径中的间接分支，确保目标地址尽可能固定。</li>
<li><strong>使用条件分支或其他方法替代跳转表</strong>，以减少间接分支的复杂性。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="2-8-1-5-Advanced-Conditional-Branch-Direction-Predictor"><a href="#2-8-1-5-Advanced-Conditional-Branch-Direction-Predictor" class="headerlink" title="2.8.1.5 Advanced Conditional Branch Direction Predictor"></a><strong>2.8.1.5 Advanced Conditional Branch <em>Direction</em> Predictor</strong></h4><p>条件分支预测器用于预测**条件近分支（conditional near branches）**的方向。<strong>只有那些先前被发现具有“跳转”（taken）和“不跳转”（not-taken）行为的分支才会使用条件分支预测器</strong>。条件分支预测器采用全局历史机制（<strong>global history scheme</strong>），记录之前执行过的分支行为。对于从未跳转的分支，全局历史不会更新。因此，倾向于“不跳转”的动态分支更受青睐。依赖于深层历史或与全局历史相关性较低的分支行为更容易被错误预测。</p>
<p><strong>尚未被发现为“跳转”的条件分支不会在 BTB（分支目标缓冲区）中标记</strong>。这些分支会被隐式预测为“不跳转”。一旦某个条件分支首次被发现为“跳转”，它将被标记为“始终跳转”（always-taken）。如果后续发现该分支出现“不跳转”行为，则其状态会从“始终跳转”转变为“动态”（dynamic），此时它将有资格使用动态条件分支预测器进行预测。</p>
<ul>
<li><p>隐式预测与显式预测</p>
<ul>
<li><strong>隐式预测（Implicit Prediction）</strong> ：<ul>
<li>对于尚未被发现为“跳转”的分支，处理器会默认预测其为“不跳转”, 不会在BTB中标记该分支。</li>
<li>这种隐式预测减少了对硬件资源的需求，同时适用于大多数情况下偏向“不跳转”的分支。</li>
</ul>
</li>
<li><strong>显式预测（Explicit Prediction）</strong> ：<ul>
<li>一旦某个分支首次被发现为“跳转”，它将被标记为“始终跳转”。</li>
<li>如果随后发现该分支也有“不跳转”的行为，则其状态会转变为“动态”，并使用条件分支预测器进行更复杂的预测。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>优化建议</strong> ：</p>
<ul>
<li><strong>减少分支数量</strong> ：尽量避免不必要的条件分支，尤其是在热点代码路径中。</li>
<li><strong>倾向于“不跳转”的分支（即偏置分支）更高效</strong>，因为它们不会增加全局历史的复杂性，也不会占用条件分支预测器的资源。以利用隐式预测的优势。</li>
<li><strong>合并分支</strong> ：将多个小分支合并为一个较大的分支，以减少分支预测器的负担。</li>
<li><strong>避免长距离相关性</strong> ：如果分支行为依赖于较早的历史，考虑重新组织代码以减少这种依赖。</li>
</ul>
</li>
<li><p>编译器支持 ：</p>
<ul>
<li>现代编译器通常会自动优化分支逻辑，例如通过重新排列代码来提高分支预测的准确性。</li>
<li>开发者可以通过编译器标志（如 -O2 或 -O3）启用高级优化。</li>
</ul>
</li>
<li><p><strong>性能分析工具识别频繁被错误预测的分支</strong> ：</p>
<blockquote>
<p>perf record -e branch-misses .&#x2F;your_program  # 记录程序运行时分支预测错误次数<br>perf report # 查看结果<br>perf annotate #查看导致分支预测错误的汇编代码<br>perf top -e branch-misses #实时查看系统的性能瓶颈<br># 导出报告<br>perf record -o perf.data .&#x2F;your_program<br>perf report -i perf.data</p>
</blockquote>
</li>
</ul>
<hr>
<h4 id="2-8-1-6-Fetch-Window-Tracking-Structure"><a href="#2-8-1-6-Fetch-Window-Tracking-Structure" class="headerlink" title="2.8.1.6 Fetch Window Tracking Structure"></a><strong>2.8.1.6 Fetch Window Tracking Structure</strong></h4><p>*<em>指令获取窗口（Fetch Windows）*<em>通过一个 128 entry的 FIFO 队列（在 SMT 模式下为 64 项）<strong>从指令获取阶段跟踪到指令退役阶段</strong>。每个队列条目可以存储最多一个完整 64 字节缓存行的分支预测信息。如果单个 BTB 条目不足以支持对整个缓存行末尾的预测，则获取窗口跟踪结构会为该特定缓存行使用额外的条目。如果在某个缓存行中未检测到分支，则获取窗口跟踪结构将仅使用一个条目来跟踪整个缓存行。如果获取窗口跟踪结构被填满，指令获取将暂停，直到指令从退役控制单元退役，或者分支错误预测清除了部分条目。无论是</em>错误预测*的分支还是</em>退役*的分支，都会使用此结构中的信息按需更新预测结构。</p>
<ul>
<li>优化建议 ：<ul>
<li>减少分支密集型代码的复杂性，防止获取窗口跟踪结构被快速填满。</li>
<li>在 SMT 模式下，获取窗口跟踪结构的条目数减半，因此更容易被填满。应尽量减少线程间的分支冲突。优化线程间的资源分配。</li>
<li>合并分支逻辑，减少获取窗口跟踪结构的条目占用。</li>
</ul>
</li>
</ul>
<hr>
<p><a id="282"></a></p>
<h3 id="2-8-2-跨边界分支（Boundary-Crossing-Branches）"><a href="#2-8-2-跨边界分支（Boundary-Crossing-Branches）" class="headerlink" title="2.8.2 跨边界分支（Boundary Crossing Branches）"></a><strong>2.8.2 跨边界分支（Boundary Crossing Branches）</strong></h3><p>目标地址跨越 16 MB 对齐边界的分支无法与其他分支共享 BTB（分支目标缓冲区）条目。那么频繁出现这种情况会降低 BTB 的有效容量和带宽。</p>
<p><strong>16 MB 对齐边界</strong> ：</p>
<ul>
<li>处理器中的某些硬件结构（如 BTB）对分支目标地址的存储有特定限制。</li>
<li>如果分支的目标地址跨越了 16 MB 对齐边界（即目标地址的高阶位发生变化），则该分支被视为“跨边界分支”。</li>
</ul>
<p><strong>实际场景中的问题</strong> ：</p>
<ul>
<li><strong>大型代码库</strong> ：<br>在大型程序或动态链接库中，函数地址可能分布在不同的 16 MB 区域，导致跨边界分支的发生频率增加。</li>
<li><strong>间接分支</strong> ：<br>间接分支（如函数指针调用、虚函数调用）的目标地址通常是动态确定的，更容易跨越 16 MB 边界。</li>
</ul>
<p><strong>优化建议</strong> :</p>
<ul>
<li><strong>减少跨边界分支的发生</strong> ：<ul>
<li><strong>优化代码布局</strong> ：<ul>
<li>将热点函数和相关代码尽量放置在相同的 16 MB 区域内，避免目标地址跨越边界。</li>
<li>使用链接器脚本或编译器选项控制函数和代码段的布局。</li>
</ul>
</li>
<li><strong>合并间接分支</strong> ：<ul>
<li>减少间接分支的数量，或者将目标地址集中在较小的地址范围内。</li>
</ul>
</li>
</ul>
</li>
<li>硬件支持 ：<ul>
<li>现代处理器可能会通过更复杂的 BTB 设计（如多级 BTB 或更大的条目容量）来缓解跨边界分支的影响。</li>
</ul>
</li>
</ul>
<hr>
<p><a id="283"></a></p>
<h3 id="2-8-3-循环对齐（Loop-Alignment）"><a href="#2-8-3-循环对齐（Loop-Alignment）" class="headerlink" title="2.8.3 循环对齐（Loop Alignment）"></a><strong>2.8.3 循环对齐（Loop Alignment）</strong></h3><p>对于处理器来说，循环对齐通常不是一个显著的问题。然而，对于<strong>热点循环（hot loops）</strong>，了解一些权衡可以帮助进一步优化性能。</p>
<p><strong>1. 64 字节缓存行对齐</strong></p>
<ul>
<li>处理器每周期可以读取一个对齐的 64 字节获取块（fetch block）。因此，建议：<ul>
<li>将循环的起点对齐到 64 字节缓存行的起始位置。</li>
<li>或者将循环的终点对齐到 64 字节缓存行的末尾。</li>
</ul>
</li>
<li>性能差异 ：<ul>
<li>将循环的终点对齐到缓存行的末尾稍微更优，因为这可以减少跨缓存行提取指令的可能性。</li>
</ul>
</li>
</ul>
<p><strong>2. 分支放置与 BTB 条目的使用</strong></p>
<ul>
<li>分支预测器的能力 ：<ul>
<li>分支预测器可以通过单个 BTB 条目处理从缓存行入口点开始的前两个分支。</li>
<li>为了获得最佳性能，应尽量确保在同一缓存行中，分支目标之后的预测分支数量不超过两个。</li>
</ul>
</li>
<li>BTB 条目的限制 ：<ul>
<li><strong>每个 BTB 条目最多可以存储两个分支的信息</strong>。</li>
<li>如果需要预测第三个分支，则需要额外的 BTB 条目，并增加预测延迟。</li>
</ul>
</li>
</ul>
<p><strong>3. 分支密度与执行频率</strong><br>这里的优化不应与“每个缓存行的分支数量”混淆。</p>
<ul>
<li>即使每个缓存行包含三到四个分支，仍然是最优的，前提是：<ul>
<li>第二个分支是无条件分支（unconditional branch）。</li>
<li>或者第一个或第二个分支被频繁跳转，导致第三和第四个分支很少被执行。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="2-8-3-1-编码填充以实现循环对齐"><a href="#2-8-3-1-编码填充以实现循环对齐" class="headerlink" title="2.8.3.1 编码填充以实现循环对齐"></a><strong>2.8.3.1 编码填充以实现循环对齐</strong></h4><p>对齐循环通常是通过在循环前添加 NOP 指令来实现的。<br><strong>1. NOP 指令的成本</strong><br>虽然 NOP 指令不消耗执行单元资源，但它们仍然需要从解码器（Decoder）转发，并由退役控制单元（Retire Control Unit, RCU）跟踪。因此，建议使用<strong>较少且较长</strong>的 NOP 指令 ，而不是许多短 NOP 指令。<br><strong>2. NOP 指令的编码</strong><br>NOP 指令的编码支持长度为 1 到 15 的编码方式。对于长度超过 8 的 NOP 指令，可以通过在指令开头添加一个或多个操作数大小覆盖前缀（66h）来实现。</p>
<hr>
<h2 id="2-9-取指与译码"><a href="#2-9-取指与译码" class="headerlink" title="2.9 取指与译码"></a>2.9 取指与译码</h2><p>处理器从指令缓存中<strong>以 32 字节对齐的块（Fetch block）形式</strong>获取指令，每个块大小为 32 字节。每周期最多可以独立获取两个这样的块，以供给解码单元的<strong>两条解码流水线（decode pipes）</strong>。来自不同基本块的指令字节可以被获取并乱序发送到两条解码流水线，从而实现指令提前预取（instruction fetch-ahead），这可以隐藏因 TLB 未命中、指令缓存（I-Cache）未命中和指令解码带来的延迟。</p>
<p><strong>1. IBQ 结构</strong></p>
<ul>
<li>每条解码流水线都有一个称为 IBQ（Instruction Byte Queue）的 20 条目结构，它充当<strong>指令获取&#x2F;分支预测单元与解码单元之间的解耦</strong>队列。<strong>IBQ 条目保存了 16 字节对齐的指令字节流的获取窗口（fetch windows）</strong>。</li>
</ul>
<p><strong>2. 解码流水线的工作方式</strong></p>
<ul>
<li>每条解码流水线扫描两个 IBQ 条目，并每周期最多输出 4 条指令。</li>
<li>在单线程模式下，最大吞吐量为每周期 4 条指令。</li>
<li>在 SMT（同步多线程）模式下，解码流水线 0 专用于线程 0，解码流水线 1 专用于线程 1，支持每周期最多 8 条指令的最大吞吐量。</li>
</ul>
<p><strong>3. 指令解码窗口</strong></p>
<ul>
<li>指令解码窗口大小为 32 字节，并且对齐到 16 字节边界。</li>
<li>优化建议 ：将分支目标地址对齐到 16 字节边界可以获得最大的指令解码吞吐量。</li>
</ul>
<p><strong>4. 长指令的限制</strong></p>
<ul>
<li>在每组四个解码槽位中，只有第一个解码槽位能够解码长度超过 10 字节的指令。</li>
<li>优化建议 ：避免在一组四个连续指令中出现多条长度超过 10 字节的指令。</li>
</ul>
<hr>
<h3 id="2-9-1-Op-Cache"><a href="#2-9-1-Op-Cache" class="headerlink" title="2.9.1 Op Cache"></a><strong>2.9.1 Op Cache</strong></h3><p>操作缓存（Op Cache，简称 OC）是已解码指令的缓存。当指令从 Op Cache 中获取时，传统的指令获取和解码过程会被绕过。这带来了以下性能优势：</p>
<ul>
<li><strong>降低流水线延迟</strong> ：<br>Op Cache 的流水线比传统的获取和解码流水线更短。</li>
<li><strong>提高带宽</strong> ：<br>Op Cache 的最大吞吐量为每周期 12 条指令，而传统获取和解码流水线的最大吞吐量为每线程每周期 4 条指令。</li>
<li><strong>节省功耗</strong> ：<br>由于无需重新解码指令，Op Cache 的使用降低了功耗。</li>
</ul>
<p><strong>1. Op Cache 的组织结构</strong></p>
<ul>
<li>缓存设计 ：<ul>
<li>Op Cache 是一个具有 64 组（sets）和 16 路（ways）的关联缓存。在每个组-路交叉点上，有一个条目，每个条目最多可以存储 6 条指令或融合指令（fused instructions）。</li>
<li>与 Zen3 和 Zen4 的区别 ：<br>Zen3 和 Zen4 的 Op Cache 存储的是宏操作（macro-ops），而新的设计直接存储指令或融合指令，从而提高了有效存储密度。</li>
</ul>
</li>
<li>容量限制 ：<br>Op Cache 的最大容量为 6K 条指令或融合指令。实际容量可能因效率考虑而略低。</li>
<li>优化建议 ：<br>当只有一个线程运行在物理核心上时，避免热点代码区域接近此大小。当两个线程共享一个物理核心时，避免热点代码区域接近 3K 条指令的大小。</li>
<li>物理标记（Physically Tagged） ：<br>Op Cache 使用物理地址标记，允许两个线程在获取共享代码时共享 Op Cache 条目。</li>
</ul>
<p><strong>2. Op Cache 的填充机制</strong></p>
<ul>
<li><strong>未命中处理</strong> ：<ul>
<li>当指令获取在 Op Cache 中未命中时，指令会从指令缓存（IC）中读取并解码，然后被构建到 Op Cache 中。</li>
<li>多条指令会被一起构建到一个 Op Cache 条目中，最多可以将 6 条连续指令或融合指令缓存到一个条目中。</li>
</ul>
</li>
</ul>
<p><strong>3. Op Cache 条目的限制</strong></p>
<p>Op Cache 条目有以下限制：</p>
<ul>
<li><strong>指令数量限制</strong> ：<ul>
<li>每个条目最多包含 6 条指令或融合指令。</li>
</ul>
</li>
<li><strong>立即数或位移操作数存储槽位限制</strong> ：<ul>
<li>每个条目最多支持 6 个 32 位立即数或位移操作数存储槽位。这些槽位可以被任何指令使用。</li>
<li>如果所有 6 个槽位已被占用，则后续包含立即数或位移操作数的指令无法被加入该条目。</li>
<li>存储规则 ：<ul>
<li>64 位操作数占用 2 个槽位。</li>
<li>8&#x2F;16&#x2F;32 位操作数各占用 1 个槽位。</li>
</ul>
</li>
</ul>
</li>
<li><strong>AVX-512 指令限制</strong> ：<br>每个条目最多支持 6 条带有 EVEX 前缀的 AVX-512 指令。</li>
<li><strong>微码指令限制</strong> ：<ul>
<li>当存在微码指令时，传统的宏操作限制不再适用。</li>
<li>微码指令和非微码指令的总数限制为 4 条。</li>
</ul>
</li>
<li>缓存行限制 ：<ul>
<li>一个 Op Cache 条目只能包含来自最多两个相邻 64 字节缓存行的指令。</li>
</ul>
</li>
</ul>
<p><strong>4. Op Cache 的模式切换</strong></p>
<ul>
<li>模式定义 ：<br>处理器可以在两种模式之间切换：**指令缓存模式（IC 模式）**和 <strong>Op Cache 模式（OC 模式）</strong>。</li>
<li>切换条件 ：<ul>
<li><strong>从指令缓存模式切换到 Op Cache 模式只能在分支跳转（taken branches）时发生</strong>。</li>
<li><strong>处理器会保持在 Op Cache 模式，直到检测到 Op Cache 未命中</strong>。</li>
</ul>
</li>
<li>性能影响 ：<br>频繁的模式切换可能会对性能产生负面影响。</li>
<li>优化建议 ：<br>将热点代码区域的大小限制在 Op Cache 的容量范围内，以尽量减少模式切换。在展开循环时，需特别注意这一点。</li>
</ul>
<p><strong>5. 内存模型要求</strong></p>
<ul>
<li><strong>平坦内存模型</strong> ：<ul>
<li><strong>使用 Op Cache 需要采用平坦内存模型（Flat Memory Model）</strong>。</li>
<li>要求 ：<ul>
<li>64 位模式</li>
<li>或32 位模式，且 CS.Base &#x3D; 0h 且 CS.Limit &#x3D; FFFFFFFFh。</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<p><a id="292"></a></p>
<h3 id="2-9-2-依赖项消除的惯用方法Idioms-for-Dependency-removal"><a href="#2-9-2-依赖项消除的惯用方法Idioms-for-Dependency-removal" class="headerlink" title="2.9.2 依赖项消除的惯用方法Idioms for Dependency removal"></a><strong>2.9.2 依赖项消除的惯用方法Idioms for Dependency removal</strong></h3><p><strong>核心机制 ：</strong><br>零化惯用法和置一惯用法通过特殊的指令模式清空或初始化寄存器(处理器会识别这些指令并特殊处理)，同时打破输入依赖关系。这些操作通常被处理器优化为 0 周期操作，显著提升性能。</p>
<p><strong>零化惯用法</strong><br>一些指令可以用于清空寄存器并打破依赖关系，而无需加载立即数零。这些方法被称为零化惯用法（Zeroing Idioms）。</p>
<ul>
<li><p><strong>GPR 零化惯用法</strong></p>
<blockquote>
<p>XOR reg, reg (clears reg and the flags, 0-cycle operation)<br>SUB reg, reg (clears reg and the flags, 0-cycle operation)<br>CMP reg, reg (sets Z flag and clears other flags, 0-cycle operation)<br>SBB reg, reg (copies the zero extended value of the carry flag into reg without a dependency on the previous value of reg, 1-cycle operation) …</p>
</blockquote>
</li>
<li><p><strong>SIMD 零化惯用法</strong> (all clear destination register as a 0-cycle operation):</p>
<blockquote>
<p>VXORP(S&#x2F;D) zmm&#x2F;ymm&#x2F;xmm,zmm&#x2F;ymm&#x2F;xmm,zmm&#x2F;ymm,xmm …</p>
</blockquote>
</li>
</ul>
<p><strong>置一惯用法</strong><br>一些指令可以将寄存器设置为全 1，并打破输入依赖关系。这些方法被称为置一惯用法（Ones Idioms）。</p>
<blockquote>
<p>PCMPEQ(B&#x2F;W&#x2F;D&#x2F;Q) xmm, xmm …</p>
</blockquote>
<p><strong>Q: 为什么使用 XOR 而不是 MOV？</strong><br>使用 MOV reg, 0 需要加载立即数，可能会增加代码大小和解码开销。<br>XOR reg, reg 更短（仅 2 字节），并且被处理器优化为 0 周期操作。</p>
<p><strong>优化建议 ：</strong></p>
<ul>
<li>在代码中优先使用零化惯用法（如 XOR reg, reg 或 VXORPS）来清空寄存器。</li>
<li>对于 SIMD 操作，避免显式加载立即数，而是使用零化惯用法。</li>
<li>在需要初始化寄存器为全 1 时，使用置一惯用法（如 PCMPEQD）。</li>
</ul>
<hr>
<p><a id="293"></a></p>
<h3 id="2-9-3-分支融合-Branch-Fusion"><a href="#2-9-3-分支融合-Branch-Fusion" class="headerlink" title="2.9.3 分支融合 Branch Fusion"></a><strong>2.9.3 分支融合 Branch Fusion</strong></h3><p>处理器的解码单元能够将条件分支指令与某些标志位写入指令融合为一条融合指令 。融合指令仅占用 Op Cache 条目中的一个槽位，并<strong>减少了一条宏操作（macro-op）在处理器流水线中的流动</strong>，从而提高了分发（dispatch）、发射（issue）和退役（retire）的<strong>带宽</strong>。</p>
<p><strong>分支融合的条件</strong><br>为了实现分支融合，需要满足以下条件：</p>
<ul>
<li><strong>顺序要求</strong> ：<br>条件分支指令必须紧跟在标志位写入指令之后。</li>
<li><strong>支持的标志位写入指令</strong> ：<br>以下指令支持与其对应的条件分支指令进行融合：<blockquote>
<p>CMP<br>  TEST<br>  SUB<br>  ADD<br>  INC<br>  DEC<br>  OR<br>  AND<br>  XOR</p>
</blockquote>
</li>
<li><strong>指令形式</strong> ：<br>支持的指令形式包括：<ul>
<li>寄存器-寄存器（reg&#x2F;reg）</li>
<li>寄存器-立即数（reg&#x2F;imm）</li>
<li>寄存器-内存（reg&#x2F;mem）</li>
</ul>
</li>
<li><strong>立即数和位移限制</strong> ：<br>当指令包含立即数和位移时，需满足以下条件之一：<ul>
<li>4 字节位移和 2 字节立即数。</li>
<li>2 字节位移和 4 字节立即数。</li>
</ul>
</li>
</ul>
<p><strong>优化建议 ：</strong></p>
<ul>
<li>在编写代码时，尽量将条件分支指令紧接在标志位写入指令之后，以便触发分支融合。</li>
<li>使用支持融合的指令形式（如 CMP、TEST 等），并注意立即数和位移的大小限制。</li>
</ul>
<hr>
<h3 id="2-9-4-MOV-ALU-Fusion"><a href="#2-9-4-MOV-ALU-Fusion" class="headerlink" title="2.9.4 MOV + ALU Fusion"></a><strong>2.9.4 MOV + ALU Fusion</strong></h3><p>MOV + ALU Fusion 是一种优化技术，它允许将 MOV 指令与 ALU 指令进行融合，以减少指令数量和延迟。这种优化技术在某些情况下可以提高程序性能。</p>
<hr>
<h3 id="2-9-5-Zero-Cycle-Move"><a href="#2-9-5-Zero-Cycle-Move" class="headerlink" title="2.9.5 Zero Cycle Move"></a><strong>2.9.5 Zero Cycle Move</strong></h3><p>处理器可以以零周期延迟执行某些 register-to-register mov操作，从而减少指令数量和延迟。</p>
<hr>
<p><a id="296"></a></p>
<h3 id="2-9-6-栈指针跟踪以消除依赖（Stack-Pointer-Tracking-for-Dependency-Removal）"><a href="#2-9-6-栈指针跟踪以消除依赖（Stack-Pointer-Tracking-for-Dependency-Removal）" class="headerlink" title="2.9.6 栈指针跟踪以消除依赖（Stack Pointer Tracking for Dependency Removal）"></a><strong>2.9.6 栈指针跟踪以消除依赖（Stack Pointer Tracking for Dependency Removal）</strong></h3><p>整数重命名单元（Integer Rename Unit）提供了一种机制，用于优化某些对栈指针（stack pointer）的隐式操作以及对栈指针的引用。这里的栈指针指的是 rSP 寄存器（即 64 位模式下的栈指针寄存器）。<u>当栈指针被跟踪时，支持的指令不再依赖于先前对栈指针进行隐式更新的指令。这消除了这些指令之间的执行依赖关系，从而提高了性能</u>。</p>
<p><strong>1. 支持栈指针跟踪的指令</strong><br>以下隐式更新栈指针的指令支持栈指针跟踪：</p>
<ul>
<li>PUSH reg&#x2F;mem&#x2F;imm （不包括 PUSH rSP）</li>
<li>POP reg&#x2F;mem （不包括 POP rSP）</li>
<li>CALL near rel （近相对调用）</li>
<li>CALL near abs reg （近绝对寄存器调用）</li>
<li>RET near （近返回）</li>
<li>RET near imm （带立即数的近返回）</li>
</ul>
<p><strong>2. 可利用栈指针跟踪的指令</strong><br>以下引用栈指针的指令可以利用栈指针跟踪功能：</p>
<ul>
<li><p><strong>内存引用</strong> ：<br>使用 rSP 作为基址或索引寄存器的加载和存储操作。</p>
<blockquote>
<p>MOV EAX, [RSP+8]  ; 加载指令<br>  MOV [RSP+8], EAX  ; 存储指令</p>
</blockquote>
</li>
<li><p><strong>MOV 指令</strong> ：<br>将栈指针的值移动到其他寄存器。</p>
<blockquote>
<p>MOV RAX, RSP</p>
</blockquote>
</li>
<li><p><strong>ADD&#x2F;SUB 指令</strong> ：</p>
<ul>
<li>对栈指针执行加法或减法操作，并且立即数为 12 位（对于 32 位指令，高 19 位是符号扩展）。</li>
<li>支持的指令包括：<ul>
<li>ADD (81 &#x2F;0, 83 &#x2F;0) ：将立即数加到 RSP。</li>
<li>SUB (81 &#x2F;5, 83 &#x2F;5) ：从 RSP 中减去立即数。<blockquote>
<p>ADD RSP, 16       ; 增加栈指针<br>  SUB RSP, 8        ; 减少栈指针</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>LEA 指令</strong> ：</p>
<blockquote>
<p>LEA RAX, [RSP+8]  ; 计算地址</p>
</blockquote>
</li>
</ul>
<p><strong>3. 优化建议 ：</strong></p>
<ul>
<li>在编写代码时，尽量使用支持栈指针跟踪的指令。</li>
<li>避免使用可能导致栈指针跟踪重置的操作（如 PUSH rSP 或复杂寻址模式）。</li>
<li>注意 ADD 和 SUB 的立即数大小限制，确保符合 12 位的要求。</li>
</ul>
<hr>
<p><a id="297"></a></p>
<h3 id="2-9-7-指令分发-Dispatch"><a href="#2-9-7-指令分发-Dispatch" class="headerlink" title="2.9.7 指令分发 Dispatch"></a><strong>2.9.7 指令分发 Dispatch</strong></h3><p><u>分发带宽是指处理器每周期能够将多少条宏操作从解码阶段传递到执行引擎的能力</u>。分发带宽直接影响处理器的**指令级并行性（ILP）**和整体吞吐量。如果分发带宽不足，可能导致流水线停滞，降低性能。</p>
<p><u>处理器每周期最多可以将 8 条宏操作（macro-ops） 分发到执行引擎中</u>。然而，对于某些指令组合，由于内部限制，处理器可能无法达到 8 条宏操作的分发上限。为了最大化分发带宽，软件可以通过在任意连续的 8 条宏操作窗口中平衡操作类型来优化分发效率。如果一个窗口中的操作类型混合得当，并且这些操作可以在执行引擎中并发执行，那么它们也可能被同时分发。</p>
<p><strong>1. 分发优化规则</strong><br>为了优化分发带宽，需遵循以下规则：</p>
<ul>
<li><strong>最多 2 条已跳转分支（Taken branches）</strong> ：<br>在一个分发组中，最多允许 2 条已被预测为跳转的分支指令。这是因为分支指令需要额外的资源来处理控制流转移。</li>
<li><strong>最多 8 个立即数或位移（Immediates or displacements）</strong> ：<br>在一个分发组中，最多允许 8 个立即数或位移操作。立即数和位移操作会占用解码器和分发单元的资源，因此需要限制其数量。</li>
<li><strong>第 8 条操作不能是加载或存储（Load&#x2F;Store）</strong> ：<br>在一个分发组中，第 8 条操作不能是内存加载（Load）或存储（Store）指令。这是因为加载和存储操作通常涉及复杂的地址计算和内存访问，可能会限制分发效率。</li>
</ul>
<p><strong>2. 优化建议 ：</strong></p>
<ul>
<li>在任意连续的 8 条宏操作窗口中，<strong>尽量混合不同类型的操作，避免在一个窗口中集中过多相似类型的操作</strong>（如多个分支指令或多个加载操作），以充分利用执行引擎的并发能力。应注意满足：<ul>
<li>最多 2 条已跳转分支。</li>
<li>最多 8 个立即数或位移。</li>
<li>第 8 条操作不能是加载或存储。</li>
</ul>
</li>
<li>汇编&#x2F;编译器优化：<ul>
<li><strong>代码布局</strong> ：<br>注意操作类型的分布，避免连续多条加载或存储操作，而是将其与其他类型的操作交替排列。</li>
<li><strong>指令融合</strong> ：<br>利用处理器的指令融合功能（如分支融合），减少宏操作的数量，从而提高分发效率。</li>
<li><strong>循环展开</strong> ：<br>在循环展开时，确保每个展开的迭代块中包含多种类型的操作，以平衡分发窗口中的操作类型。</li>
</ul>
</li>
</ul>
<hr>
<p><a id="298"></a></p>
<h3 id="2-9-8-使用-PAUSE-指令优化自旋循环（Span-Loop）"><a href="#2-9-8-使用-PAUSE-指令优化自旋循环（Span-Loop）" class="headerlink" title="2.9.8 使用 PAUSE 指令优化自旋循环（Span Loop）"></a><strong>2.9.8 使用 PAUSE 指令优化自旋循环（Span Loop）</strong></h3><p>软件可以使用 <code>\color{red}{PAUSE}</code> 指令来减少在自旋循环中等待获取竞争锁时的功耗和其他资源占用。<code>\color{red}{PAUSE}</code> 指令的具体效果取决于处理器的实现，但在 AMD Zen5 微架构中，<strong>PAUSE 指令会导致执行线程暂停宏操作（macro-ops）的分发</strong>，持续大约 64 个周期。</p>
<p><strong>自旋循环 Span Loop</strong></p>
<ul>
<li>自旋循环（Spin Loop）是一种忙等待（Busy-Waiting）机制，通常用于多线程编程中，当一个线程未能获取竞争锁（Contended Lock）时，它会不断检查锁的状态，直到锁被释放。</li>
<li>在没有优化的情况下，自旋循环会持续占用处理器资源（如指令分发带宽、执行单元等），导致高功耗和低效率。此外，在超线程（SMT）环境中，自旋循环可能会对共享资源（如执行单元和缓存）造成压力，影响其他线程的性能。</li>
</ul>
<hr>
<p><a id="299"></a></p>
<h3 id="2-9-9-其他解码注意事项（Other-Decode-Considerations）"><a href="#2-9-9-其他解码注意事项（Other-Decode-Considerations）" class="headerlink" title="2.9.9 其他解码注意事项（Other Decode Considerations）"></a><strong>2.9.9 其他解码注意事项（Other Decode Considerations）</strong></h3><p>略</p>
<hr>
<p><a id="210"></a></p>
<h2 id="2-10-整数执行单元（Integer-Execution-Unit）"><a href="#2-10-整数执行单元（Integer-Execution-Unit）" class="headerlink" title="2.10 整数执行单元（Integer Execution Unit）"></a>2.10 整数执行单元（Integer Execution Unit）</h2><p><img src="/image-2.png" alt="alt text"></p>
<h3 id="2-10-1-Schedulers"><a href="#2-10-1-Schedulers" class="headerlink" title="2.10.1 Schedulers"></a><strong>2.10.1 Schedulers</strong></h3><p>调度器每周期最多可以接收（前端dispatch到后端） 8 条宏操作（macro-ops），并跟踪其中包含的微操作（micro-ops）的操作数可用性和依赖关系执行需求。</p>
<p><strong>调度器吞吐量</strong></p>
<ul>
<li>ALU 调度器 ：每周期最多可以发出 6 条微操作。</li>
<li>AGU 调度器 ：每周期最多可以发出 4 条微操作。</li>
</ul>
<p><strong>性能瓶颈</strong></p>
<ul>
<li>高负载场景 :<ul>
<li>在计算密集型任务（如科学计算、加密算法）中，ALU 调度器可能成为瓶颈。</li>
<li>在内存密集型任务（如数据库查询、图像处理）中，AGU 调度器可能成为瓶颈。</li>
</ul>
</li>
</ul>
<p><strong>优化建议</strong></p>
<ul>
<li><strong>平衡操作类型</strong> ：<br>在编写代码时，尽量混合整数运算和内存操作，以充分利用 ALU 和 AGU 的并发能力。</li>
<li><strong>减少依赖链</strong> ：<br>避免创建长依赖链（如连续的累加操作），以减少调度器的压力。</li>
<li><strong>使用宽指令集</strong> ：<br>利用 SIMD 指令（如 AVX）来并行处理多个数据元素，从而提高整体效率。</li>
</ul>
<hr>
<p><a id="2102"></a></p>
<h3 id="2-10-2-执行单元（Execution-Units）"><a href="#2-10-2-执行单元（Execution-Units）" class="headerlink" title="2.10.2 执行单元（Execution Units）"></a><strong>2.10.2 执行单元（Execution Units）</strong></h3><p>处理器包含 6 个通用整数执行流水线。</p>
<ul>
<li>ALU0&#x2F;ALU1&#x2F;ALU2 ：<ul>
<li>支持通用整数运算。</li>
<li>额外支持乘法（Multiply）和 CRC 操作。整数乘法单元延迟为3个周期。</li>
</ul>
</li>
<li>ALU3&#x2F;ALU4&#x2F;ALU5 ：<ul>
<li>支持通用整数运算。</li>
<li>支持 PDEP&#x2F;PEXT、移位（Shift）、分支（Branch）操作。</li>
<li>ALU3 额外支持除法（Divide）操作。整数除法单元延迟为8个周期，商需要一个周期。</li>
</ul>
</li>
</ul>
<p>处理器还包含 4 个地址生成单元（AGUs），用于所有加载（Load）和存储（Store）地址的生成。所有 ALU 流水线都可以<strong>发出(issue)<strong>存储数据操作，每周期最多可以将两个</strong>整数存储操作</strong>写入<strong>存储队列</strong>(store queue)。</p>
<p><strong>优化建议</strong></p>
<ul>
<li>平衡简单和复杂操作的比例，避免在关键路径上集中高延迟操作。</li>
<li>利用 PDEP&#x2F;PEXT 和 LEA 等高效指令优化代码。</li>
<li>对于乘法和除法操作，了解其性能特性并采取替代方案（如 SIMD 或近似算法）。</li>
</ul>
<hr>
<p><a id="2103"></a></p>
<h3 id="2-10-3-退役控制单元（Retire-Control-Unit-RCU）"><a href="#2-10-3-退役控制单元（Retire-Control-Unit-RCU）" class="headerlink" title="2.10.3 退役控制单元（Retire Control Unit, RCU）"></a><strong>2.10.3 退役控制单元（Retire Control Unit, RCU）</strong></h3><p>退役控制单元（RCU）负责跟踪所有未完成操作（包括整数、加载&#x2F;存储和浮点运算）的完成状态，并作为异常处理和恢复的最终仲裁者。该单元<strong>每周期最多可以接收 8 条宏操作（macro-ops）</strong>，并在非 SMT 模式下<strong>跟踪最多 448 条在途宏操作</strong>，或者在 SMT 模式下每个线程最多跟踪 224 条宏操作。</p>
<p>在某些情况下，一个<strong>退役队列条目</strong>可以跟踪来自相邻指令的两条宏操作，这会增加退役队列的有效容量。</p>
<p>一条宏操作只有在其对应的所有微操作（micro-ops）完成执行后才有资格被退役单元提交。对于大多数快速路径双宏操作（fastpath double macro-ops），还需要两条宏操作都完成执行后才能提交。</p>
<p><u>退役单元每周期可以按顺序提交最多 8 个退役队列条目，这些条目可能代表超过 8 条宏操作</u>。</p>
<p>退役单元还<u>管理整数寄存器的映射和重命名</u>。<u>整数物理寄存器文件（PRF）</u>包含 240 个寄存器，其中每个线程最多有 40 个寄存器映射到架构状态或微架构临时状态。剩余的寄存器可用于乱序重命名。</p>
<p>整数物理寄存器文件不存储标志位信息。标志位信息保存在一个独立的<u>标志物理寄存器文件</u>中，该文件提供了 192 个可用寄存器，用于<u>对写标志位的指令进行乱序重命名</u>。</p>
<p><strong>退役队列</strong>的优化</p>
<ul>
<li><strong>双宏操作</strong>支持<br><strong>在某些情况下</strong>，一个退役队列条目可以同时跟踪两条相邻指令的宏操作。这种设计增加了退役队列的有效容量，从而减少了因队列满而导致的性能瓶颈。</li>
<li>提交规则<br>一条宏操作只有在其所有对应的微操作完成执行后才能被提交。对于快速路径双宏操作（如融合指令），要求两条宏操作都完成执行后才能提交。</li>
<li>提交吞吐量<br>每周期最多可以提交 8 个退役队列条目。这些条目可能代表超过 8 条宏操作。</li>
</ul>
<p><strong>优化建议</strong></p>
<ul>
<li>退役队列的限制 ：<ul>
<li>如果程序中存在大量长延迟操作（如除法、内存访问等），可能会导致退役队列被快速填满，从而降低性能。</li>
<li>优化建议 ：<ul>
<li><strong>减少长延迟操作的数量，尽量使用低延迟替代方案（如 SIMD 或近似算法）</strong>。</li>
<li><strong>避免过多的分支预测错误，因为错误预测会导致流水线清空，增加 RCU 的负担</strong>。</li>
</ul>
</li>
</ul>
</li>
<li>寄存器分配 ：<ul>
<li>整数寄存器和标志寄存器的分配是有限的，因此需要合理使用这些资源。</li>
<li>优化建议 ：<ul>
<li><strong>避免频繁写入标志位的指令（如 CMP、TEST），以减少标志寄存器的压力</strong>。</li>
<li>使用寄存器分配优化工具（如编译器选项 -O2 或 -O3）来减少寄存器冲突。</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<p><a id="211"></a></p>
<h2 id="2-11-浮点单元-（Floating-Point-Unit）"><a href="#2-11-浮点单元-（Floating-Point-Unit）" class="headerlink" title="2.11 浮点单元 （Floating-Point Unit）"></a>2.11 浮点单元 （Floating-Point Unit）</h2><p><img src="/image-3.png" alt="alt text"></p>
<p>处理器原生支持以下浮点数据类型：</p>
<ul>
<li>基本浮点数据类型 ：<ul>
<li>32 位单精度（Single Precision）</li>
<li>64 位双精度（Double Precision）</li>
<li>80 位扩展精度（Extended Precision）</li>
</ul>
</li>
<li>向量浮点数据类型 ：<ul>
<li>128 位、256 位和 512 位的整数、单精度、双精度以及 bfloat16 精度的向量浮点数据类型。</li>
</ul>
</li>
</ul>
<p>浮点加载和存储路径宽度为 512 位 。</p>
<p><strong>1. 浮点单元的架构</strong></p>
<ul>
<li>协处理器模型 ：<ul>
<li>浮点单元采用协处理器模型处理所有使用 X87、MMX™、XMM、YMM、ZMM 或浮点控制&#x2F;状态寄存器的操作。</li>
<li>它拥有独立的调度器（Scheduler）、寄存器文件（Register File）和重命名器（Renamer），不与整数单元共享这些资源。</li>
</ul>
</li>
<li>吞吐量与调度能力 ：<ul>
<li>每周期可以处理 8 条浮点宏操作 的<strong>分发(dispatch)<strong>和 6 条浮点宏操作 的</strong>重命名</strong>。</li>
<li>当浮点调度器已满或每周期分发超过 6 条浮点宏操作时，溢出的宏操作会被分配到容量为 96 条目的<strong>非调度队列（Non-Scheduling Queue, NSQ）</strong> 中。此举有助于加速加载和存储地址的计算，并支持每周期 8 条宏操作的分发带宽。</li>
</ul>
</li>
<li>浮点调度器容量 ：<ul>
<li>浮点调度器具有 3（个scheduler） × 38 条目 的宏操作容量。</li>
<li>每周期可以为每个执行管道<strong>发出(issue) 1 条微操作</strong> 。</li>
</ul>
</li>
<li>退役队列共享 ：<ul>
<li>浮点单元与整数单元共享<strong>退役队列（Retire Queue）</strong>，其容量在非 SMT 模式下为 448 条宏操作 ，在 SMT 模式下每个线程为 224 条宏操作 。</li>
</ul>
</li>
</ul>
<p><strong>2. 执行管道与接口</strong></p>
<ul>
<li>执行管道 ：<br>浮点单元包含 4 条执行管道（Pipe 0 至 Pipe 3） ，<strong>每条管道每周期可以执行一个操作</strong>。</li>
<li>加载与存储 ：<ul>
<li>浮点单元每周期可以从<strong>加载&#x2F;存储单元</strong>接收最多 两条 512 位<strong>加载</strong>操作。</li>
<li>浮点<strong>存储操作</strong>由两条管道支持，但吞吐量限制为每周期 1 次存储 。</li>
</ul>
</li>
<li>快速移动支持 ：<ul>
<li>有专用总线用于在<strong>浮点寄存器</strong>和<strong>整数寄存器</strong>之间快速移动数据。</li>
<li><strong>存储数据和浮点到通用寄存器</strong>的传输由两条专用管道（Pipe 4 和 Pipe 5）支持。</li>
</ul>
</li>
</ul>
<p><strong>3. 执行管道与源总线的竞争</strong></p>
<p>管道 0、1、2 和 3 支持需要三个操作数的操作。对于这些管道：</p>
<ul>
<li><strong>管道 0 和 2 的第三个操作数会与通常分配给管道 4 的源总线（source bus）发生竞争</strong>。</li>
<li><strong>管道 1 和 3 的第三个操作数会与通常分配给管道 5 的源总线发生竞争</strong>。</li>
</ul>
<p><strong>当发生这种竞争时，仲裁失败的操作会被暂停（stall）</strong>。</p>
<p>如果第三个操作数的数据或管道 4&#x2F;5 的数据能够从同一周期的结果中<strong>通过旁路（bypass）提供，则不会发生竞争</strong>。由于源数据由上一个周期的结果产生，不经过总线，所以不会发生竞争。</p>
<p><strong>4. 优化建议</strong></p>
<ul>
<li>减少对第三个操作数的需求，尤其是避免在同一周期内发出多个需要第三个操作数的指令。</li>
<li>利用旁路机制，确保数据能够快速传递，避免竞争。</li>
<li>在 AVX-512 中，优先使用零掩码代替合并掩码以减少源总线的使用，从而减少竞争。</li>
</ul>
<hr>
<p><a id="2111"></a></p>
<h3 id="2-11-1-浮点执行资源-Floating-Point-Execution-Resources"><a href="#2-11-1-浮点执行资源-Floating-Point-Execution-Resources" class="headerlink" title="2.11.1 浮点执行资源 Floating Point Execution Resources"></a><strong>2.11.1 浮点执行资源 Floating Point Execution Resources</strong></h3><table border='1'>
  <thead align='center'>
    <tr>
      <td rowspan='2'> Unit </td>
      <td colspan='6'> Pipe </td>
      <td rowspan='2'> Dowain </td>
      <td rowspan='2' align='left'> Ops Supported </td>
    </tr>
    <tr>
      <td> 0 </td>
      <td> 1 </td>
      <td> 2 </td>
      <td> 3 </td>
      <td> 4 </td>
      <td> 5 </td>
    </tr>
  </thead>
  <tbody align='center'>
    <tr>
      <td> FMUL </td>
      <td> * </td>
      <td> * </td>
      <td>  </td>
      <td>  </td>
      <td>  </td>
      <td>  </td>
      <td> F </td>
      <td align='left'> (v)FMUL*, (v)FMA*, Floating Point Compares, Blendv(DQ) </td>
    </tr>
    <tr>
      <td> FADD </td>
      <td>  </td>
      <td>  </td>
      <td> * </td>
      <td> * </td>
      <td>  </td>
      <td>  </td>
      <td> F </td>
      <td align='left'> (v)FADD* Signature </td>
    </tr>
    <tr>
      <td> FCVT </td>
      <td>  </td>
      <td>  </td>
      <td> * </td>
      <td> * </td>
      <td>  </td>
      <td>  </td>
      <td> F </td>
      <td align='left'> All convert operations except pack/unpack </td>
    </tr>
    <tr>
      <td> FDIV </td>
      <td>  </td>
      <td> * </td>
      <td>  </td>
      <td>  </td>
      <td>  </td>
      <td>  </td>
      <td> F </td>
      <td align='left'> All Divide and Square Root except Reciprocal Approximation </td>
    </tr>
    <tr>
    <td> FMISC </td>
      <td> * </td>
      <td> * </td>
      <td> * </td>
      <td> * </td>
      <td>  </td>
      <td>  </td>
      <td> F </td>
      <td align='left'> Moves and Logical operations on Floating Point Data Types </td>
    </tr>
    <tr>
      <td> STORE </td>
      <td>  </td>
      <td>  </td>
      <td> * </td>
      <td> * </td>
      <td> * </td>
      <td> * </td>
      <td> S </td>
      <td align='left'> Stores and Move to General Register (EX) Operations </td>
    </tr>
    <tr>
      <td> VADD </td>
      <td> * </td>
      <td> * </td>
      <td> * </td>
      <td> * </td>
      <td>  </td>
      <td>  </td>
      <td> I </td>
      <td align='left'> Integer Adds, Subtracts, and Compares </td>
    </tr>
    <tr>
      <td> VMUL </td>
      <td> * </td>
      <td> * </td>
      <td>  </td>
      <td> * </td>
      <td>  </td>
      <td>  </td>
      <td> I </td>
      <td align='left'> Integer Multiplies, SAD </td>
    </tr>
    <tr>
      <td> VSHUF </td>
      <td>  </td>
      <td>  </td>
      <td> * </td>
      <td> * </td>
      <td>  </td>
      <td>  </td>
      <td> I </td>
      <td align='left'> Data Shuffles, Packs, Unpacks, Permute, Blendvb </td>
    </tr>
    <tr>
      <td> VSHIFT </td>
      <td>  </td>
      <td>  </td>
      <td> * </td>
      <td> * </td>
      <td>  </td>
      <td>  </td>
      <td> I </td>
      <td align='left'> Bit Shift Left/Right operations </td>
    </tr>
    <tr>
      <td> VMISC </td>
      <td> * </td>
      <td> * </td>
      <td> * </td>
      <td> * </td>
      <td>  </td>
      <td>  </td>
      <td> I </td>
      <td align='left'> Moves and Logical operations on Packed Integer Data Types </td>
    </tr>
    <tr>
      <td> AES </td>
      <td> * </td>
      <td> * </td>
      <td>  </td>
      <td>  </td>
      <td>  </td>
      <td>  </td>
      <td> I </td>
      <td align='left'> *AES* </td>
    </tr>
    <tr>
      <td> CLM </td>
      <td> * </td>
      <td> * </td>
      <td>  </td>
      <td>  </td>
      <td>  </td>
      <td>  </td>
      <td>  </td>
      <td align='left'> *CLM* </td>
    </tr>
  </tbody>
</table>

<hr>
<p><a id="2112"></a></p>
<h3 id="2-11-2-代码优化建议（Code-Recommendations）"><a href="#2-11-2-代码优化建议（Code-Recommendations）" class="headerlink" title="2.11.2 代码优化建议（Code Recommendations）"></a><strong>2.11.2 代码优化建议（Code Recommendations）</strong></h3><p><strong>1. 充分利用 SIMD 指令集</strong></p>
<ul>
<li>使用 SSE、AVX 等 SIMD 指令集的向量化特性，以显著提高吞吐量。</li>
<li>AMD Zen5 支持 SSE、SSE2、SSE3、SSSE3、SSE4.1、SSE4.2、SSE4a、F16C、FMA、AVX、AVX2 和 AVX-512 。</li>
<li>优先使用 512 位（ZMM 寄存器）操作 ，因为 Zen5 的数据路径宽度为 512 位，全宽操作能最大化性能并降低功耗 。</li>
</ul>
<p><strong>2. 使用全宽度加载和存储指令</strong></p>
<p>使用全宽度加载&#x2F;存储指令（例如 vmovapd），而非分块操作（如 movapd 或 movlpd&#x2F;movhpd）。分块操作会增加指令数量和延迟，而全宽度操作只需一条指令即可完成。</p>
<p><strong>3. 使用零化惯用法&#x2F;置一惯用法清理&#x2F;设置寄存器</strong></p>
<p><strong>4. 设置 MXCSR.DAZ 和 MXCSR.FTZ</strong></p>
<p>如果可能，将 MXCSR 控制寄存器的 DAZ（Denorm As Zero）和 FTZ（Flush To Zero）标志置为 1。这可以避免因非规格化数（denormal numbers）导致的乘法、除法、平方根等操作的延迟。</p>
<p><strong>5. 避免条件分支</strong><br> 避免在数值计算中使用分支（如 if-else），改用条件移动或向量比较指令。</p>
<p><strong>6. 寄存器间移动无延迟</strong><br>XMM&#x2F;YMM&#x2F;ZMM 寄存器之间的移动（如 VMOVAPS）没有延迟，可放心使用。</p>
<p><strong>7. 保持数据类型一致性</strong></p>
<p>对同一数据的操作应使用一致的数据类型（例如，若使用 VMULPS 计算单精度浮点结果，后续操作也应使用单精度指令如 VANDPS 或 VMAXPS）。<br>这可以避免因数据类型转换导致的额外开销。</p>
<p><strong>8. 避免不必要的 GATHER 指令</strong><br>当索引已知时，避免使用 GATHER 指令，改用向量加载（vector loads）结合 shuffle 指令。GATHER 指令的延迟较高，而向量加载和 shuffle 可以提高内存带宽利用率。</p>
<hr>
<h3 id="2-11-3-x87-代码的浮点性能优化"><a href="#2-11-3-x87-代码的浮点性能优化" class="headerlink" title="2.11.3 x87 代码的浮点性能优化"></a><strong>2.11.3 x87 代码的浮点性能优化</strong></h3><p>以下是针对 x87 浮点代码的优化建议：</p>
<ul>
<li><strong>使用 FXCH 代替 push&#x2F;pop</strong><ul>
<li>尽可能使用 FXCH 指令交换 x87 浮点寄存器的值，而非通过 push&#x2F;pop 操作。FXCH 的交换速度更快，能够减少延迟 。</li>
</ul>
</li>
<li><strong>避免在 FCOM 和 FSTSW 之间插入指令</strong><ul>
<li>在浮点比较操作中，避免在 FCOM（比较浮点值）和 FSTSW（将状态字保存到 AX 寄存器）之间插入其他指令。这可以确保比较结果的正确性和性能 。</li>
</ul>
</li>
</ul>
<hr>
<p><a id="2114"></a></p>
<h3 id="2-11-4-非规格化数（Denormals）"><a href="#2-11-4-非规格化数（Denormals）" class="headerlink" title="2.11.4 非规格化数（Denormals）"></a><strong>2.11.4 非规格化数（Denormals）</strong></h3><p>非规格化浮点值（也称为次正规数，subnormals）可以通过以下两种方式产生：</p>
<ul>
<li><strong>显式指定</strong> ：在源代码中明确使用非规格化值。</li>
<li><strong>计算生成</strong> ：对正常浮点值进行计算时可能生成非规格化结果。</li>
</ul>
<p>在某些操作（如乘法 MUL、除法 DIV、平方根 SQRT）中，遇到非规格化值会引入轻微性能损失。对于 SSE&#x2F;AVX 指令，非规格化数的性能损失取决于 MXCSR 寄存器的配置以及在存在非规格化值时执行的指令序列。</p>
<p>如果不需要非规格化数的精度，建议软件设置 MXCSR.DAZ （将非规格化数视为零）和 MXCSR.FTZ （将非规格化数刷新为零）。设置这些标志位后，处理器在处理或生成非规格化值时，结果将不符合 IEEE-754 标准（损失精确性），但能避免性能损失 。</p>
<p>x87 浮点控制字（FCW）没有与 MXCSR.DAZ 或 MXCSR.FTZ 等效的功能，因此在使用 x87 指令时，无法避免因非规格化数导致的性能惩罚 。</p>
<h3 id="2-11-5-XMM-寄存器合并优化"><a href="#2-11-5-XMM-寄存器合并优化" class="headerlink" title="2.11.5 XMM 寄存器合并优化"></a><strong>2.11.5 XMM 寄存器合并优化</strong></h3><p>处理器实现了 XMM 寄存器合并优化 。其核心机制如下：</p>
<ul>
<li><p><strong>高位清零跟踪</strong> ：</p>
<ul>
<li>处理器会跟踪那些高位（例如 128 位寄存器的高 96 位）已被清零的 XMM 寄存器。这一信息可以跨多个操作和目标寄存器传递，直到有非零数据被写入这些高位 。<strong>如果后续指令未修改这些高位，则无需重新合并寄存器的高位部分，从而减少延迟</strong>。</li>
</ul>
</li>
<li><p>合并优化的触发条件 ：</p>
<ul>
<li>如果某条指令（如 SQRTSS）的目标寄存器高位未被修改（例如 SQRTSS 仅操作低 32 位），且后续指令未向高位写入非零数据，则该指令可以绕过常规的结果合并步骤，直接执行而无需等待前序指令完成 。</li>
</ul>
</li>
<li><p>受益指令列表 ：<br>以下指令可以利用此优化（因其仅修改寄存器的低位部分）：</p>
<ul>
<li>标量转换指令 ：<code>CVTPI2PS</code>, <code>CVTSI2SS</code>, <code>CVTSD2SS</code>, <code>CVTSS2SD</code>, <code>CVTSI2SD</code></li>
<li>标量移动指令 ：<code>MOVSS xmm1, xmm2</code>, <code>MOVSD xmm1, xmm2</code>, <code>MOVLPS xmm1, [mem]</code>, <code>MOVLPD xmm1, [mem]</code></li>
<li>标量浮点运算指令 ：<code>RCPSS</code>, <code>ROUNDSS</code>, <code>ROUNDSD</code>, <code>RSQRTSS</code>, <code>SQRTSD</code>, <code>SQRTSS</code></li>
</ul>
</li>
</ul>
<hr>
<h3 id="2-11-6-混合使用-AVX-和-SSE-指令的性能惩罚"><a href="#2-11-6-混合使用-AVX-和-SSE-指令的性能惩罚" class="headerlink" title="2.11.6 混合使用 AVX 和 SSE 指令的性能惩罚"></a><strong>2.11.6 混合使用 AVX 和 SSE 指令的性能惩罚</strong></h3><p>当 ZMM 寄存器的上部 384 位包含非零数据时，<strong>混合使用 SSE 和 AVX 指令会导致性能损失</strong>。此时，SSE 操作会被提升为 256 位或 512 位操作以合并数据到结果中。这会导致那些不依赖结果操作数的指令<strong>产生额外的依赖关系</strong>。</p>
<h3 id="2-11-7-何时使用-FMA-而非-FMUL-FADD"><a href="#2-11-7-何时使用-FMA-而非-FMUL-FADD" class="headerlink" title="2.11.7 何时使用 FMA 而非 FMUL&#x2F;FADD"></a><strong>2.11.7 何时使用 FMA 而非 FMUL&#x2F;FADD</strong></h3><p>在某些情况下，软件需要在 FMA（融合乘加） 和单独的 FMUL（乘法）&#x2F;FADD（加法） 操作之间选择。以下是具体指导原则：</p>
<ul>
<li><p><strong>不建议使用 FMA 的情况</strong> ：</p>
<ul>
<li><strong>关键依赖链通过 FMA 的加数输入</strong><blockquote>
<p>vfmadd231ss xmm0, xmm1, xmm2  &#x2F;&#x2F; xmm0 &#x3D; xmm0 + (xmm1 * xmm2)， xmm0存在依赖链</p>
</blockquote>
</li>
</ul>
</li>
<li><p><strong>建议使用 FMA 的情况</strong> ：</p>
<ul>
<li><strong>关键依赖链通过 FMUL 到 FADD 的路径</strong><blockquote>
<p>vmulss xmm1, xmm2, xmm3      &#x2F;&#x2F; xmm1 &#x3D; xmm2 * xmm3<br>  vaddss xmm0, xmm0, xmm1      &#x2F;&#x2F; xmm0 &#x3D; xmm0 + xmm1<br>  vfmadd231ss xmm0, xmm2, xmm3 &#x2F;&#x2F; xmm0 &#x3D; xmm0 + (xmm2 * xmm3), 优化后</p>
</blockquote>
</li>
<li>操作数不在关键依赖链中</li>
</ul>
</li>
</ul>
<hr>
<p><a id="212"></a></p>
<h2 id="2-12-加载-存储单元（Load-Store-Unit-LS）"><a href="#2-12-加载-存储单元（Load-Store-Unit-LS）" class="headerlink" title="2.12 加载-存储单元（Load-Store Unit, LS）"></a>2.12 加载-存储单元（Load-Store Unit, LS）</h2><p><img src="/image-4.png" alt="alt text"></p>
<p>加载-存储单元（LS 单元）负责处理数据访问。LS 单元包含 4 条高度独立的流水线 ，每周期最多可执行 4 条内存操作 。具体限制如下：</p>
<ul>
<li>加载操作 ：<br>每周期最多支持 2 条 128&#x2F;256&#x2F;512 位加载操作 。</li>
<li>存储操作 ：<br>每周期最多支持 2 条存储操作 ，但如果存储操作是 512 位，则每周期仅限 1 条 。</li>
</ul>
<p><strong>1. LS 单元的关键组件</strong></p>
<ul>
<li><strong>加载队列（LDQ）</strong> ：<ul>
<li>接收分发(dispatch)的加载操作，并跟踪未完成的加载。</li>
<li>最多可跟踪 64 条未完成的加载操作 ，且对已完成的加载数量没有硬性限制 。</li>
</ul>
</li>
<li><strong>存储队列（STQ）</strong> ：<ul>
<li>包含 104 个条目 ，用于保存从分发到数据写入数据缓存（Data Cache）的存储操作 。</li>
</ul>
</li>
</ul>
<p><strong>2. 动态重排序与内存一致性</strong></p>
<ul>
<li><strong>动态重排序</strong> ：<ul>
<li>LS 单元支持<strong>加载绕过旧加载</strong> 和 <strong>加载绕过无冲突的旧存储</strong> 。</li>
<li>这种机制提高了内存操作的并行性，同时确保遵循 AMD64 架构的内存顺序规则 。</li>
</ul>
</li>
<li><strong>Store-to-Load Forwarding (STLF)</strong> ：<ul>
<li>当存储操作的数据已就绪且完全包含在加载操作的地址范围内时，<strong>LS 单元可以直接将存储数据转发给加载操作</strong>（无需等待数据写入缓存）。</li>
<li>加载操作无需特定对齐，只要其地址完全包含在存储操作的地址范围内即可 。</li>
</ul>
</li>
</ul>
<p><strong>3. 地址冲突与优化建议</strong></p>
<ul>
<li>地址匹配规则 ：<ul>
<li>处理器使用<strong>线性地址的 低 12 位（11:0）</strong> 判断是否满足 STLF 条件。</li>
<li>如果多个存储操作具有相同的低 12 位地址（但高位地址不同），且同时存在未完成的加载操作需要 STLF，可能导致性能损失。</li>
</ul>
</li>
<li>优化建议 ：<ul>
<li><strong>避免地址冲突</strong> ：避免同时有多个存储操作的低 12 位地址相同但高位不同的情况。</li>
<li><strong>紧密分组操作</strong> ：将加载操作紧接在相关存储操作之后，以最大化 STLF 的效率。</li>
</ul>
</li>
</ul>
<p><strong>4. LS 单元的缓存未命中跟踪能力 Outstanding Cache Misses</strong></p>
<p>LS 单元最多可以跟踪 124 个未完成的缓存未命中 ，确保高并发内存操作时不会因缓存未命中导致流水线停滞 。</p>
<p><strong>5. AGU 与 LS 流水线的寻址模式优化</strong></p>
<ul>
<li><strong>简单寻址模式（Simple Addressing Modes）</strong> ：<br>以下寻址模式被视为简单模式，具有较低的加载延迟：<ul>
<li>基址+位移 （Base+Displacement）</li>
<li>基址+索引 （Base+Index）</li>
<li>无缩放的索引+位移 （Unscaled Index+Displacement）</li>
<li>纯位移模式 （Displacement-Only）</li>
<li>延迟表现 ：<ul>
<li>整数加载（Integer Load）：<strong>4</strong> 周期 （Load-to-Use）</li>
<li>浮点加载（FP Load）：<strong>7</strong> 周期 （Load-to-Use）</li>
</ul>
</li>
</ul>
</li>
<li><strong>复杂寻址模式（Complex Addressing Modes）</strong> ：<br>以下模式需要额外的地址计算周期：<ul>
<li>基址+索引+位移 （Base+Index+Displacement）</li>
<li>任何使用缩放索引 （如 *2, *4, *8）的寻址模式</li>
<li>延迟表现 ：<ul>
<li>整数加载：<strong>5</strong> 周期 （比简单模式多 1 周期）</li>
<li>浮点加载：<strong>8</strong> 周期 （比简单模式多 1 周期）</li>
</ul>
</li>
<li>编译器建议 ：<br>在延迟敏感的代码中，编译器应避免使用复杂寻址模式 。</li>
</ul>
</li>
</ul>
<hr>
<p><a id="2121"></a></p>
<h3 id="2-12-1-数据预取（Prefetching-of-Data）"><a href="#2-12-1-数据预取（Prefetching-of-Data）" class="headerlink" title="2.12.1 数据预取（Prefetching of Data）"></a><strong>2.12.1 数据预取（Prefetching of Data）</strong></h3><p>AMD Zen5 微架构为其 L1 数据缓存和 L2 缓存实现了数据预取逻辑（Prefetch Logic）。一般来说：</p>
<ul>
<li><strong>L1 数据预取器 ：将数据预取到 L1 数据缓存和 L2 缓存中</strong>。</li>
<li><strong>L2 数据预取器 ：仅将数据预取到 L2 缓存中</strong> 。</li>
</ul>
<p><strong>预取器类型</strong><br>以下是 Zen5 的预取器分类及其功能：</p>
<ul>
<li><strong>L1 Stream 预取器</strong>：<br>根据内存访问模式的历史记录，按升序或降序预取连续的缓存行（cacheline）。<br>示例：顺序遍历数组时触发预取。</li>
<li><strong>L1 Stride 预取器</strong> ：<br>根据单条指令的内存访问历史记录，预取固定步长（stride）的缓存行。<br>支持识别“跳跃模式”（如二维数组访问），只要跳跃距离固定且间隔规律。</li>
<li><strong>L1 Region 预取器</strong> ：<br>当某条指令的数据访问后，后续访问呈现局部区域内的稳定模式时触发预取。<br>示例：在紧凑的循环中访问相邻内存区域。</li>
<li><strong>L2 Stream 预取器</strong> ：<br>类似 L1 Stream，但作用于 L2 缓存，预取顺序缓存行。</li>
<li><strong>L2 Up&#x2F;Down 预取器</strong> ：<br>根据内存访问历史，决定预取下一条或前一条缓存行。<br>适用于双向遍历（如链表或双向数据流）。</li>
</ul>
<hr>
<p><a id="213"></a></p>
<h2 id="2-13-写入数据优化（Optimizing-Writing-Data）"><a href="#2-13-写入数据优化（Optimizing-Writing-Data）" class="headerlink" title="2.13 写入数据优化（Optimizing Writing Data）"></a>2.13 写入数据优化（Optimizing Writing Data）</h2><p>写合并（Write-Combining） 是一种将多个内存写入操作合并到同一写缓冲区地址范围内的技术。AMD Zen5 处理器支持 <strong>内存类型范围寄存器（MTRR）</strong> 和 <strong>页属性表（PAT）</strong> 扩展，允许软件将<strong>内存区域</strong>定义为以下类型之一：</p>
<ul>
<li>Write-Back (WB) ：常规缓存模式。</li>
<li>Write-Protected (WP) ：写保护模式。</li>
<li>Write-Through (WT) ：写直达模式。</li>
<li>Uncacheable (UC) ：不可缓存模式。</li>
<li>Write-Combining (WC) ：写合并模式 。</li>
</ul>
<p>当内存区域被定义为 WC 模式 时，处理器会将多个写入操作（针对该范围内的地址）合并到一个合并缓冲区（merge buffer）中。合并多个写入操作为单次操作可以减少处理器总线利用率和流水线停滞（stalls）。此外，写合并缓冲区 也用于流式存储指令（如 MOVNTQ 和 MOVNTI）。</p>
<p>通过 MTRR 或 PAT 将频繁写入的内存区域（如帧缓冲区、临时数据缓冲区）<strong>设置为 WC 模式，以减少总线压力</strong>。</p>
<hr>
<h3 id="2-13-1-软件预取数据或指令"><a href="#2-13-1-软件预取数据或指令" class="headerlink" title="2.13.1 软件预取数据或指令"></a><strong>2.13.1 软件预取数据或指令</strong></h3><p>AMD Zen5 微架构通过改进的软件预取控制，允许 PREFETCH 指令将数据或指令显式预取到缓存层次结构的特定层级。新增的两种局部性引用类型 IT0 和 IT1 专门用于<strong>指令预取（Instruction Prefetch）</strong>，进一步优化代码执行效率 。</p>
<ul>
<li><strong>IT0</strong> ：预取到 L1 指令缓存（I-Cache）。</li>
<li><strong>IT1</strong> ：预取到 L2 缓存，适用于需要长期保留的指令。</li>
</ul>
<p>具体指令见Spec.</p>
<hr>
<p><a id="2132"></a></p>
<h3 id="2-13-2-写合并操作（Write-Combining-Operations）"><a href="#2-13-2-写合并操作（Write-Combining-Operations）" class="headerlink" title="2.13.2 写合并操作（Write-Combining Operations）"></a><strong>2.13.2 写合并操作（Write-Combining Operations）</strong></h3><p>为了提高系统性能，AMD Zen5 处理器引入了 写合并缓冲区（Write Combining Buffer, WCB） ，其核心机制如下：</p>
<p><strong>WCB 的组成 ：</strong><br>WCB 包含多个 64 字节对齐的写缓冲区 ，每个缓冲区对应一个缓存行（cache line）。</p>
<p><strong>合并规则 ：</strong></p>
<ul>
<li>WC 内存类型 ：<ul>
<li>WC 模式的写操作可以按任意顺序合并，直到填满 64 字节缓冲区。支持的数据类型包括字节、字、双字、四字、XMM&#x2F;YMM&#x2F;ZMM 字（如 MOVNTI 指令）。</li>
<li>其他内存类型（UC&#x2F;WP&#x2F;WT&#x2F;WB） ：<br>除非被流式存储指令（如 MOVNTQ、MOVNTI）覆盖，否则这些模式的写操作无法合并。流式指令的合并行为与 WC 内存模式一致。</li>
</ul>
</li>
</ul>
<p><strong>部分填充的缓冲区问题 ：</strong></p>
<ul>
<li>如果写操作未对齐到 64 字节边界，可能<strong>导致缓冲区部分填充，长时间未关闭（flush），从而降低后续写操作的带宽</strong>。</li>
<li>优化建议 ：<br>将写合并操作<strong>对齐到 64 字节缓存行边界，避免部分填充</strong>。如果必须从非对齐地址开始写入，可以在代码中插入 写合并完成事件 （如 SFENCE 或 MFENCE）以强制刷新缓冲区 。</li>
</ul>
<p><strong>合并中断条件 ：</strong><br>合并会在以下情况中断（如引用  中的 Table 9）：</p>
<ul>
<li>遇到 <code>SFENCE</code>、<code>MFENCE</code> 或 <code>CLFLUSH</code> 指令。</li>
<li>缓冲区被填满（64 字节）。</li>
<li>发生上下文切换或异常。</li>
</ul>
<hr>
<p><a id="2133"></a></p>
<h3 id="2-13-3-将写缓冲区数据发送到系统（Sending-Write-Buffer-Data-to-the-System）"><a href="#2-13-3-将写缓冲区数据发送到系统（Sending-Write-Buffer-Data-to-the-System）" class="headerlink" title="2.13.3 将写缓冲区数据发送到系统（Sending Write-Buffer Data to the System）"></a><strong>2.13.3 将写缓冲区数据发送到系统（Sending Write-Buffer Data to the System）</strong></h3><p>AMD Zen5 处理器通过写合并（Write Combining）实现最大吞吐量的条件如下：</p>
<ul>
<li><strong>数据有效性</strong> ：<br>当所有 四字（quadword, 8 字节） 或 双字（doubleword, 4 字节） 写入操作的数据有效时，处理器可以将多个 16 字节写入<strong>合并</strong>为一个 64 字节的高效内存写入 ，从而<u>最大化带宽利用率</u>。</li>
<li><strong>多缓存行支持</strong> ：<br>处理器可以从 12 个不同的 64 字节缓存行 中收集写入数据。在 SMT（同步多线程）模式下，单个线程最多可以处理 11 个缓存行 的写合并流。</li>
<li><strong>吞吐量优化</strong> ：<br>当同时进行的<strong>写合并流（write-combining streams）数量较少</strong>时，吞吐量最佳。</li>
</ul>
<hr>
<p><a id="2134"></a></p>
<h3 id="2-13-4-字符串存储优化（String-Store-Optimizations）"><a href="#2-13-4-字符串存储优化（String-Store-Optimizations）" class="headerlink" title="2.13.4 字符串存储优化（String Store Optimizations）"></a><strong>2.13.4 字符串存储优化（String Store Optimizations）</strong></h3><p>AMD Zen5 架构针对 rep movs 和 rep stos 等字符串指令（string instructions）的存储操作进行了多项优化，以提升性能。</p>
<p><strong>1. 大字符串的流式存储优化</strong></p>
<ul>
<li>触发条件 ：<br>当字符串大小 大于或等于处理器的 L3 缓存容量 时，Zen5 会使用 流式存储（streaming-store） 操作 。</li>
<li>流式存储的特点 ：<ul>
<li>非缓存写入 ：数据绕过缓存层次结构（L1&#x2F;L2&#x2F;L3），直接通过 <strong>写合并缓冲区（WCB）</strong> 聚合后写入内存。</li>
<li>避免缓存污染 ：防止字符串数据替换掉缓存中其他有用的数据，提升整体性能。</li>
</ul>
</li>
</ul>
<p><strong>2. 小字符串的 RFO 优化</strong></p>
<ul>
<li>优化触发条件 ：<br>当字符串指令 <strong>完全覆盖目标缓存行</strong> 时，Zen5 会消除 读取所有权（Read For Ownership, RFO） 操作，即使缓存行未被预取 。</li>
<li>RFO 的代价 ：<br>RFO 需要先从内存中读取缓存行到缓存，再修改并写回。Zen5 的优化允许直接分配缓存行（无需读取），从而减少延迟。</li>
<li>阈值限制 ：<br>优化的触发阈值取决于具体实现，但字符串无需严格对齐到缓存行大小（如 64 字节）。如果缓存行未被完全覆盖（如部分写入），仍需执行 RFO。</li>
</ul>
<p><strong>3. 内存可见性与一致性</strong></p>
<ul>
<li>乱序可见性 ：<br>字符串指令产生的存储操作可能对其他处理器乱序可见，但 Zen5 保证以下顺序：<ul>
<li>**前序存储 （older stores）**在字符串存储之前完成可见性。</li>
<li>**后续存储 （younger stores）**在字符串存储完成后才可见 。</li>
</ul>
</li>
</ul>
<p><strong>4. 核心机制 ：</strong></p>
<ul>
<li><strong>大字符串使用流式存储绕过缓存，减少污染</strong> 。</li>
<li><strong>小字符串通过消除 RFO 加速完全覆盖写入</strong> 。</li>
</ul>
<hr>
<p><a id="214"></a></p>
<h2 id="2-14-同步多线程（Simultaneous-Multi-Threading-SMT）"><a href="#2-14-同步多线程（Simultaneous-Multi-Threading-SMT）" class="headerlink" title="2.14 同步多线程（Simultaneous Multi-Threading, SMT）"></a>2.14 同步多线程（Simultaneous Multi-Threading, SMT）</h2><p>为了提高指令吞吐量，处理器实现了 同步多线程（SMT） 。单线程应用程序通常无法完全占用处理器的所有资源，SMT 允许处理器利用未使用的资源并发执行第二个线程。</p>
<p><strong>SMT 的核心机制</strong></p>
<ul>
<li>资源分配类型 ：<br>在双线程模式下，处理器资源（如队列条目、缓存、流水线、执行单元）可通过以下三种模式管理：<ul>
<li><strong>竞争共享（Competitively Shared）</strong> ：<br>资源按需动态分配，单个线程可能占用所有资源条目。<br>示例 ：L3 缓存默认采用此模式 。</li>
<li><strong>水印限制（Watermarked）</strong> ：<br>资源按需分配，但在双线程模式下，每个线程的资源使用量受限于预设的水印阈值。</li>
<li><strong>静态分区（Statically Partitioned）</strong> ：<br>资源在进入双线程模式时被静态划分，每个线程仅能使用其分配的分区资源 。</li>
</ul>
</li>
<li>资源分配策略的配置 ：<ul>
<li>L3 缓存 ：默认为竞争共享模式，但可通过 AMD64 技术平台服务质量扩展（QoS Extensions） 调整策略 。</li>
<li>其他资源 ：如调度队列、执行单元等，可能采用水印或静态分区模式。</li>
</ul>
</li>
</ul>
<table border="1">
<caption> Resource Sharing</caption>
<thead>
  <tr>
    <th>Resource</th>
    <th>Competitively Shared</th>
    <th>Watermarked</th>
    <th>Static Partitioned</th>
  </tr>
</thead>
<tbody>
  <tr>
    <td>L1 Instruction Cache</td>
    <td>Yes</td>
    <td></td>
    <td></td>
  </tr>
  <tr>
    <td>ITLB</td>
    <td>Yes</td>
    <td></td>
    <td></td>
  </tr>
  <tr>
    <td>Op Cache</td>
    <td>Yes</td>
    <td></td>
    <td></td>
  </tr>
  <tr>
    <td>Dispatch Interface</td>
    <td>Yes</td>
    <td></td>
    <td></td>
  </tr>
  <tr>
    <td>DTLB</td>
    <td>Yes</td>
    <td></td>
    <td></td>
  </tr>
  <tr>
    <td>L2 Cache</td>
    <td>Yes</td>
    <td></td>
    <td></td>
  </tr>
  <tr>
    <td>L3 Cache</td>
    <td>Yes</td>
    <td></td>
    <td></td>
  </tr>
  <tr>
    <td>Integer Scheduler</td>
    <td></td>
    <td>Yes</td>
    <td></td>
  </tr>
  <tr>
    <td>Integer Register File</td>
    <td></td>
    <td>Yes</td>
    <td></td>
  </tr>
  <tr>
    <td>Load Queue</td>
    <td></td>
    <td>Yes</td>
    <td></td>
  </tr>
  <tr>
    <td>Floating Point Physical Register</td>
    <td></td>
    <td>Yes</td>
    <td></td>
  </tr>
  <tr>
    <td>Floating Point Scheduler</td>
    <td></td>
    <td>Yes</td>
    <td></td>
  </tr>
  <tr>
    <td>Memory Request Buffers</td>
    <td></td>
    <td>Yes</td>
    <td></td>
  </tr>
  <tr>
    <td>Op Queue</td>
    <td></td>
    <td></td>
    <td>Yes</td>
  </tr>
  <tr>
    <td>Store Queue</td>
    <td></td>
    <td></td>
    <td>Yes</td>
  </tr>
  <tr>
    <td>Write Combining Buffer</td>
    <td></td>
    <td>Yes</td>
    <td></td>
  </tr>
  <tr>
    <td>Retire Queue</td>
    <td></td>
    <td></td>
    <td>Yes</td>
  </tr>
</tbody>
</table>

<hr>

                
                <hr>
                <!-- Pager -->
                <ul class="pager">
                    
                    <li class="previous">
                        <a href="/2025/04/08/RISC-V-扩展命名规则总结/" data-toggle="tooltip" data-placement="top" title="RISC-V 扩展命名规则总结">&larr; Previous Post</a>
                    </li>
                    
                    
                    <li class="next">
                        <a href="/2024/06/11/opensbi启动分析/" data-toggle="tooltip" data-placement="top" title="opensbi启动分析">Next Post &rarr;</a>
                    </li>
                    
                </ul>

                <!-- tip start -->
                

                
                <!-- tip end -->

                <!-- Music start-->
                
                <!-- Music end -->

                <!-- Sharing -->
                
                <!-- Sharing -->

                <!-- gitment start -->
                
                <!-- gitment end -->

                <!-- 来必力City版安装代码 -->
                
                <!-- City版安装代码已完成 -->

                <!-- disqus comment start -->
                
                <!-- disqus comment end -->
            </div>
            
            <!-- Tabe of Content -->
            <!-- Table of Contents -->

    
      
        <aside id="sidebar">
          <div id="toc" class="toc-article">
          <strong class="toc-title">Contents</strong>
          
            
              <ol class="toc-nav"><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#%E7%9B%AE%E5%BD%95"><span class="toc-nav-number">1.</span> <span class="toc-nav-text">目录</span></a></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#1-%E5%BC%95%E8%A8%80"><span class="toc-nav-number">2.</span> <span class="toc-nav-text">1. 引言</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#1-1-%E7%9B%AE%E6%A0%87%E5%8F%97%E4%BC%97"><span class="toc-nav-number">2.1.</span> <span class="toc-nav-text">1.1 目标受众</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#1-2-%E7%9B%B8%E5%85%B3%E6%96%87%E6%A1%A3"><span class="toc-nav-number">2.2.</span> <span class="toc-nav-text">1.2 相关文档</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#1-3-%E4%B8%93%E4%B8%9A%E6%9C%AF%E8%AF%AD"><span class="toc-nav-number">2.3.</span> <span class="toc-nav-text">1.3 专业术语</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#2-Zen5-%E5%A4%84%E7%90%86%E5%99%A8%E5%BE%AE%E6%9E%B6%E6%9E%84"><span class="toc-nav-number">3.</span> <span class="toc-nav-text">2. Zen5 处理器微架构</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#2-1-%E5%85%B3%E9%94%AE%E5%BE%AE%E6%9E%B6%E6%9E%84%E7%89%B9%E6%80%A7"><span class="toc-nav-number">3.1.</span> <span class="toc-nav-text">2.1 关键微架构特性</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#2-2-%E7%BC%93%E5%AD%98%E4%B8%8E%E6%95%B0%E6%8D%AE%E9%80%9A%E8%B7%AF"><span class="toc-nav-number">3.2.</span> <span class="toc-nav-text">2.2 缓存与数据通路</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#2-3-%E6%8C%87%E4%BB%A4%E5%88%86%E8%A7%A3%E6%9C%BA%E5%88%B6"><span class="toc-nav-number">3.3.</span> <span class="toc-nav-text">2.3 指令分解机制</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#2-4-%E8%B6%85%E6%A0%87%E9%87%8F%E6%9E%B6%E6%9E%84"><span class="toc-nav-number">3.4.</span> <span class="toc-nav-text">2.4 超标量架构</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#2-5-%E5%A4%84%E7%90%86%E5%99%A8%E7%BB%93%E6%9E%84"><span class="toc-nav-number">3.5.</span> <span class="toc-nav-text">2.5 处理器结构</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#2-6-%E7%BC%93%E5%AD%98%E6%93%8D%E4%BD%9C"><span class="toc-nav-number">3.6.</span> <span class="toc-nav-text">2.6 缓存操作</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#2-6-1-L1I-Cache"><span class="toc-nav-number">3.6.1.</span> <span class="toc-nav-text">2.6.1 L1I Cache:</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#2-6-2-L1D-Cache"><span class="toc-nav-number">3.6.2.</span> <span class="toc-nav-text">2.6.2 L1D Cache:</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#2-6-2-1-Bank-Conflicts"><span class="toc-nav-number">3.6.2.1.</span> <span class="toc-nav-text">2.6.2.1 Bank Conflicts:</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#2-6-2-2-512bit-load-store-%E6%93%8D%E4%BD%9C%EF%BC%9A"><span class="toc-nav-number">3.6.2.2.</span> <span class="toc-nav-text">2.6.2.2 512bit load&#x2F;store 操作：</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#2-6-2-3-%E5%9F%BA%E4%BA%8E%E7%BA%BF%E6%80%A7%E5%9C%B0%E5%9D%80%E7%9A%84utag-way-predictor"><span class="toc-nav-number">3.6.2.3.</span> <span class="toc-nav-text">2.6.2.3 基于线性地址的utag&#x2F;way-predictor</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#2-6-3-L2-Cache"><span class="toc-nav-number">3.6.3.</span> <span class="toc-nav-text">2.6.3 L2 Cache</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#2-6-4-L3-Cache"><span class="toc-nav-number">3.6.4.</span> <span class="toc-nav-text">2.6.4 L3 Cache</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#2-7-%E5%86%85%E5%AD%98%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2"><span class="toc-nav-number">3.7.</span> <span class="toc-nav-text">2.7 内存地址转换</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#2-7-1-%E4%B8%A4%E7%BA%A7TLB%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1"><span class="toc-nav-number">3.7.1.</span> <span class="toc-nav-text">2.7.1 两级TLB结构设计</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#2-7-2-%E7%A1%AC%E4%BB%B6%E9%A1%B5%E8%A1%A8%E9%81%8D%E5%8E%86%E5%99%A8%E4%B8%8E%E5%8A%A0%E9%80%9F%E6%9C%BA%E5%88%B6"><span class="toc-nav-number">3.7.2.</span> <span class="toc-nav-text">2.7.2 硬件页表遍历器与加速机制</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#2-7-3-%E8%99%9A%E6%8B%9F%E5%8C%96%E4%B8%8E%E8%83%BD%E6%95%88%E4%BC%98%E5%8C%96"><span class="toc-nav-number">3.7.3.</span> <span class="toc-nav-text">2.7.3 虚拟化与能效优化</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#2-7-4-%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94%E4%B8%8E%E5%9C%BA%E6%99%AF%E5%BA%94%E7%94%A8"><span class="toc-nav-number">3.7.4.</span> <span class="toc-nav-text">2.7.4 性能对比与场景应用</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#2-8-%E5%88%86%E6%94%AF%E4%BC%98%E5%8C%96"><span class="toc-nav-number">3.8.</span> <span class="toc-nav-text">2.8 分支优化</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#2-8-1-%E5%88%86%E6%94%AF%E9%A2%84%E6%B5%8B%E5%99%A8"><span class="toc-nav-number">3.8.1.</span> <span class="toc-nav-text">2.8.1 分支预测器</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#2-8-1-1-next-address-logic"><span class="toc-nav-number">3.8.1.1.</span> <span class="toc-nav-text">2.8.1.1 next-address logic</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#2-8-1-2-Branch-Target-Buffer"><span class="toc-nav-number">3.8.1.2.</span> <span class="toc-nav-text">2.8.1.2 Branch Target Buffer</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#2-8-1-3-Return-Address-Stack"><span class="toc-nav-number">3.8.1.3.</span> <span class="toc-nav-text">2.8.1.3 Return Address Stack</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#2-8-1-4-Indirect-Target-Predictor"><span class="toc-nav-number">3.8.1.4.</span> <span class="toc-nav-text">2.8.1.4 Indirect Target Predictor</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#2-8-1-5-Advanced-Conditional-Branch-Direction-Predictor"><span class="toc-nav-number">3.8.1.5.</span> <span class="toc-nav-text">2.8.1.5 Advanced Conditional Branch Direction Predictor</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#2-8-1-6-Fetch-Window-Tracking-Structure"><span class="toc-nav-number">3.8.1.6.</span> <span class="toc-nav-text">2.8.1.6 Fetch Window Tracking Structure</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#2-8-2-%E8%B7%A8%E8%BE%B9%E7%95%8C%E5%88%86%E6%94%AF%EF%BC%88Boundary-Crossing-Branches%EF%BC%89"><span class="toc-nav-number">3.8.2.</span> <span class="toc-nav-text">2.8.2 跨边界分支（Boundary Crossing Branches）</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#2-8-3-%E5%BE%AA%E7%8E%AF%E5%AF%B9%E9%BD%90%EF%BC%88Loop-Alignment%EF%BC%89"><span class="toc-nav-number">3.8.3.</span> <span class="toc-nav-text">2.8.3 循环对齐（Loop Alignment）</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#2-8-3-1-%E7%BC%96%E7%A0%81%E5%A1%AB%E5%85%85%E4%BB%A5%E5%AE%9E%E7%8E%B0%E5%BE%AA%E7%8E%AF%E5%AF%B9%E9%BD%90"><span class="toc-nav-number">3.8.3.1.</span> <span class="toc-nav-text">2.8.3.1 编码填充以实现循环对齐</span></a></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#2-9-%E5%8F%96%E6%8C%87%E4%B8%8E%E8%AF%91%E7%A0%81"><span class="toc-nav-number">3.9.</span> <span class="toc-nav-text">2.9 取指与译码</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#2-9-1-Op-Cache"><span class="toc-nav-number">3.9.1.</span> <span class="toc-nav-text">2.9.1 Op Cache</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#2-9-2-%E4%BE%9D%E8%B5%96%E9%A1%B9%E6%B6%88%E9%99%A4%E7%9A%84%E6%83%AF%E7%94%A8%E6%96%B9%E6%B3%95Idioms-for-Dependency-removal"><span class="toc-nav-number">3.9.2.</span> <span class="toc-nav-text">2.9.2 依赖项消除的惯用方法Idioms for Dependency removal</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#2-9-3-%E5%88%86%E6%94%AF%E8%9E%8D%E5%90%88-Branch-Fusion"><span class="toc-nav-number">3.9.3.</span> <span class="toc-nav-text">2.9.3 分支融合 Branch Fusion</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#2-9-4-MOV-ALU-Fusion"><span class="toc-nav-number">3.9.4.</span> <span class="toc-nav-text">2.9.4 MOV + ALU Fusion</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#2-9-5-Zero-Cycle-Move"><span class="toc-nav-number">3.9.5.</span> <span class="toc-nav-text">2.9.5 Zero Cycle Move</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#2-9-6-%E6%A0%88%E6%8C%87%E9%92%88%E8%B7%9F%E8%B8%AA%E4%BB%A5%E6%B6%88%E9%99%A4%E4%BE%9D%E8%B5%96%EF%BC%88Stack-Pointer-Tracking-for-Dependency-Removal%EF%BC%89"><span class="toc-nav-number">3.9.6.</span> <span class="toc-nav-text">2.9.6 栈指针跟踪以消除依赖（Stack Pointer Tracking for Dependency Removal）</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#2-9-7-%E6%8C%87%E4%BB%A4%E5%88%86%E5%8F%91-Dispatch"><span class="toc-nav-number">3.9.7.</span> <span class="toc-nav-text">2.9.7 指令分发 Dispatch</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#2-9-8-%E4%BD%BF%E7%94%A8-PAUSE-%E6%8C%87%E4%BB%A4%E4%BC%98%E5%8C%96%E8%87%AA%E6%97%8B%E5%BE%AA%E7%8E%AF%EF%BC%88Span-Loop%EF%BC%89"><span class="toc-nav-number">3.9.8.</span> <span class="toc-nav-text">2.9.8 使用 PAUSE 指令优化自旋循环（Span Loop）</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#2-9-9-%E5%85%B6%E4%BB%96%E8%A7%A3%E7%A0%81%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%EF%BC%88Other-Decode-Considerations%EF%BC%89"><span class="toc-nav-number">3.9.9.</span> <span class="toc-nav-text">2.9.9 其他解码注意事项（Other Decode Considerations）</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#2-10-%E6%95%B4%E6%95%B0%E6%89%A7%E8%A1%8C%E5%8D%95%E5%85%83%EF%BC%88Integer-Execution-Unit%EF%BC%89"><span class="toc-nav-number">3.10.</span> <span class="toc-nav-text">2.10 整数执行单元（Integer Execution Unit）</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#2-10-1-Schedulers"><span class="toc-nav-number">3.10.1.</span> <span class="toc-nav-text">2.10.1 Schedulers</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#2-10-2-%E6%89%A7%E8%A1%8C%E5%8D%95%E5%85%83%EF%BC%88Execution-Units%EF%BC%89"><span class="toc-nav-number">3.10.2.</span> <span class="toc-nav-text">2.10.2 执行单元（Execution Units）</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#2-10-3-%E9%80%80%E5%BD%B9%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83%EF%BC%88Retire-Control-Unit-RCU%EF%BC%89"><span class="toc-nav-number">3.10.3.</span> <span class="toc-nav-text">2.10.3 退役控制单元（Retire Control Unit, RCU）</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#2-11-%E6%B5%AE%E7%82%B9%E5%8D%95%E5%85%83-%EF%BC%88Floating-Point-Unit%EF%BC%89"><span class="toc-nav-number">3.11.</span> <span class="toc-nav-text">2.11 浮点单元 （Floating-Point Unit）</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#2-11-1-%E6%B5%AE%E7%82%B9%E6%89%A7%E8%A1%8C%E8%B5%84%E6%BA%90-Floating-Point-Execution-Resources"><span class="toc-nav-number">3.11.1.</span> <span class="toc-nav-text">2.11.1 浮点执行资源 Floating Point Execution Resources</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#2-11-2-%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96%E5%BB%BA%E8%AE%AE%EF%BC%88Code-Recommendations%EF%BC%89"><span class="toc-nav-number">3.11.2.</span> <span class="toc-nav-text">2.11.2 代码优化建议（Code Recommendations）</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#2-11-3-x87-%E4%BB%A3%E7%A0%81%E7%9A%84%E6%B5%AE%E7%82%B9%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"><span class="toc-nav-number">3.11.3.</span> <span class="toc-nav-text">2.11.3 x87 代码的浮点性能优化</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#2-11-4-%E9%9D%9E%E8%A7%84%E6%A0%BC%E5%8C%96%E6%95%B0%EF%BC%88Denormals%EF%BC%89"><span class="toc-nav-number">3.11.4.</span> <span class="toc-nav-text">2.11.4 非规格化数（Denormals）</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#2-11-5-XMM-%E5%AF%84%E5%AD%98%E5%99%A8%E5%90%88%E5%B9%B6%E4%BC%98%E5%8C%96"><span class="toc-nav-number">3.11.5.</span> <span class="toc-nav-text">2.11.5 XMM 寄存器合并优化</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#2-11-6-%E6%B7%B7%E5%90%88%E4%BD%BF%E7%94%A8-AVX-%E5%92%8C-SSE-%E6%8C%87%E4%BB%A4%E7%9A%84%E6%80%A7%E8%83%BD%E6%83%A9%E7%BD%9A"><span class="toc-nav-number">3.11.6.</span> <span class="toc-nav-text">2.11.6 混合使用 AVX 和 SSE 指令的性能惩罚</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#2-11-7-%E4%BD%95%E6%97%B6%E4%BD%BF%E7%94%A8-FMA-%E8%80%8C%E9%9D%9E-FMUL-FADD"><span class="toc-nav-number">3.11.7.</span> <span class="toc-nav-text">2.11.7 何时使用 FMA 而非 FMUL&#x2F;FADD</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#2-12-%E5%8A%A0%E8%BD%BD-%E5%AD%98%E5%82%A8%E5%8D%95%E5%85%83%EF%BC%88Load-Store-Unit-LS%EF%BC%89"><span class="toc-nav-number">3.12.</span> <span class="toc-nav-text">2.12 加载-存储单元（Load-Store Unit, LS）</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#2-12-1-%E6%95%B0%E6%8D%AE%E9%A2%84%E5%8F%96%EF%BC%88Prefetching-of-Data%EF%BC%89"><span class="toc-nav-number">3.12.1.</span> <span class="toc-nav-text">2.12.1 数据预取（Prefetching of Data）</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#2-13-%E5%86%99%E5%85%A5%E6%95%B0%E6%8D%AE%E4%BC%98%E5%8C%96%EF%BC%88Optimizing-Writing-Data%EF%BC%89"><span class="toc-nav-number">3.13.</span> <span class="toc-nav-text">2.13 写入数据优化（Optimizing Writing Data）</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#2-13-1-%E8%BD%AF%E4%BB%B6%E9%A2%84%E5%8F%96%E6%95%B0%E6%8D%AE%E6%88%96%E6%8C%87%E4%BB%A4"><span class="toc-nav-number">3.13.1.</span> <span class="toc-nav-text">2.13.1 软件预取数据或指令</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#2-13-2-%E5%86%99%E5%90%88%E5%B9%B6%E6%93%8D%E4%BD%9C%EF%BC%88Write-Combining-Operations%EF%BC%89"><span class="toc-nav-number">3.13.2.</span> <span class="toc-nav-text">2.13.2 写合并操作（Write-Combining Operations）</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#2-13-3-%E5%B0%86%E5%86%99%E7%BC%93%E5%86%B2%E5%8C%BA%E6%95%B0%E6%8D%AE%E5%8F%91%E9%80%81%E5%88%B0%E7%B3%BB%E7%BB%9F%EF%BC%88Sending-Write-Buffer-Data-to-the-System%EF%BC%89"><span class="toc-nav-number">3.13.3.</span> <span class="toc-nav-text">2.13.3 将写缓冲区数据发送到系统（Sending Write-Buffer Data to the System）</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#2-13-4-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AD%98%E5%82%A8%E4%BC%98%E5%8C%96%EF%BC%88String-Store-Optimizations%EF%BC%89"><span class="toc-nav-number">3.13.4.</span> <span class="toc-nav-text">2.13.4 字符串存储优化（String Store Optimizations）</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#2-14-%E5%90%8C%E6%AD%A5%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88Simultaneous-Multi-Threading-SMT%EF%BC%89"><span class="toc-nav-number">3.14.</span> <span class="toc-nav-text">2.14 同步多线程（Simultaneous Multi-Threading, SMT）</span></a></li></ol></li></ol>
            
          
          </div>
        </aside>
      
    

                
            <!-- Sidebar Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                sidebar-container">

                <!-- Featured Tags -->
                
                <section>
                    <!-- no hr -->
                    <!-- <h5><a href="/tags/">FEATURED TAGS</a></h5> -->
                    <h5><a href="/tags/"></a></h5>
                    <div class="tags">
                       
                          <a class="tag" href="/tags/#x86" title="x86">x86</a>
                        
                          <a class="tag" href="/tags/#微架构" title="微架构">微架构</a>
                        
                    </div>
                </section>
                

                <!-- Friends Blog -->
                
                
                <script src="https://giscus.app/client.js"
                    data-repo="AllenZF/allenzf.github.io"
                    data-repo-id="R_kgDOQMASLQ"
                    data-category="General"
                    data-category-id="DIC_kwDOQMASLc4CxR4Q"
                    data-mapping="pathname"
                    data-strict="0"
                    data-reactions-enabled="1"
                    data-emit-metadata="0"
                    data-input-position="bottom"
                    data-theme="preferred_color_scheme"
                    data-lang="en"
                    crossorigin="anonymous"
                    async>
                </script>

            </div>
        </div>
    </div>
</article>




<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>
<!-- anchor-js, Doc:http://bryanbraun.github.io/anchorjs/ -->
<script>
    async("https://cdn.bootcss.com/anchor-js/1.1.1/anchor.min.js",function(){
        anchors.options = {
          visible: 'hover',
          placement: 'left',
          icon: 'ℬ'
        };
        anchors.add().remove('.intro-header h1').remove('.subheading').remove('.sidebar-container h5');
    })
</script>


<style  type="text/css">
    /* place left on bigger screen */
    @media all and (min-width: 800px) {
        .anchorjs-link{
            position: absolute;
            left: -0.75em;
            font-size: 1.1em;
            margin-top : -0.1em;
        }
    }
</style>



    <!-- Footer -->
    <!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">

                
                    <li>
                        <a target="_blank"  href="https://github.com/AllenZF">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                

                
                    <li>
                        <a target="_blank" href="https://gitee.com/Sven">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-stack-1x fa-inverse">码</i>
                            </span>
                        </a>
                    </li>
                

                

                
                    <li>
                        <a target="_blank" href="https://www.zhihu.com/people/people/zhou-lang-jie-feng">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa  fa-stack-1x fa-inverse">知</i>
                            </span>
                        </a>
                    </li>
                

                

                

                

                </ul>
                <p class="copyright text-muted">
                    Copyright &copy; 周郎借风 2025 
                    <br>
                    Powered by 
                    <a href="https://github.com/dusign/hexo-theme-snail">
                        <i>hexo-theme-snail</i>
                    </a> | 
                    <iframe name="star" style="margin-left: 2px; margin-bottom:-5px;" frameborder="0" scrolling="0"
                        width="100px" height="20px"
                        src="https://ghbtns.com/github-btn.html?user=dusign&repo=hexo-theme-snail&type=star&count=true">
                    </iframe>
                </p>
            </div>
        </div>
    </div>

</footer>

<!-- jQuery -->

<script src="/js/jquery.min.js"></script>


<!-- Bootstrap Core JavaScript -->

<script src="/js/bootstrap.min.js"></script>


<!-- Custom Theme JavaScript -->

<script src="/js/hux-blog.min.js"></script>


<!-- Search -->

<script src="/js/search.js"></script>


<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>


<!-- jquery.tagcloud.js -->
<script>
    // only load tagcloud.js in tag.html
    if($('#tag_cloud').length !== 0){
        async("https://allenzf.github.io/js/jquery.tagcloud.js",function(){
            $.fn.tagcloud.defaults = {
                //size: {start: 1, end: 1, unit: 'em'},
                color: {start: '#bbbbee', end: '#0085a1'},
            };
            $('#tag_cloud a').tagcloud();
        })
    }
</script>

<!--fastClick.js -->
<script>
    async("https://cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js", function(){
        var $nav = document.querySelector("nav");
        if($nav) FastClick.attach($nav);
    })
</script>


<!-- Google Analytics -->


<script>
    // dynamic User by Hux
    var _gaId = 'UA-XXXXXXXX-X';
    var _gaDomain = 'yoursite';

    // Originial
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', _gaId, _gaDomain);
    ga('send', 'pageview');
</script>




<!-- Baidu Tongji -->


<!-- Search -->

    <script type="text/javascript">      
        var search_path = "search.xml";
        if (search_path.length == 0) {
            search_path = "search.xml";
        }
    var path = "/" + search_path;
    searchFunc(path, 'local-search-input', 'local-search-result');
    </script>


<!-- busuanzi -->
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>






	<a id="rocket" href="#top" class=""></a>
	<script type="text/javascript" src="/js/totop.js?v=1.0.0" async=""></script>
    <script type="text/javascript" src="/js/toc.js?v=1.0.0" async=""></script>

    
        <!-- background effects line -->
        

        
            <script type="text/javascript" src="/js/mouse-click.js" content='[&quot;🌱&quot;,&quot;just do it&quot;,&quot;🍀&quot;]' color='[&quot;rgb(121,93,179)&quot; ,&quot;rgb(76,180,231)&quot; ,&quot;rgb(184,90,154)&quot;]'></script>
        

        <!-- background effects end -->
    

    <!--<script size="50" alpha='0.3' zIndex="-999" src="/js/ribbonStatic.js"></script>-->
    
        <script src="/js/ribbonDynamic.js"></script>
    
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</body>

</html>
